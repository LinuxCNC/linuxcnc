;hpid_touchoff (SIMULATION)

;NOTE: M66 is a queuebuster and fails if eoffset active
;      so check for arc-ok must be made beofre
;      enabling offsets

o<hpid_touchoff> sub
  #<pierce_height> = #1
   #<pierce_delay> = #2
     #<cut_height> = #3
    #<arc_timeout> = #4 
    #<probe_speed> = #5
   #<to_hgt_speed> = #6

(debug, hpid_touchoff BEGIN)
;---------------------------------------
F#<probe_speed>
;NOTE: probe and set Z0 here
;---------------------------------------
G1 Z#<pierce_height>
M3 S1 ;start torch & assert first enable (enable-in-a) for eoffset
(debug, torch on, wait #<arc_timeout>)

M66 P0 L1 Q#<arc_timeout>
          ;M66 wait on digital input (arc-ok)
          ;
          ;NOTE: M66 is a queubuster and must be sampled before
          ;      external offsets are fully enabled by the M64 below
          ;
          ;P0 motion.digital-in-00
          ;L1 wait low to high
          ;Q5 timeout seconds
          ;   if timeout: #5399 == -1
#<arc_status> = #5399
o<if1> if [#<arc_status> LT 0]
          (debug, arc FAIL, bye)
          M2
o<if1> else
          M64 P0
          ;M64 set digital output ON to finish enabling (enable-in-b) eoffset
          ;NOTE: any queuebusters occuring while external offsets
          ;      are applied will STOP motion and end a running 
          ;      program
          (debug, arc OK, continue)
o<if1> endif

(debug, pierce_delay #<pierce_delay>)
G4 P#<pierce_delay>

F#<to_hgt_speed>
G1 Z#<cut_height>
(debug, hpid_touchoff END)

o<hpid_touchoff> endsub
