/********************************************************************
* Description: tof.comp
*   IEC_61131-3 Time Off timer for HAL bit signals.
*
*   This is a HAL component that can be used to delay falling edge signals
*   for a certain amount of time.
*
*********************************************************************
*
* Author: Chad Woitas (aka satiowadahc)
* License: GPL Version 2
* Created on: 2021/06/10
* System: Linux
*
* Copyright (c) 2021 All rights reserved.
*
* Last change: Creation
*
********************************************************************/

#include "rtapi.h"
#include "rtapi_app.h"
#include "hal.h"
#include "rtapi_errno.h"
#include "rtapi_string.h"

/* module information */
MODULE_AUTHOR("Chad Woitas");
MODULE_DESCRIPTION("IEC TOFF - Off Delay Timer");
MODULE_LICENSE("GPL");


#define NS_SECONDS(X) ((float)X/1000000000)
#define MAX_TIMERS 255

static int cfg[MAX_TIMERS];

RTAPI_MP_ARRAY_INT(cfg, MAX_TIMERS, "Group size for up to 255 timers");

/***********************************************************************
*                STRUCTURES AND GLOBAL VARIABLES                       *
************************************************************************/

typedef struct{
    hal_bit_t *in;  // Input
    hal_float_t *pt;  // Pulse Timer
    hal_bit_t *q;   // Output
    hal_float_t *et;  // Elapsed Time since on in High
} t_off_t;

static t_off_t *timer_array;

/* other globals */
static int comp_id;		  /* component ID */

static int num_timers;	/* number of individual timers */


/***********************************************************************
*                  LOCAL FUNCTION DECLARATIONS                         *
************************************************************************/

static int export_timer(int num, t_off_t * addr);
static void update(void *arg, long period);


int rtapi_app_main(void){

   int retval, n;

  /* count number of timers */
  num_timers = 0;
  while ((num_timers < MAX_TIMERS) && (cfg[num_timers] != 0)) {
    if ((cfg[num_timers] < 1) || (cfg[num_timers] > MAX_TIMERS)) {
      rtapi_print_msg(RTAPI_MSG_ERR,
                      "IEC_TOFF: ERROR: bad group size '%d'\n", cfg[num_timers]);
      return -1;
    }
    num_timers += cfg[num_timers];
    num_timers++;
  }
  /* OK, now we've counted everything */
  if (num_timers == 0) {
    rtapi_print_msg(RTAPI_MSG_ERR,
                    "IEC_TOFF: ERROR: no channels configured\n");
    return -1;
  }

  /* have good config info, connect to the HAL */
  comp_id = hal_init("t_off");
  if (comp_id < 0) {
    rtapi_print_msg(RTAPI_MSG_ERR,
                    "IEC_TOFF: ERROR: hal_init() failed\n");
    return -1;
  }

  /* allocate shared memory for timer group array */
  timer_array = hal_malloc(num_timers * sizeof(t_off_t));
  if (timer_array == 0) {
    rtapi_print_msg(RTAPI_MSG_ERR,
                    "IEC_TOFF: ERROR: hal_malloc() failed\n");
    hal_exit(comp_id);
    return -1;
  }

  /* export all vars */
  for (n = 0; n < num_timers; n++) {
    retval = export_timer(n, &(timer_array[n]));
    if (retval != 0) {
      rtapi_print_msg(RTAPI_MSG_ERR,
                      "IEC_TOFF: ERROR: group %d export failed\n", n);
      hal_exit(comp_id);
      return -1;
    }
  }

  retval = hal_export_funct("t_off.update", update, timer_array, 0, 0, comp_id);

  rtapi_print_msg(RTAPI_MSG_INFO,
                  "IEC_TOFF: installed %d groups of IEC_TOFF timers, %d total\n",
                  num_timers, num_timers);

  hal_ready(comp_id);
  return 0;
}

void rtapi_app_exit(void){
  hal_exit(comp_id);
}

static void update(void *arg, long period){
  t_off_t *timer;

  timer = arg;

  if(*(timer->pt) < 0) {
    *(timer->pt) = 0;
    rtapi_print_msg(RTAPI_MSG_WARN,
                    "IEC_TP: Pulse time must be positive, resetting to 0");
  }
  if(*(timer->et) < 0) {
    *(timer->et) = 0;
    rtapi_print_msg(RTAPI_MSG_WARN,
                    "IEC_TP: Elapsed time rolled over, resetting to 0");
  }

  float seconds = NS_SECONDS(period);

  // Check timers
  if(*(timer->in)){
    *(timer->q) = 1;
    *(timer->et) = 0;
  }
  else{
    // Update outputs
    if(*(timer->et) > *(timer->pt)){
      *(timer->q) = 0;
    }
    else{
      *(timer->et) += seconds;
    }
  }

}


/***********************************************************************
*                   LOCAL FUNCTION DEFINITIONS                         *
************************************************************************/

static int export_timer(int num, t_off_t * addr)
{
  int retval, msg;

  /* This function exports a lot of stuff, which results in a lot of
     logging if msg_level is at INFO or ALL. So we save the current value
     of msg_level and restore it later.  If you actually need to log this
     function's actions, change the second line below */
  msg = rtapi_get_msg_level();
  rtapi_set_msg_level(RTAPI_MSG_WARN);

  /* Export Pins */
  retval = hal_pin_bit_newf(HAL_IN, &(addr->in), comp_id,
                            "t_off.%d.in", num);
  if (retval != 0) { return retval; }

  retval = hal_pin_float_newf(HAL_IN, &(addr->pt), comp_id,
                            "t_off.%d.pt", num);
  if (retval != 0) { return retval; }

  retval = hal_pin_bit_newf(HAL_OUT, &(addr->q), comp_id,
                            "t_off.%d.q", num);
  if (retval != 0) { return retval; }

  retval = hal_pin_float_newf(HAL_OUT, &(addr->et), comp_id,
                            "t_off.%d.et", num);
  if (retval != 0) { return retval; }


  *(addr->in) = 0;
  *(addr->pt) = 1;


  /* restore saved message level */
  rtapi_set_msg_level(msg);
  return 0;
}

