component plasmac "A plasma cutter controller";

description
"""

A plasma cutting table control component for use with the LinuxCNC 2.10.

.I VERSION:
.br
008

.I SUMMARY:
.br
Usage of this component is demonstrated in the QtPlasmaC example configurations included with LinuxCNC.

.I DISCLAIMER:
.br
THE AUTHOR OF THIS SOFTWARE ACCEPTS ABSOLUTELY NO LIABILITY FOR ANY HARM OR LOSS RESULTING FROM ITS USE.

IT IS EXTREMELY UNWISE TO RELY ON SOFTWARE ALONE FOR SAFETY.

Any machinery capable of harming persons must have provisions for completely stopping all motors and moving parts etc. before persons enter any danger area.

All machinery must be designed to comply with local and national safety codes, and the author of this software can not, and does not, take any responsibility for such compliance.
""";

/* INPUT PINS */
pin in  float   arc_fail_delay              "arc start failure timeout (seconds)";
pin in  float   arc_lost_delay              "arc lost delay during a cut (seconds)";
pin in  float   arc_ok_high                 "maximum voltage level for Arc OK signal [mode 0] (volts)";
pin in  bit     arc_ok_in                   "external arc ok input signal [mode 1 & mode 2]";
pin in  float   arc_ok_low                  "minimum voltage level for Arc OK signal [mode 0] (volts)";
pin in  s32     arc_max_starts              "maximum attempts at starting the arc";
pin in  float   arc_voltage_in              "arc voltage input [mode 0 & mode 1] see Notes above";
pin in  float   arc_voltage_offset          "offset to set arc voltage to 0 at 0 volts";
pin in  float   arc_voltage_scale           "scale to convert arc_voltage input to actual volts";
pin in  bit     thc_auto                    "enable automatic thc activation";
pin in  float   axis_x_max_limit            "axis x maximum limit, connect to ini.x.max-limit";
pin in  float   axis_x_min_limit            "axis x minimum limit, connect to ini.x.min-limit";
pin in  float   axis_x_position             "current x axis position, connect to axis.x.pos-cmd";
pin in  float   axis_y_max_limit            "axis y maximum limit, connect to ini.y.max-limit";
pin in  float   axis_y_min_limit            "axis y minimum limit, connect to ini.y.min-limit";
pin in  float   axis_y_position             "current y axis position, connect to axis.y.pos-cmd";
pin in  float   axis_z_max_limit            "axis z maximum limit, connect to ini.z.max-limit";
pin in  float   axis_z_min_limit            "axis z minimum limit, connect to ini.z.min-limit";
pin in  float   axis_z_position             "current z axis position, connect to joint.N.pos-fb";
pin in  bit     breakaway                   "torch breakaway switch (optional, see float_switch)";
pin in  bit     consumable_change           "change consumables in torch";
pin in  bit     cornerlock_enable           "enable corner lock";
pin in  float   cornerlock_threshold        "corner lock threshold (% of requested feed rate), speeds below this disable THC";
pin in  float   current_velocity            "current machine velocity, connect to motion.current-vel";
pin in  float   cut_feed_rate               "cut feed rate from current material (machine units per minute)";
pin in  float   cut_height                  "cut height (machine units)";
pin in  bit     cut_recovery                "recover from cut error";
pin in  float   cut_volts                   "cut voltage (volts)";
pin in  bit     cutting_start               "start a new cut, connect to spindle.0.on";
pin in  bit     debug_print                 "if true will print state changes as a debug aid";
pin in  bit     dry_run                     "perform a dry run without probing";
pin in  bit     external_estop              "external E-stop input";
pin in  float   feed_override               "feed override value from GUI (connect to halui.feed-override.value)";
pin in  float   feed_reduction              "reduce adaptive feed to this percentage (connect to motion.analog-out-03)";
pin in  bit     float_switch                "float switch input (can also act as breakaway if it actuates when torch breaks away)";
pin in  float   float_switch_travel         "float switch travel (machine units)";
pin in  float   gcode_scale = 1             "current G-code scale";
pin in  float   height_override             "height override adjustment (volts)";
pin in  float   height_per_volt             "torch height change per volt (machine units)";
pin in  bit     homed                       "machine is homed";
pin in  bit     ignore_arc_ok_0             "don't require arc ok for start or cutting";
pin in  bit     ignore_arc_ok_1             "don't require arc ok for start or cutting";
pin in  float   kerf_width                  "placeholder for better G-code portability between GUIs";
pin in  bit     override_jog                "override jog inhibit";
pin in  bit     offset_set_probe            "deploy probe for setting offsets";
pin in  bit     offset_set_scribe           "deploy scribe for setting offsets";
pin in  bit     laser_mode                  "laser mode for fiber lasers";
pin in  s32     laser_recovery_start        "start laser offset for cut recovery";
pin in  s32     laser_x_offset              "alignment laser x axis offset (scaled units)";
pin in  s32     laser_y_offset              "alignment laser y axis offset (scaled units)";
pin in  float   lowpass_frequency           "lowpass cutoff frequency for arc voltage output";
pin in  bit     machine_is_on               "machine is on signal";
pin in  s32     max_offset = 5              "maximum height offset";
pin in  bit     mesh_arc_ok = FALSE         "don't require arc ok for mesh mode";
pin in  bit     mesh_enable                 "enable mesh cutting mode";
pin in  s32     mode                        "operating mode";
pin in  s32     motion_type                 "motion type, connect to motion.motion-type";
pin in  bit     move_down                   "external thc down switch [mode 2]";
pin in  bit     move_up                     "external thc up switch [mode 2]";
pin in  bit     multi_tool = 1              "allows the use of multiple tools";
pin in  float   offset_feed_rate            "probe offset velocity (machine units per minute)";
pin in  float   offset_probe_delay          "wait for probe to deploy (seconds)";
pin in  float   offset_probe_x              "X axis offset for offset probe (machine units)";
pin in  float   offset_probe_y              "Y axis offset for offset probe (machine units)";
pin in  bit     offsets_active              "offsets are active, connect to motion.eoffsets-active";
pin in  s32     ohmic_sense_on_delay = 3    "debounce cycles for ohmic sense on";
pin in  s32     ohmic_sense_off_delay = 3   "debounce cycles for ohmic sense off";
pin in  bit     ohmic_sense_in              "ohmic sense relay input";
pin in  s32     ohmic_max_attempts          "maximum ohmic probe attempts before fallback to float switch";
pin in  bit     ohmic_probe                 "ohmic probe input, from ohmic-sense-out or external component/pin";
pin in  bit     ohmic_probe_enable          "enable ohmic probe";
pin in  float   ohmic_probe_offset          "Z axis offset for ohmic probe (machine units)";
pin in  bit     ohmic_test                  "test for shorted torch";
pin in  s32     ok_sample_counts = 10       "arc_ok number of valid samples required [mode 0]";
pin in  float   ok_sample_threshold = 10    "arc_ok maximum arc voltage deviation allowed [mode 0]";
pin in  float   pause_at_end                "time to pause at end of cut";
pin in  float   paused_motion_speed         "multiplier for speed of motion when paused, from -1 to 1";
pin in  float   pid_d_gain                  "derivative gain input [mode 0 & mode 1]";
pin in  float   pid_i_gain                  "integral gain input [mode 0 & mode 1]";
pin in  float   pid_p_gain                  "proportional gain input [mode 0 & mode 1]";
pin in  float   pierce_delay                "time required to pierce stock (seconds)";
pin in  float   probe_feed_rate             "probe down velocity (machine units per minute)";
pin in  s32     probe_final_speed = 1       "final probe speed (steps per servo period)";
pin in  float   pierce_height               "pierce height (machine units)";
pin in  float   probe_start_height          "probe starting height";
pin in  bit     probe_test                  "probe test only";
pin in  bit     program_is_idle             "program is idle, connect to halui.program.is-idle";
pin in  bit     program_is_paused           "program is paused, connect to halui.program.is-paused";
pin in  bit     program_is_running          "program is running, connect to halui.program.is-running";
pin in  float   puddle_jump_delay           "Delay move from pierce height to cut height (seconds), leave disconnected if not required.";
pin in  float   puddle_jump_height          "Puddle jump height (percentage of pierce height), leave disconnected if not required.";
/* requested_velocity is deprecated in favour of feed_upm, the pin is kept so as not to break existing configs */
pin in  float   requested_velocity          "deprecated";
pin in  float   feed_upm                    "requested feed_rate, connect to motion.feed-upm to use as the default (G-code units per minute)";
pin in  s32     resolution = 100            "multiplier for resolution of the offset counts";
pin in  float   restart_delay               "time from arc failure till next restart attempt";
pin in  float   safe_height                 "requested safe traverse height (machine units)";
pin in  float   scribe_arm_delay            "delay from scribe arm to scribe on";
pin in  float   scribe_on_delay             "delay from scribe on to motion beginning";
pin in  bit     scribe_start                "start a new scribe, connect to spindle.1.on";
pin in  float   setup_feed_rate             "feed rate for moves to pierce and cut heights (machine units per minute)";
pin in  float   skip_ihs_distance           "skip IHS if less than this distance from last cut";
pin in  bit     spotting_start              "start a new spot, connect to spindle.2.on";
pin in  float   spotting_threshold          "threshold voltage to start spotting delay";
pin in  float   spotting_time               "torch off delay after spotting threshold reached";
pin in  float   thc_delay                   "delay from cut feed rate reached to THC activate (seconds) [non auto THC]";
pin in  bit     thc_disable                 "thc disable";
pin in  bit     thc_enable                  "enable/disable thc and set the IHS skip type";
pin in  float   thc_feed_rate               "maximum feed rate for thc (machine units per minute)";
pin in  s32     thc_sample_counts = 50      "thc number of valid samples required [auto THC]";
pin in  float   thc_sample_threshold = 1    "thc maximum arc voltage deviation allowed [auto THC]";
pin in  float   thc_threshold               "thc threshold (volts), changes below this have no effect";
pin in  bit     torch_enable                "enable torch";
pin in  bit     torch_off                   "turn torch off";
pin in  bit     torch_pulse_start           "torch pulse start";
pin in  float   torch_pulse_time            "torch pulse time (seconds)";
pin in  bit     tube_cut                    "set the current job as tube cutting";
pin in  float   units_per_mm                "for scale calcs, connect to halui.machine.units-per-mm";
pin in  bit     use_auto_volts              "use calculated voltage for thc baseline";
pin in  bit     voidlock_enable             "enable voidlock [mode 0 & mode 1]";
pin in  s32     voidlock_on_cycles = 2      "number of sampling cycles to activate voidlock ";
pin in  s32     voidlock_off_cycles = 10    "number of sampling cycles to deactivate voidlock";
pin in  s32     voidlock_slope = 500        "voidlock slope in volts per second";
pin in  s32     x_offset                    "offset to apply to axis x for consumable change and cut recovery (scaled units)";
pin in  float   x_offset_current            "current x axis offset, connect to axis.x.eoffset";
pin in  float   xy_feed_rate                "feed-rate for consumable change";
pin in  s32     y_offset                    "offset to apply to axis y for consumable change and cut recovery (scaled units)";
pin in  float   y_offset_current            "current z axis offset, connect to axis.y.eoffset";
pin in  float   z_offset_current            "current z axis offset, connect to axis.z.eoffset";
pin in  float   zero_window = 0.1           "sets window that voltage fluctuations show as zero (-0.1 to 0.1 at default value)";
// Pierce user control pins
pin in  unsigned  pierce_type = 0           "allows motion to progress during pierce. 0=No movement, 1=Wiggle, 2=Ramp";
pin in  float   pierce_motion_delay = 0     "delay starting motion during pierce delay period. This is a % of Pierce Delay. Only used when pierce-with-motion is True";
pin in  float   cut_height_delay = 0        "at the end of transition to end-pierce-height how long to pause before transition to cut height";
pin in  float   pierce_end_height = 0       "The height at end of piercing (in machine units). Can be different to Cut Height. Default 0 means not used. i.e. no change in height";
pin in  float   gouge_speed = 0             "Ramp starting speed for gouge. In machine units/min.";
pin in  float   gouge_speed_distance = 0    "Distance gouge will run in machine units. Gouge plus creep distance should not be longer than any lead in";
pin in  float   creep_speed = 0             "Ramp creep or intermediate speed. Comes after gouge and is before cut speed. In machine units/min.";
pin in  float   creep_speed_distance = 0    "Distance creep will run in machine units. Gouge plus creep distance should not be longer than any lead in";

/* OUTPUT PINS */
pin out float   adaptive_feed               "for reverse-run, connect to motion.adaptive-feed";
pin out bit     arc_ok_out                  "arc ok output";
pin out float   arc_voltage_out             "arc voltage output [mode 0 & mode 1]";
pin out bit     consumable_changing         "consumables are being changed";
pin out bit     cornerlock_is_locked        "corner locked indicator";
pin out float   cut_length                  "length of current cut job";
pin out bit     cut_recovering              "recovering from cut error";
pin out float   cut_time                    "cut time of current job";
pin out bit     cutting_stop                "stop manual cut, connect to halui.spindle.0.stop";
pin out bit     feed_hold                   "feed hold, connect to motion.feed-hold";
pin out bit     jog_inhibit                 "jog inhibit, connect to motion.jog-inhibit";
pin out s32     laser_recovery_state        "laser recovery status";
pin out bit     led_down                    "thc move down indicator";
pin out bit     led_up                      "thc move up indicator";
pin out float   offset_scale                "offset scale, connect to axis.<x y z>.eoffset-scale";
pin out bit     ohmic_enable                "on only while probing";
pin out bit     ohmic_sense_out             "ohmic sense output state";
pin out bit     paused_motion               "paused motion flag, true when paused motion is active";
pin out float   paused_time                 "paused time during current job";
pin out s32     pierce_count                "number of pierce attempts (torch starts)";
pin out bit     probe_out                   "probe for tube cutting, connect to motion.probe-input";
pin out bit     probe_test_error            "minimum limit reached while probe testing";
pin out float   probe_time                  "probe time of current job";
pin out bit     program_pause               "pause the current program, connect to halui.program.pause";
pin out bit     program_resume              "resume the currently paused program, connect to halui.program.resume";
pin out bit     program_run                 "run the currently loaded program, connect to halui.program.run";
pin out bit     program_stop                "stop current program, connect to halui.program.stop";
pin out float   rapid_time                  "rapid motion time of current job";
pin out float   run_time                    "run time of current job";
pin out bit     safe_height_is_limited      "safe height is limited indicator";
pin out bit     sensor_active               "one of float, ohmic, or breakaway is detected";
pin out bit     scribe_arm                  "arm the scribe";
pin out bit     scribe_on                   "turn scribe on";
pin out s32     state_out                   "current state";
pin out s32     stop_type_out               "current stop type";
pin out bit     thc_active                  "thc status output";
pin out bit     thc_enabled                 "thc is enabled";
pin out bit     torch_on                    "turn torch on, connect to your torch on input";
pin out float   torch_time                  "torch on time of current job";
pin out bit     voidlock_is_locked          "voidlock is locked indicator [mode 0 & mode 1]";
pin out s32     x_offset_counts             "x offset for consumable change, connect to axis.x.eoffset-counts";
pin out bit     xy_offset_enable            "enable x and y offsets, connect to axis.<x & y>.eoffset-enable";
pin out s32     y_offset_counts             "y offset for consumable change, connect to axis.y.eoffset-counts";
pin out float   z_height                    "current z axis height relative to the probed zero height";
pin out s32     z_offset_counts             "z offset for height control, connect to axis.z.eoffset-counts";
pin out bit     z_offset_enable             "enable z offsets, connect to axis.z.eoffset-enable";
pin out float   z_relative                  "distance of Z from last probed height";

// temp for auto-thc testing
// check when we at "at speed"
pin out float   current_feed_rate           "current feed rate per minute";
pin out float   requested_feed_rate         "requested feed rate";

/* VARIABLES */
variable double angle_x_y;                  /* angle for x/y velocity calcs in radians*/
variable float  arc_fail_timer;             /* arc failure timer */
variable float  arc_lost_timer;             /* arc lost timer */
variable int    arc_starts;                 /* number of attempts to start torch */
variable float  arc_valid_timer;            /* timer to wait for valid arc_voltage_in */
variable float  arc_voltage_raw;            /* filtered arc voltage to be scaled */
variable int    arc_voltage_buffer_index;   /* arc voltage sampler write index */
variable int    ok_sampler_samples;         /* required number of arc ok samples [mode0] */
variable bool   auto_cut;                   /* auto cut mode is active */
variable float  axis_x_finish;              /* axis x position at end of cut */
variable float  axis_x_start;               /* axis x position at start of cut */
variable float  axis_y_finish;              /* axis y position at end of cut */
variable float  axis_y_start;               /* axis y position at start of cut */
variable int    cons_change_clear;          /* consumable change is clearing */
variable int    count;                      /* for counting */
variable int    cut_height_first;           /* cut height at start of cut */
variable int    cut_height_last;            /* cut height at end of cut */
variable float  cut_offset;                 /* offset from last cut end to this cut start */
variable bool   cut_started;                /* cut has started */
variable int    cut_target;                 /* cut height target offset */
variable bool   error_message;              /* 1 if error message has been sent */
variable bool   first_cut_finished;         /* first cut is complete */
variable bool   float_detected;             /* float switch detected */
variable int    height_ovr_counts;          /* number of counts to change height via override */
variable float  height_ovr_old;             /* old height override value */
variable bool   initialized;                /* initialization flag */
variable int    laser_x_target;             /* target count for laser recovery x offset */
variable int    laser_y_target;             /* target count for laser recovery y offset */
variable float  last_arc_voltage;           /* last sensed arc voltage */
variable bool   manual_cut;                 /* manual cut mode is active */
variable int    offset_datum;               /* datum for safe height calcs */
variable int    offset_max;                 /* maximum allowed offset */
variable int    offset_min;                 /* minimum allowed offset */
variable float  offset_probe_timer;         /* offset probe deployment delay time */
variable bool   offset_probing;             /* offset probing is enabled */
variable int    offset_res;                 /* resolution for comparing offset move to target*/
variable bool   offset_set;                 /* probe or scribe is being offset*/
variable int    offset_velocity;            /* velocity for probe offset moves */
variable int    ohmic_attempts;             /* current ohmic probe attempts */
variable bool   ohmic_detected;             /* true if ohmic probe detected */
variable int    ohmic_sense_counts;         /* ohmic sense debounce counter */
variable int    old_resolution;             /* previous resolution value */
variable int    op_x_start;                 /* x offset when offset probing started */
variable int    op_x_target;                /* target offset for x probe offset */
variable int    op_x_velocity;              /* velocity for x probe offset */
variable double op_xy_angle;                /* angle for x/y probe offset calcs in radians*/
variable int    op_y_start;                 /* y offset when offset probing started */
variable int    op_y_target;                /* target offset for y probe offset */
variable int    op_y_velocity;              /* velocity for y probe offset */
variable float  pause_at_end_timer;         /* pause at end of cut timer */
variable float  paused_motion_timer;        /* minimum run timer for paused motion */
variable float  pid_error_now;              /* current error for pid calcs */
variable float  pid_error_old;              /* old error for pid calcs */
variable float  pid_output;                 /* calculated pid output value */
variable int    pierce_target;              /* pierce height target offset */
variable float  pierce_timer;               /* pierce delay timer */
variable float  probe_at_bottom;            /* probe is at bottom limit */
variable bool   probe_inhibit;              /* inhibit probing */
variable int    probe_offset;               /* offset for active probe */
variable bool   probe_required = 1;         /* a probe sequence is required */
variable bool   probe_retry;                /* probe will retry after contact before probe height */
variable int    probe_start_target;         /* probe start height target */
variable bool   probe_testing;              /* probe test active */
variable int    probe_velocity;             /* probe down velocity */
variable int    puddle_jump_percent;        /* puddle jump height as percentage of pierce height */
variable int    puddle_jump_target;         /* puddle jump height target offset */
variable float  puddle_jump_timer;          /* puddle jump delay timer */
variable float  recovery_velocity;          /* cut recovery step velocity */
// temp for auto-thc testing
// created a out pin @ L204 to check when we at "at speed"
//variable float  requested_feed_rate;        /* requested feed rate */
variable int    res;                        /* resolution of offset move*/
variable float  restart_timer;              /* time between torch on attempts*/
variable int    safe_alarm;                 /* warn if safe_available falls below this value during a cut */
variable int    safe_available;             /* available safe height */
variable int    safe_min;                   /* minimum safe height allowed */
variable int    safe_preferred;             /* preferred safe height offset */
variable int    safe_target;                /* safe height target offset */
variable int    setup_velocity;             /* velocity for setup moves */
variable float  scribe_arm_timer;           /* scribe timer from arm to on*/
variable float  scribe_on_timer;            /* scribe timer from on to motion*/
variable bool   scribe_pause;               /* scribe pause flag */
variable bool   spotting;                   /* spotting flag */
variable float  spotting_timer;             /* spotting timer */
variable int    state_old = -1;             /* old state */
variable int    statistics_reset;           /* statistics are reset */
//temp for testing forum post #210558
//variable int    target_samples = 6;         /* number of samples for setting target_volts */
variable float  target_total;               /* total voltage of samples for setting target_volts */
//temp for testing forum post #210558
//variable float  target_volts;               /* target voltage for thc, set by arc voltage at cut height */
variable bool   thc_activated;              /* thc was activated */
variable float  thc_activated_timer;        /* timer to reset thc_activated - end of cut is detected from userspace :( */
variable float  thc_delay_timer;            /* thc delay timer [non auto THC] */
variable int    thc_sampler_samples;        /* required number of thc samples  [auto THC] */
variable int    thc_velocity;               /* velocity for thc moves */
variable float  torch_off_timer;            /* arc off delay timer */
variable float  torch_pulse_timer;          /* torch pulse timer */
variable float  velocity_scale;             /* the velocity multiplier */
variable float  voidlock_change;            /* voltage change this cycle */
variable float  voidlock_off_count;         /* current count of voidlock deactivate cycles */
variable int    voidlock_on_count;          /* current count of voidlock activate cycles */
variable float  voidlock_threshold;         /* voidlock threshold voltage per cycle */
variable int    x_velocity;                 /* velocity for x motion for consumable change */
variable int    y_velocity;                 /* velocity for y motion for consumable change */
variable int    z_max;                      /* max height for testing against pierce height*/
variable int    z_pierce;                   /* pierce height for testing against max height*/
variable int    zero_target;                /* zero height target offset */
// Pierce user control pins
variable float  pierce_motion_delay_timer;  /* delay starting motion during pierce delay period. Only used whrn pierce-type is 2. Is calced from a % of Pierce Delay*/
variable float  cut_height_delay_timer;     /* at the end of transition to end-perice-height how long to pause before transition to cut height*/
variable float  total_pierce_state_delay;   /* Total of pierce delay and cut motion delay */
variable int    pierce_end_target;          /* Target pierce height at end of pierce motion. Usually less than the starting pierce height */
variable float  gouge_speed_dist_travelled; /* Sum of distance traveled during gouge stage */
variable float  gouge_speed_scale;          /* scale of gouge speed in proportion to standard cut feed rate */
variable float  creep_speed_dist_travelled; /* Sum of distance traveled during creep stage */
variable float  creep_speed_scale;          /* scale of creep speed in proportion to standard cut feed rate */
variable float  pierce_old_x;               /* tracking the last x location during pierce */
variable float  pierce_old_y;               /* tracking the last y location during pierce */

// temp for testing forum post #210558
// https://forum.linuxcnc.org/plasmac/42690-is-this-qtplasmac-expected-behaviour-cycle-start-and-jog-disabled?start=0#210558
pin in  s32     low_cut_volts               "low cut voltage threshold while thc active";
pin in  s32     target_samples = 6          "number of samples for setting target_volts";
pin out float   target_volts                "target voltage for thc, set by arc voltage at cut height";


function _;

author "Phillip A Carter & Gregory D Carl";

license "GPLv2 or greater";

option singleton yes;

;;

#include "rtapi_math.h"

typedef enum{IDLE,
             PROBE_HEIGHT,
             PROBE_DOWN,
             PROBE_UP,
             ZERO_HEIGHT,
             PIERCE_HEIGHT,
             TORCH_ON,
             ARC_OK,
             PIERCE_DELAY,
             PUDDLE_JUMP,
             CUT_HEIGHT,
             CUT_MODE_01,
             CUT_MODE_2,
             PAUSE_AT_END,
             SAFE_HEIGHT,
             MAX_HEIGHT,
             END_CUT,
             END_JOB,
             TORCHPULSE,
             PAUSED_MOTION,
             OHMIC_TEST,
             PROBE_TEST,
             SCRIBING,
             CONSUMABLE_CHANGE_ON,
             CONSUMABLE_CHANGE_OFF,
             CUT_RECOVERY_ON,
             CUT_RECOVERY_OFF,
             DEBUG,
            } state_t;

typedef enum{NONE,
             STOP,
             WAIT,
             PAUSE,
            } stop_type_t;

typedef enum{ZERO,
             UP,
             DOWN,
            } move_direction_t;

typedef enum{FLOAT,
             OHMIC,
            } probe_type_t;

typedef enum{EMPTY,
             CUTTING,
             SCRIBE,
             SPOTTING,
            } tool_t;

typedef enum{OFF,
             SET,
             SETTING,
             ON,
             RESET,
             RESETTING,
         } laser_recovery_state_t;

state_t state = IDLE;
stop_type_t stop_type = NONE;
move_direction_t move_direction = ZERO;
probe_type_t probe_type = FLOAT;
tool_t tool = EMPTY;
laser_recovery_state_t laser_recovery = OFF;

/* setup the arc voltage ring buffer */
#define BUFFERSIZE 1000
#define READ_OK 0
#define READ_THC 1
float arc_voltage_buffer[BUFFERSIZE];

/* read the arc voltage buffer */
float read_arc_voltage_buffer(int caller, int size, int index, float target, float threshold){
    int reads = 0;
    double sum = 0;
    int errors = 0;
    while(reads < size){
        if (arc_voltage_buffer[index] < target - threshold || arc_voltage_buffer[index] > target + threshold){
            if(caller == READ_THC){
                return 0;
            }else{
                errors++;
            }
        }
        sum += arc_voltage_buffer[index];
        if(index == 0){
            index = BUFFERSIZE;
        }else{
            index--;
        }
        reads++;
    }
    if(caller == READ_THC){
        return(sum / reads);
    }else{
        return(errors);
    }
}

/* set an axis eoffset position at a set velocity */
int offset_move(int offset, int vel, int target){
    if(offset - vel > target){
        offset -= vel;
    }else if(offset + vel < target){
        offset += vel;
    }else{
        offset = target;
    }
    return offset;
}

FUNCTION(_) {

    /* set message level */
    if(!debug_print && rtapi_get_msg_level() != 1){
        rtapi_set_msg_level(1);
    }else if(debug_print && rtapi_get_msg_level() != 3){
        rtapi_set_msg_level(3);
    }

    /* validate ok sample size for mode 0 */
    if(mode == 0){
        if(ok_sample_counts < 1){
            ok_sampler_samples = 1;
        }else if(ok_sample_counts > BUFFERSIZE){
            ok_sampler_samples = BUFFERSIZE;
        }else{
            ok_sampler_samples = ok_sample_counts;
        }
    }

    /* validate thc sample size */
    if(mode < 2){
        if(thc_sample_counts < 1){
            thc_sampler_samples = 1;
        }else if(thc_sample_counts > BUFFERSIZE){
            thc_sampler_samples = BUFFERSIZE;
        }else{
            thc_sampler_samples = thc_sample_counts;
        }
    }

    /* wait until arc_voltage_in is valid */
    if(isinf(arc_voltage_in) || isnan(arc_voltage_in)){
        arc_valid_timer += fperiod;
        if(arc_valid_timer > 1){
            rtapi_print_msg(RTAPI_MSG_ERR,"invalid arc-voltage-in\n");
            arc_valid_timer = 0;
        }
        return;
    }

    /* set scaling */
    if(resolution > 1000){
        res = 1000;
    }else if(resolution < 1){
        res = 1;
    }else{
        res = resolution;
    }
    if(units_per_mm == 1){
        offset_res = res;
    }else{
        offset_res = res * 10;
    }
    offset_scale = units_per_mm * fperiod / res;
    velocity_scale = res / units_per_mm / 60;
    recovery_velocity = cut_feed_rate * velocity_scale * 0.5;

    /* set the active tool */
    if(cutting_start && !dry_run){ //  this allows M3 for cutting as well as M3 $0
        tool = CUTTING;
    }else if(multi_tool && scribe_start && !cutting_start && !spotting_start && !dry_run){
        tool = SCRIBE;
    }else if(multi_tool && spotting_start && !cutting_start && !scribe_start && !dry_run){
        tool = SPOTTING;
    }else{
        tool = EMPTY;
    }

    /* check for active sensor */
    if(breakaway || float_switch || ohmic_detected){
        sensor_active = TRUE;
    }else{
        sensor_active = FALSE;
    }
    probe_out = float_switch && tube_cut && state == IDLE;

// I don't recall why z_relative was originally created!!!
// commit # b29d1af 24 Oct 2019
//    /* output the relative Z height */
//    if(zero_target){
//        z_relative = z_offset_current - zero_target * offset_scale;
//    }else{
//        z_relative = axis_z_position - axis_z_min_limit;
//    }

// this height calculation is really only the target z height, we may not have reached the target yet
    /* output current z height */
//    z_height = (z_offset_counts - zero_target) * offset_scale;

// this is probably more correct
// we don't use z_relative anywhere so we could probably just rename it to z_height and remove the z_relative pin.
    /* output the relative Z height */
    if(zero_target){
        z_height = z_offset_current - (zero_target * offset_scale);
    }else{
        z_height = axis_z_position - axis_z_min_limit;
    }

// temp for auto-thc testing
//  check when we at "at speed"
    current_feed_rate = current_velocity * 60;

    /* convert feed rates to velocity */
    setup_velocity = setup_feed_rate * velocity_scale;
    offset_velocity = offset_feed_rate * velocity_scale;
    if(probe_feed_rate < setup_feed_rate){
        probe_velocity = probe_feed_rate * velocity_scale;
    }else{
        probe_velocity = setup_velocity;
    }
    if(mode == 2){
        thc_velocity = thc_feed_rate * velocity_scale * pid_p_gain / 100;
    }else{
        thc_velocity = thc_feed_rate * velocity_scale;
    }
    if(thc_velocity < 1){
        thc_velocity = 1;
    }

    /* turn torch off if torch off timer completed */
    if(torch_off_timer > 0){
        torch_off_timer -= fperiod;
        if(torch_off_timer <= 0){
            torch_on = FALSE;
            torch_off_timer = 0;
        }
    }

    /* turn torch off from external input */
    if(torch_off){
        torch_on = FALSE;
    }

    /* set THC state */
//FIXME not sure if we really need thc for tube cutting
//    thc_enabled = (thc_enable && !thc_disable && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1 && (arc_lost_timer > arc_lost_delay - 0.000001) && tool != TUBE ? 1:0);
    thc_enabled = (thc_enable && !thc_disable && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1 && (arc_lost_timer > arc_lost_delay - 0.000001) ? 1:0);

    /* set THC status */
    thc_active = (state == CUT_MODE_01 || state == CUT_MODE_2) && ((mode < 2 && target_volts) || (mode == 2 && arc_ok_out)) && thc_enabled && !cornerlock_is_locked && !voidlock_is_locked ? 1:0;
    if(thc_active){
        thc_activated = TRUE;
        thc_activated_timer = 0.25;
    }else if(thc_activated && (state == CUT_MODE_01 || state == CUT_MODE_2)){
        thc_activated_timer -= fperiod;
        if(thc_activated_timer <= 0){
            thc_activated = FALSE;
        }
    }else if(probe_required){
        thc_activated = FALSE;
    }

    /* set ohmic probe state */
    ohmic_detected = ohmic_probe && ohmic_probe_enable;

    /* set adaptive feed reduction if no paused motion */
    if(state != PAUSED_MOTION){
        if(feed_reduction < 10 && (state == CUT_MODE_01 || state == CUT_MODE_2)){
            adaptive_feed = 1;
        }else if(feed_reduction < 100 && (state == CUT_MODE_01 || state == CUT_MODE_2)){
            adaptive_feed = feed_reduction * 0.01;
        }else{
            adaptive_feed = 1;
        }
    }

    /* check for a manual cut */
    if(tool == CUTTING && !auto_cut){
        manual_cut = TRUE;
    }

    /* check for an abort */
    /* or for a pause or wait while active */
    if(auto_cut){
        if(state == IDLE && sensor_active && !program_is_idle && !tube_cut){
            torch_on = FALSE;
            if(!program_is_paused && !program_pause){
                if(breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                                  "program is paused.\n");
                }else if(float_switch){
                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                                  "program is paused.\n");
                }else if(ohmic_detected){
                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                                  "program is paused.\n");
                }
            }
            program_pause = TRUE;
            if(stop_type != WAIT){
                stop_type = PAUSE;
            }
            probe_required = TRUE;
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(!probe_test && program_is_idle && cut_started && !program_run){
            if(consumable_changing){
                state = CONSUMABLE_CHANGE_OFF;
            }else if(cut_recovering){
                state = CUT_RECOVERY_OFF;
            }else{
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = STOP;
                program_stop = TRUE;
                cut_started = FALSE;
                probe_required = TRUE;
                axis_x_finish = 0;
                axis_y_finish = 0;
                if(pause_at_end_timer){
                    state = PAUSE_AT_END;
                }else{
                    state = MAX_HEIGHT;
                }
            }
        }else if(!probe_test && state > IDLE && state <= CUT_MODE_2 && stop_type == NONE && cut_started){
            if(program_is_paused){
                torch_on = FALSE;
                stop_type = PAUSE;
                probe_required = TRUE;
                pause_at_end_timer = pause_at_end;
                state = MAX_HEIGHT;
            }else if(tool == EMPTY){
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = WAIT;
                if(thc_enabled || !torch_enable){
                    axis_x_finish = axis_x_position;
                    axis_y_finish = axis_y_position;
                }else{
                    axis_x_finish = 0;
                    axis_y_finish = 0;
                }
                pause_at_end_timer = pause_at_end;
                state = PAUSE_AT_END;
            }else if(breakaway){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && float_switch && !tube_cut){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && ohmic_detected){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && !arc_ok_out && torch_enable && !torch_off && !(mesh_enable || ignore_arc_ok_0 || ignore_arc_ok_1)){ ;
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"valid arc lost\n"
                                              "program is paused.\n");
                state = MAX_HEIGHT;
            }
        }
    }else if(manual_cut){
        if(tool == EMPTY){
            manual_cut = FALSE;
            torch_on = FALSE;
            stop_type = NONE;
            program_stop = TRUE;
            cut_started = FALSE;
            probe_required = TRUE;
            axis_x_finish = 0;
            axis_y_finish = 0;
            state = MAX_HEIGHT;
        }
    }

    /* calculate arc voltage */
    if(lowpass_frequency){
        arc_voltage_raw += (arc_voltage_in - arc_voltage_raw) * (1 - exp(-(2 * M_PI * fabs(lowpass_frequency)) * fperiod));
    }else{
        arc_voltage_raw = arc_voltage_in;
    }
    arc_voltage_out = round(((fabs(arc_voltage_raw) - arc_voltage_offset) * fabs(arc_voltage_scale)) * 1000) / 1000;
    if(arc_voltage_out < zero_window && arc_voltage_out > zero_window * -1){
        arc_voltage_out = 0;
    }

    /* temporary for forum issue #210558 */
    if(thc_active && low_cut_volts && arc_voltage_out < low_cut_volts){
        torch_on = FALSE;
        program_pause = TRUE;
        stop_type = PAUSE;
        probe_required = TRUE;
        rtapi_print_msg(RTAPI_MSG_ERR,"arc voltage fell below safe level while THC active\n"
                                      "target voltage = %f\n"
                                      "low cut volts = %d\n"
                                      "arc voltage = %f\n"
                                      "program is paused.\n", target_volts, low_cut_volts, arc_voltage_out);
        probe_inhibit = TRUE;
        state = MAX_HEIGHT;
    }

    /* ohmic sensing */
    if(ohmic_enable){
        if(ohmic_sense_in){
            if(ohmic_sense_counts < ohmic_sense_on_delay){
                ohmic_sense_counts += 1;
            }else{
                ohmic_sense_out = TRUE;
                ohmic_sense_counts = 0;
            }
        }else if(!ohmic_sense_in && ohmic_sense_out){
            if(ohmic_sense_counts < ohmic_sense_off_delay){
                ohmic_sense_counts += 1;
            }else{
                ohmic_sense_out = FALSE;
                ohmic_sense_counts = 0;
            }
        }else{
            ohmic_sense_counts = 0;
        }
    }else{
        ohmic_sense_out = FALSE;
        ohmic_sense_counts = 0;
    }

    /* offset probing deployment timer*/
    if(ohmic_probe_enable && (offset_probe_x || offset_probe_y)){
        offset_probing = TRUE;
    }else{
        offset_probing = FALSE;
    }
    if(offset_probing && (ohmic_enable || state == PIERCE_HEIGHT)){
        if(offset_probe_timer < offset_probe_delay){
            offset_probe_timer += fperiod;
        }
    }else{
        offset_probe_timer = 0;
    }

    /* set arc ok from either arc ok input of from actual arc voltage
     * if using arc ok input, set arc_ok_low_in and/or arc_ok_high_in to 0 */
    if(torch_on){
        torch_time += fperiod;
        /* add the current arc voltage to the arc voltage buffer */
        arc_voltage_buffer[arc_voltage_buffer_index] = arc_voltage_out;
        if (arc_voltage_buffer_index == BUFFERSIZE) {
            arc_voltage_buffer_index = 0;
        }else{
            arc_voltage_buffer_index++;
        }
        /* set from arc ok input */
        if(mode > 0){
            if(arc_ok_in){
                arc_ok_out = TRUE;
                arc_lost_timer = arc_lost_delay;
            }else if(arc_lost_timer > 0){
                arc_lost_timer -= fperiod;
            }else{
                arc_ok_out = FALSE;
            }
        /* synthesised from arc voltage */
        }else{
            /* stable voltages required to set arc_ok */
            if(!arc_ok_out){
                if(arc_voltage_out >= arc_ok_low &&
                   arc_voltage_out <= arc_ok_high &&
                    !read_arc_voltage_buffer(READ_OK, ok_sampler_samples, arc_voltage_buffer_index - 1, arc_voltage_out, ok_sample_threshold)){
                arc_ok_out = TRUE;
                arc_lost_timer = arc_lost_delay;
                }
            /* stable voltages required to maintain arc_ok */
            }else if((arc_voltage_out < arc_ok_low || arc_voltage_out > arc_ok_high) &&
                    read_arc_voltage_buffer(READ_OK, ok_sampler_samples, arc_voltage_buffer_index - 1, target_volts, ok_sample_threshold) >= ok_sampler_samples){
                if(arc_lost_timer <= 0){
                    arc_ok_out = FALSE;
                }else{
                    arc_lost_timer -= fperiod;
                }
            }
        }
    /* unset arc ok */
    }else{
        arc_lost_timer = arc_lost_delay;
        arc_ok_out = FALSE;
    }

    /* reset program states */
    if(program_is_idle){
        program_stop = FALSE;
        program_resume = FALSE;
        statistics_reset = FALSE;
    }else if(program_is_paused){
        program_pause = FALSE;
        paused_time += fperiod;
        run_time += fperiod;
    }else if(program_is_running){
        program_run = FALSE;
        program_resume = FALSE;
        auto_cut = TRUE;
        run_time += fperiod;
        if(motion_type == 1){
            rapid_time += fperiod;
        }
        if(!statistics_reset){
            cut_length = 0;
            cut_time = 0;
            paused_time = 0;
            pierce_count = 0;
            probe_time = 0;
            rapid_time = 0;
            run_time = 0;
            torch_time = 0;
            statistics_reset = TRUE;
        }
    }

    /* if puddlejump height is 0 then set it to 100 */
    puddle_jump_percent = puddle_jump_height == 0 ? 100:puddle_jump_height;

    /* set jog inhibit if required */
    if(sensor_active && program_is_idle && !(override_jog || state == PROBE_DOWN || state == PROBE_UP)){
        jog_inhibit = TRUE;
    }else{
        jog_inhibit = FALSE;
    }

    /* probe and scribe deployment for setting offsets */
    if(offset_set_probe && !offset_set && homed && program_is_idle && state == IDLE){
        offset_set = TRUE;
        ohmic_enable = TRUE;
    }else if(offset_set_scribe && !offset_set && homed && program_is_idle && state == IDLE){
        offset_set = TRUE;
        scribe_arm = TRUE;
    }else if(offset_set && !offset_set_probe && !offset_set_scribe){
        offset_set = FALSE;
        ohmic_enable = FALSE;
        scribe_arm = FALSE;
    }

    if(!machine_is_on){
        /* if machine is off */
        x_offset_counts = 0;
        y_offset_counts = 0;
        z_offset_counts = 0;
        stop_type = NONE;
        cut_started = FALSE;
        probe_required = TRUE;
        program_stop = FALSE;
        program_resume = FALSE;
        program_pause = FALSE;
        torch_on = FALSE;
        torch_pulse_timer = 0;
        state = IDLE;
    }else{
        /* if machine is on */
        switch(state){
            case IDLE:
//                if(!consumable_changing){
//                    xy_offset_enable = FALSE;
//                }
//                if(!offsets_active && program_is_idle){
//                    z_offset_enable = FALSE;
//                }
                if(probe_inhibit && !float_switch && !breakaway && !ohmic_detected){
                    probe_inhibit = FALSE;
                }else if(!probe_inhibit){
                    /* if we get a paused motion request and we are paused */
                    if(paused_motion_speed && (stop_type == PAUSE || stop_type == WAIT)){
                        state = PAUSED_MOTION;
                    /* if we get a consumable change start request and we are paused */
                    }else if(consumable_change && (stop_type == PAUSE || stop_type == WAIT) && !consumable_changing){
                        state = MAX_HEIGHT;
                        /* if we get a consumable change stop request and we are changing consumables */
                    }else if(!consumable_change && (stop_type == PAUSE || stop_type == WAIT) && consumable_changing){
                        state = CONSUMABLE_CHANGE_OFF;
                    /* if we get a cut recovery start request and we are paused */
                    }else if(cut_recovery && stop_type == PAUSE && (!cut_recovering || laser_recovery_start)){
                        state = CUT_RECOVERY_ON;
                    /* if we get a tube start request and we are stopped or waiting for a restart */
                    }else if(tube_cut && tool == CUTTING && (stop_type == NONE || stop_type == WAIT) && homed){
                        feed_hold = TRUE;
                        cut_started = TRUE;
                        stop_type = NONE;
                        if(torch_enable){
                            state = TORCH_ON;
                        }else{
                            feed_hold = FALSE;
                            state = CUT_MODE_01;
                        }
                    /* if we get a torch start request and we are stopped or waiting for a restart */
                    }else if((tool == CUTTING || tool == SPOTTING || probe_test) && (stop_type == NONE || stop_type == WAIT) && homed){
                        feed_hold = TRUE;
                        stop_type = NONE;
                        //touchdown = FALSE;
                        if(!probe_test){
                            cut_started = TRUE;
                        }else{
                            probe_testing = TRUE;
                        }
                        if(!thc_activated && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_start - axis_x_position, 2) + pow(axis_y_start - axis_y_position, 2));
                        }else if((axis_x_finish || axis_y_finish) && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_finish - axis_x_position, 2) + pow(axis_y_finish - axis_y_position, 2));
                            axis_x_finish = 0;
                            axis_y_finish = 0;
                        }
                        thc_activated = FALSE;
                        if(skip_ihs_distance && cut_offset < skip_ihs_distance && !probe_required){
                            if(thc_enabled){
                                pierce_target = pierce_target + cut_height_last - cut_target;
                                puddle_jump_target = puddle_jump_target + cut_height_last - cut_target;
                                cut_target = cut_height_last;
                                cut_height_first = cut_target;
                            }
                            cut_offset = 0;
                            state = PIERCE_HEIGHT;
                        }else{
                            if(ohmic_detected && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "probe test aborted.\n");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(float_switch && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "probe test aborted.");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(breakaway && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "probe test aborted.\n");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if (!program_is_paused && !program_pause){
                                if(!first_cut_finished){
                                    if(probe_start_height){
                                        probe_start_target = z_offset_counts - ((axis_z_position - axis_z_min_limit - probe_start_height) / offset_scale);
                                    }else{
                                        probe_start_target = z_offset_counts;
                                    }
                                }
                                cut_offset = 0;
                                /* offset probing setup if required */
                                if(offset_probing){
                                    op_xy_angle = atan2(-offset_probe_y, -offset_probe_x);
                                    op_x_velocity = fabs(offset_velocity * cos(op_xy_angle));
                                    op_y_velocity = fabs(offset_velocity * sin(op_xy_angle));
                                    op_x_target = x_offset_counts + (offset_probe_x / offset_scale);
                                    op_y_target = y_offset_counts + (offset_probe_y / offset_scale);
                                    op_x_start = x_offset_counts;
                                    op_y_start = y_offset_counts;
                                    if(axis_x_position + (op_x_target * offset_scale) < axis_x_min_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis X minimum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_y_position + (op_y_target * offset_scale) < axis_y_min_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis Y minimum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_x_position + (op_x_target * offset_scale) > axis_x_max_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis X maximum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                    if(axis_y_position + (op_y_target * offset_scale) > axis_y_max_limit){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"probe offset would violate axis Y maximum limit.\n"
                                                                      "program is paused.\n");
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        break;
                                    }
                                }
                                /* clear any laser recovery offset */
                                if(laser_recovery_state > OFF && laser_recovery_state < RESET){
                                    laser_recovery_state = RESET;
                                }else if(laser_recovery_state == RESET){
                                    angle_x_y = atan2(laser_y_offset, laser_x_offset);
                                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                                    laser_recovery_state = RESETTING;
                                }else if(laser_recovery_state == RESETTING){
                                    if(x_offset_counts == x_offset && y_offset_counts == y_offset){
                                        laser_recovery_state = OFF;
                                    }else{
                                        if(x_offset_counts != x_offset){
                                            x_offset_counts = offset_move(x_offset_counts, x_velocity, x_offset);
                                        }
                                        if(y_offset_counts != y_offset){
                                            y_offset_counts = offset_move(y_offset_counts, y_velocity, y_offset);
                                        }
                                    }
                                /* laser recovery offset complete if required */
                                }else{
                                    state = PROBE_HEIGHT;
                                }
                            }
                        }
                    /* if we get a resume request and we are paused */
                    }else if(!program_is_paused && stop_type == PAUSE){
                        if(consumable_changing){
                            state = CONSUMABLE_CHANGE_OFF;
                        }else if(motion_type == 1){
                            feed_hold = FALSE;
                        }else{
                            feed_hold = TRUE;
                        }
                        stop_type = NONE;
                    /* if torch pulse requested */
                    }else if(torch_pulse_start && torch_enable && !breakaway && !float_switch && !ohmic_probe){
                        feed_hold = TRUE;
                        state = TORCHPULSE;
                    /* if ohmic probe shorted test requested */
                    }else if(ohmic_test && ohmic_probe_enable){
                        feed_hold = TRUE;
                        ohmic_enable = TRUE;
                        state = OHMIC_TEST;
                    /* if we get a air-scribe start request */
                    }else if(tool == SCRIBE && !probe_test && homed){
                        state = SCRIBING;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_pause = FALSE;
                    }else if(!cut_started){
                        feed_hold = FALSE;
                    }
                }
                break;
            case PROBE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                if(ohmic_probe_enable){
                    ohmic_enable = TRUE;
                }
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(probe_testing && breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected during probe test\n");
                    probe_test_error = TRUE;
                    state = PROBE_TEST;
                    break;
                }
                /* move probe to x/y offsets if required */
                if(offset_probing){
                    xy_offset_enable = TRUE;
                    if(x_offset_counts != op_x_target || y_offset_counts != op_y_target){
                        if(x_offset_counts != op_x_target){
                            x_offset_counts = offset_move(x_offset_counts, op_x_velocity, op_x_target);
                        }
                        if(y_offset_counts != op_y_target){
                            y_offset_counts = offset_move(y_offset_counts, op_y_velocity, op_y_target);
                        }
                    }
                }
                if((float_switch && !float_detected) || ohmic_detected){
                    z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                    z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(z_pierce > z_max){
                        if(probe_testing){
                          state = PROBE_TEST;
                          probe_test_error = TRUE;
                          if(float_switch){
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                          "condition found while moving to probe height during float switch probe testing");
                          }else{
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                          "condition found while moving to probe height during ohmic probe testing");
                          }
                        }else{
                          stop_type = PAUSE;
                          program_pause = TRUE;
                          state = MAX_HEIGHT;
                          if(float_switch){
                              rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                            "condition found while moving to probe height during float switch probing\n");
                          }else{
                              rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum limit\n"
                                                            "condition found while moving to probe height during ohmic probing\n");
                          }
                        }
                        break;
                    }else if(ohmic_probe_enable && (x_offset_counts != op_x_target || y_offset_counts != op_y_target)){
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,"probe contact detected before probe offset reached\n"
                                                      "try increasing PROBE HEIGHT parameter\n");
                        state = MAX_HEIGHT;
                        break;
                    }
                    probe_retry = TRUE;
                    state = PROBE_UP;
                /* move to probe height at setup velocity */
                }else if(z_offset_counts != probe_start_target){
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, probe_start_target);
                }else{
                    if(float_detected){
                        if(!float_switch){
                            float_detected = FALSE;
                        }
                    }else{
                        /* test if probing offset is reached */
                        if(offset_probing){
                            if(x_offset_counts == op_x_target && y_offset_counts == op_y_target &&
                               z_offset_current - probe_start_target * offset_scale < 0.001){
                                state = PROBE_DOWN;
                            }
                        }else{
                            state = PROBE_DOWN;
                        }
                    }
                }
                probe_time += fperiod;
                break;
            case PROBE_DOWN:
                z_offset_enable = TRUE;
                stop_type = NONE;
                feed_hold = TRUE;
                if(ohmic_probe_enable){
                    ohmic_enable = TRUE;
                }
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(probe_testing && breakaway){
                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected during probe test\n");
                    probe_test_error = TRUE;
                    state = PROBE_TEST;
                    break;
                }
                if(ohmic_probe_enable && ohmic_probe_enable && offset_probe_timer < offset_probe_delay){
                    break;
                }
                if(float_switch && !float_detected){
                    if(ohmic_attempts >= ohmic_max_attempts || !ohmic_probe_enable){
                        z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                        z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                        if(z_pierce > z_max && !probe_testing){
                            rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum safe height\n"
                                                          "condition found while float switch probing\n");
                            stop_type = PAUSE;
                            program_pause = TRUE;
                            state = MAX_HEIGHT;
                            break;
                        }
                        probe_type = FLOAT;
                        ohmic_attempts = 0;
                        float_detected = FALSE;
                        state = PROBE_UP;
                    }else{
                        ohmic_attempts += 1;
                        float_detected = TRUE;
                        state = PROBE_HEIGHT;
                    }
                }else if(ohmic_detected){
                    z_pierce = z_offset_counts + probe_offset + ((pierce_height + (1 * units_per_mm))/ offset_scale);
                    z_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(z_pierce > z_max && !probe_testing){
                        rtapi_print_msg(RTAPI_MSG_ERR,"pierce height would exceed Z axis maximum safe height\n"
                                                      "condition found while ohmic probing\n");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        state = MAX_HEIGHT;
                        break;
                    }
                    probe_type = OHMIC;
                    ohmic_attempts = 0;
                    state = PROBE_UP;
                }else if(!float_switch && !ohmic_detected){
                    if(axis_z_position - (probe_velocity * offset_scale) <= axis_z_min_limit + (0.25 * units_per_mm )){
                        if(probe_at_bottom - z_offset_current < 0.0001){
                            probe_at_bottom = 0;
                            if(!probe_test){
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probing down.\n"
                                                              "program is paused.\n");
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                state = MAX_HEIGHT;
                            }else{
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probe testing.\n");
                                state = PROBE_TEST;
                                probe_test_error = TRUE;
                            }
                        }else{
                            probe_at_bottom = z_offset_current;
                        }
                    }else{
                        z_offset_counts -= probe_velocity;
                    }
                }
                probe_time += fperiod;
                break;
            case PROBE_UP:
                z_offset_enable = TRUE;
                stop_type = NONE;
                offset_probe_timer = 0;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                /* probe up at minimum speed to find top of stock */
                if(float_switch || ohmic_detected){
                    if(probe_retry){
                        z_offset_counts += 10 * res;
                    }else{
                        if(probe_final_speed > 10){
                            z_offset_counts += 10 * res;
                        }else if(probe_final_speed < 1){
                            z_offset_counts += 1 * res;
                        }else{
                            z_offset_counts += probe_final_speed * res;
                        }
                    }
                }else{
                    if(probe_retry){
                        probe_retry = FALSE;
                        state = PROBE_DOWN;
                        break;
                    }
                    ohmic_enable = FALSE;
                    if(probe_type == OHMIC){
                        probe_offset = ohmic_probe_offset / offset_scale;
                    }else{
                        probe_offset = float_switch_travel / offset_scale;
                    }
                    zero_target = z_offset_counts + probe_offset;
                    cut_target = offset_datum = zero_target + (cut_height / offset_scale);
                    pierce_target = zero_target + (pierce_height / offset_scale);
                    pierce_end_target = zero_target + (pierce_end_height / offset_scale);
                    puddle_jump_target = zero_target + ((pierce_height * puddle_jump_percent * 0.01) / offset_scale );
                    safe_min = pierce_target + ((1 * units_per_mm) / offset_scale);
                    safe_preferred = zero_target + (safe_height / offset_scale);
                    offset_min = z_offset_counts - ((axis_z_position - axis_z_min_limit) / offset_scale);
                    offset_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(!safe_available){
                        safe_available = safe_preferred - zero_target;
                    }
                    if(units_per_mm == 1){
                        safe_alarm = offset_max - (13 / offset_scale);
                    }else{
                        safe_alarm = offset_max - (0.5 / offset_scale);
                    }
                    if(!cut_height_first){
                        cut_height_first = cut_target;
                    }
                    if(safe_height == 0){
                        safe_target = offset_max;
                            axis_x_start = axis_x_position;
                            axis_y_start = axis_y_position;
                            state = ZERO_HEIGHT;
                    }else if(safe_min > offset_max && !probe_testing){
                        safe_target = offset_max;
                        rtapi_print_msg(RTAPI_MSG_ERR, "material is too high for safe traverse.\n"
                                                       "program is paused.\n");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        state = MAX_HEIGHT;
                    }else if(safe_preferred >= offset_max && !probe_testing){
                        safe_target = offset_max;
                        // warn if safe_height is less than available safe height{
                        if(offset_max - zero_target < safe_available){
                            if(units_per_mm == 1){
                                rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to %0.1fmm.\n",
                                                                (offset_max - zero_target) * offset_scale);
                            }else{
                                rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to %0.2fin.\n",
                                                                (offset_max - zero_target) * offset_scale);
                            }
                            safe_available = offset_max - zero_target;
                        }
                        axis_x_start = axis_x_position;
                        axis_y_start = axis_y_position;
                        state = ZERO_HEIGHT;
                    }else{
                        safe_target = safe_preferred;
                        axis_x_start = axis_x_position;
                        axis_y_start = axis_y_position;
                        state = ZERO_HEIGHT;
                    }
                }
                probe_time += fperiod;
                break;
            case ZERO_HEIGHT:
                /* this case is not used at present it is just a waypoint */
                /* ### do not go to zero height during offset probing ### */
                state = PIERCE_HEIGHT;
                break;
            case PIERCE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                probe_required = FALSE;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                /* clear x/y probe offsets if required */
                if(offset_probing){
                    xy_offset_enable = TRUE;
                    if(x_offset_counts != op_x_start){
                        x_offset_counts = offset_move(x_offset_counts, op_x_velocity, op_x_start);
                    }
                    if(y_offset_counts != op_y_start){
                        y_offset_counts = offset_move(y_offset_counts, op_y_velocity, op_y_start);
                    }
                    if(ohmic_probe_enable && offset_probe_timer < offset_probe_delay){
                        break;
                    }
                }
                if(pierce_height && cut_height && (use_auto_volts || (!use_auto_volts && cut_volts))){
                    feed_hold = TRUE;
                    if(z_offset_counts == pierce_target){
                        if((int)(z_offset_current * offset_res) == (int)(pierce_target * offset_scale * offset_res) &&
                           (((offset_probing && x_offset_counts == op_x_start && y_offset_counts == op_y_start)) || !offset_probing)){
                            arc_starts = 0;
                            if(probe_testing){
                                state = PROBE_TEST;
                            }else if(!torch_enable){
                                pierce_timer = pierce_delay + cut_height_delay;
                                state = PIERCE_DELAY;
                                pierce_motion_delay_timer = (pierce_motion_delay/100) * pierce_delay;
                                cut_height_delay_timer = cut_height_delay;
                                gouge_speed_dist_travelled = 0;
                                creep_speed_dist_travelled = 0;
                                pierce_old_x = axis_x_position;
                                pierce_old_y = axis_y_position;
                            }else if((tool == CUTTING || tool == SPOTTING) &&
                                     (!offset_probing || (offset_probing &&
                                     (int)(x_offset_current * offset_res) == (int)(op_x_start * offset_scale * offset_res) &&
                                     (int)(y_offset_current * offset_res) == (int)(op_y_start * offset_scale * offset_res)))){
                                state = TORCH_ON;
                            }
                        }
                    /* move to pierce height at setup velocity*/
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, pierce_target);
                    }
                }else if(!probe_testing){
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                    rtapi_print_msg(RTAPI_MSG_ERR,"invalid pierce height.\n"
                                                  "or invalid cut height.\n"
                                                  "or invalid cut volts.\n"
                                                  "program is paused.\n");
                }
                break;
            case TORCH_ON:
                stop_type = NONE;
                /* turn torch on and start arc fail timer
                 * if too many attempts then turn torch off, pause program and return to idle state */
                feed_hold = TRUE;
                if(arc_starts > arc_max_starts - 1){
                    restart_timer = 0;
                    if(program_is_idle){
                        cutting_stop = 1;
                        state = MAX_HEIGHT;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nmanual cut is stopped.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }else{
                        program_pause = TRUE;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nprogram is paused.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }
                }else{
                    error_message = 0;
                    restart_timer -= fperiod;
                    if(restart_timer <= 0){
                        restart_timer = 0;
                        arc_fail_timer = arc_fail_delay;
                        if(torch_enable){
                            torch_on = TRUE;
                            pierce_count += 1;
                        }
                        spotting = FALSE;
                        /* clear arc voltage buffer */
                        memset(arc_voltage_buffer, 0, BUFFERSIZE * sizeof(*arc_voltage_buffer));
                        state = ARC_OK;
                    }
                }
                break;
            case ARC_OK:
                stop_type = NONE;
                /* wait for arc ok
                 * if timeout occurs turn torch off then return to TORCH_ON for another attempt */
                feed_hold = TRUE;
                if(tool == SPOTTING){
                    if(!spotting){
                        if(arc_voltage_out >= spotting_threshold){
                            spotting = TRUE;
                            spotting_timer = spotting_time * 0.001;
                        }
                    }else{
                        spotting_timer -= fperiod;
                        if(spotting_timer <= 0){
                            spotting = FALSE;
                            spotting_timer = 0;
                            torch_on = FALSE;
                            stop_type = WAIT;
                            state = SAFE_HEIGHT;
                        }
                    }
                }
                arc_fail_timer -= fperiod;
                if(arc_fail_timer <= 0){
                    torch_on = FALSE;
                    restart_timer = restart_delay;
                    arc_starts += 1;
                    state = TORCH_ON;
                }else if((arc_ok_out || ignore_arc_ok_0 || ignore_arc_ok_1) && tool != SPOTTING){
                        pierce_timer = pierce_delay + cut_height_delay;
                        state = PIERCE_DELAY;
                        pierce_motion_delay_timer = (pierce_motion_delay/100) * pierce_delay;
                        cut_height_delay_timer = cut_height_delay;
                        gouge_speed_dist_travelled = 0;
                        creep_speed_dist_travelled = 0;
                        pierce_old_x = axis_x_position;
                        pierce_old_y = axis_y_position;
                }
                break;
            case PIERCE_DELAY:
                rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY\n");
                stop_type = NONE;
                /* wait for arc to pierce stock */
                feed_hold = TRUE;       // base assumption is no motion
                if(pierce_type != 0){   // Test pierce type. 0=Normal, 1=Wiggle, 2=Ramp
                    rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - pierce_type >0\n");
                    feed_hold = FALSE;  // We have motion for non normal pierce (wiggle and ramp)
                    if(pierce_type == 2){
                        /* for ramp we map have no motion for a period at the start before commencing a moving pierce and loweing height
                           Sequence being tested for is
                           1. pierce motion delay. Move in x/y but not in Z
                           2. Z movement ramp down to pierce end height
                           3. delay time  before commencing movement to cut height.
                              This should just be letting the remainder of TOTAL Pierce Delay run out
                              i.e. Pierce Delay + Cut Delay

                           In parallel there is a speed profile in the sequence
                           A. Gouge speed for gouge time period
                           B. Crawl speed for crawl time periof
                           C. Cut speed - should returning to normal feed rate.
                        */
                        rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - pierce_type == 2\n");
                        /* Set up some key variables */
                        gouge_speed_scale = gouge_speed / cut_feed_rate;
                        creep_speed_scale = creep_speed / cut_feed_rate;

                        /* ---------------------------------
                                X/Y Speed Profile logic
                        ------------------------------------*/
                        if (gouge_speed_dist_travelled < gouge_speed_distance){
                            /* Seq A - gouge distance*/
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - Seq A\n");
                            if(gcode_scale == 1){
                                requested_feed_rate = cut_feed_rate * gouge_speed_scale;
                            }else{
                                requested_feed_rate = (cut_feed_rate * gouge_speed_scale) / gcode_scale;
                            }
                            adaptive_feed = gouge_speed_scale;
                            // accumulate gouge distance traveled in XY plane
                            gouge_speed_dist_travelled += fabs(sqrt(pow(pierce_old_x - axis_x_position, 2) + pow(pierce_old_y - axis_y_position, 2)));
                            // record current X/Y for next accumulation calc
                            pierce_old_x = axis_x_position;
                            pierce_old_y = axis_y_position;
                        }else if(creep_speed_dist_travelled < creep_speed_distance){
                            /* Seq B - creep distance */
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - Seq B\n");
                            if(gcode_scale == 1){
                                requested_feed_rate = cut_feed_rate * creep_speed_scale;
                            }else{
                                requested_feed_rate = (cut_feed_rate * creep_speed_scale) / gcode_scale;
                            }
                            adaptive_feed = creep_speed_scale;
                            // accumulate gouge distance traveled in XY plane
                            creep_speed_dist_travelled += fabs(sqrt(pow(pierce_old_x - axis_x_position, 2) + pow(pierce_old_y - axis_y_position, 2)));
                            // record current X/Y for next accumulation calc
                            pierce_old_x = axis_x_position;
                            pierce_old_y = axis_y_position;
                        }else{
                            /* Seq C - set to cut speed */
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - set requested feed = cut feed\n");
                            requested_feed_rate = cut_feed_rate;
                            adaptive_feed = 1;
                        }

                        /* ---------------------------------
                                Z Motion Profile logic
                        ------------------------------------*/
                        if (pierce_motion_delay_timer > 0){
                            // Sequence 1
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - Seq 1\n");
                            pierce_motion_delay_timer -= fperiod;
                        }else if(z_offset_counts != pierce_end_target){
                            // Sequence 2
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - Seq 2\n");
                            z_offset_enable = TRUE;
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - move z_offset_counts\n");
                            z_offset_counts = offset_move(z_offset_counts,
                                            (((pierce_height - pierce_end_height)/(pierce_delay - ((pierce_motion_delay/100)*pierce_delay)))*60)*velocity_scale,
                                            pierce_end_target);
                        }else{
                            // Sequence 3
                            rtapi_print_msg(RTAPI_MSG_DBG,"PIERCE_DELAY - Seq 3\n");
                            cut_height_delay_timer -= fperiod;
                        }
                    }
                }
                // normal pierce timer processing
                if(pierce_timer > 0){
                    pierce_timer -= fperiod;
                }else if(tube_cut){
//FIXME not sure if we really need thc for tube cutting
                    zero_target = 0;
                    cut_target = 0;
                    pierce_target = 0;
                    puddle_jump_target = 0;
                    safe_min = 0;
                    safe_preferred = 0;
                    offset_min = z_offset_counts - ((axis_z_position - axis_z_min_limit) / offset_scale);
                    offset_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    feed_hold = FALSE;
                    state = CUT_MODE_01;
                }else if((puddle_jump_delay || puddle_jump_percent != 100) && !cut_recovering){
                    puddle_jump_timer = puddle_jump_delay;
                    state = PUDDLE_JUMP;
                }else{
                    state = CUT_HEIGHT;
                }
                break;
            case PUDDLE_JUMP:
                z_offset_enable = TRUE;
                feed_hold = FALSE;
                if(z_offset_counts == puddle_jump_target){
                    if((int)(z_offset_current * offset_res) == (int)(puddle_jump_target * offset_scale * offset_res)){
                        count = 0;
                        if(puddle_jump_timer > 0){
                            puddle_jump_timer -= fperiod;
                        }else{
                            puddle_jump_timer = 0;
                            state = CUT_HEIGHT;
                        }
                    }
                /* move to puddle_jump height at setup velocity*/
                }else{
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, puddle_jump_target);
                }
                break;
            case CUT_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
//                /* hold x/y motion until cut height reached */
//                if(!cut_recovering){
//                    feed_hold = FALSE;
//                }
                if(z_offset_counts == cut_target){
                    if((int)(z_offset_current * offset_res) == (int)(cut_target * offset_scale * offset_res)){
                        count = 0;
                        if(cut_recovering){
                            angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                            x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                            y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                            state = CUT_RECOVERY_OFF;
                        }else{
                            feed_hold = FALSE;
                            thc_delay_timer = thc_delay;
                            if(mode < 2){
                                voidlock_on_count = 0;
                                state = CUT_MODE_01;
                            }else{
                                state = CUT_MODE_2;
                            }
                        }
                    }
                /* move to cut height at setup velocity*/
                }else{
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, cut_target);
                }
                break;
            case CUT_MODE_01:
                /* thc control for modes 0 & 1 by arc voltage */
                /* if program is idle and spindle.0 is off then we shouldn't be here */
                if(program_is_idle && !cutting_start){
                    state = IDLE;
                }
                z_offset_enable = TRUE;
                /* use feed_upm if it has a value */
                if(feed_upm){
                    if(gcode_scale == 1){
                        requested_feed_rate = feed_upm / adaptive_feed;
                    }else{
                        requested_feed_rate = feed_upm / adaptive_feed / gcode_scale;
                    }
                /* otherwise fall back to cut feed rate parameter */
                }else{
                    if(gcode_scale == 1){
                        requested_feed_rate = cut_feed_rate * feed_override;
                    }else{
                        requested_feed_rate = cut_feed_rate * feed_override / gcode_scale;
                    }
                }
                /* while cutting and it is not a dry run or laser mode is enabled and mesh mode is not enabled:
                 * if thc is enabled then vary the torch height to keep the arc voltage constant
                 * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity
                 * if voidlock is enabled, only allow THC if the voltage change is less than the threshold voltage
                 * adjust torch height and target voltage to suit if height override requested */
                if((torch_on || laser_mode) && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1){
                    if(target_volts == 0){
                        cornerlock_is_locked = TRUE;
                        /* wait until velocity reaches 99.9% of requested velocity or if laser mode is enabled */
                        if((current_velocity * 60 > requested_feed_rate * 0.999) || laser_mode){
                            if(thc_auto && use_auto_volts){
                                /* test the arc voltage buffer for a stable voltage */
                                double target = read_arc_voltage_buffer(READ_THC, thc_sampler_samples, arc_voltage_buffer_index - 1, arc_voltage_out, thc_sample_threshold);
                                if(target){
// should we use average voltage or current voltage???
//                                    target_volts = arc_voltage_out; // current voltage
                                    target_volts = target;            // average voltage
                                }
                            }else{
                                /* wait until thc delay is completed before setting target voltage */
                                if(thc_delay_timer <= 0){
                                    if(use_auto_volts){
                                        count += 1;
                                        target_total += arc_voltage_out;
                                        if(count == target_samples){
                                            target_volts = target_total / target_samples;
                                            last_arc_voltage = target_volts;
                                            count = 0;
                                            target_total = 0;
                                        }
                                    }else{
                                        target_volts = cut_volts;
                                    }
                                }else{
                                    thc_delay_timer -= fperiod;
                                }
                            }
                        }
                    /* height override setup*/
                    }else if(fabs(height_override - height_ovr_old) > 0.005){
                        height_ovr_counts -= (height_override - height_ovr_old) * height_per_volt / offset_scale;
                        height_ovr_old = height_override;
                    /* height override z motion */
                    }else if(height_ovr_counts != 0){
                        if((setup_velocity) < height_ovr_counts){
                            z_offset_counts -= setup_velocity;
                            height_ovr_counts -= setup_velocity;
                        }else{
                            z_offset_counts -= height_ovr_counts;
                            height_ovr_counts = 0;
                        }
                    /* torch height control */
                    }else if(thc_enabled){
                        /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                        if(cornerlock_enable){
                            if(current_velocity * 60 < requested_feed_rate * cornerlock_threshold * 0.01){
                                cornerlock_is_locked = TRUE;
                            }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * 0.99){
                                cornerlock_is_locked = FALSE;
                            }
                        }else{
                            cornerlock_is_locked = FALSE;
                        }
                        if(voidlock_enable){
                            voidlock_threshold = (voidlock_slope * voidlock_on_cycles * fperiod);
                            voidlock_change = fabs(arc_voltage_out - last_arc_voltage);
                            last_arc_voltage = arc_voltage_out;
                            if(voidlock_change > voidlock_threshold){
                                if(voidlock_on_count >= voidlock_on_cycles){
                                    voidlock_off_count = 0;
                                    voidlock_is_locked = TRUE;
                                }else{
                                    voidlock_on_count += 1;
                                }
                            }else if(voidlock_is_locked){
                                voidlock_off_count += 1;
                            }else{
                                voidlock_on_count = 0;
                            }
                            if(voidlock_is_locked && voidlock_off_count >= voidlock_off_cycles){
                                    voidlock_is_locked = FALSE;
                            }
                        }else{
                            voidlock_is_locked = FALSE;
                            voidlock_on_count = 0;
                            last_arc_voltage = arc_voltage_out;
                        }
                        /* do thc if ok to go */
                        if(!cornerlock_is_locked && !voidlock_is_locked){
                            pid_error_now = (target_volts + height_override - arc_voltage_out) * 0.1;
                            if(fabs(pid_error_now) < fabs(thc_threshold * 0.1)){
                                pid_error_now = 0;
                            }
                            pid_output = pid_error_now * pid_p_gain * res;
                            pid_output += pid_error_now * pid_i_gain * res * fperiod;
                            pid_output += (pid_error_now - pid_error_old) * pid_d_gain * res / fperiod;
                            pid_error_old = pid_error_now;
                            if(pid_output > thc_velocity){
                                pid_output = thc_velocity;
                            }else if(pid_output < -thc_velocity){
                                pid_output = -thc_velocity;
                            }
                            /* if we hit a soft limit during thc*/
                            if(z_offset_counts + pid_output <= offset_min || z_offset_counts + pid_output >= offset_max){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                if(z_offset_counts + pid_output <= offset_min){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                                  "program is paused.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                                  "program is paused.\n");
                                }
                                pid_output = 0;
                                state = MAX_HEIGHT;

                            }
                            z_offset_counts += pid_output;
                        }
                    }
                    if(pid_output > 0){
                        led_up = TRUE;
                    }else if((pid_output) < 0){
                        led_down = TRUE;
                    }else{
                        led_down = FALSE;
                        led_up = FALSE;
                    }
                    pid_output = 0;
                    /* check if safe height is below maximum offset */
                    if(z_offset_counts > offset_datum){
                        safe_target += z_offset_counts - offset_datum;
                        offset_datum = z_offset_counts;
                        if(safe_target > offset_max){
                            safe_target = offset_max;
                            // warn if safe height less than 10mm (0.4")
                            if(!safe_height_is_limited && z_offset_counts > safe_alarm){
                                safe_height_is_limited = TRUE;
                                if(units_per_mm == 1){
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 13mm.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 0.5in.\n");
                                }
                                safe_available = offset_max - z_offset_counts;
                            }
                        }
                    }
                }
                cut_height_last = z_offset_counts;
                cut_length = cut_length + current_velocity * fperiod;
                cut_time = cut_time + fperiod;
                break;
            case CUT_MODE_2:
                /* thc control for mode 2 by move-up and move-down inputs (no void lock in this mode) */
                /* if program is idle and spindle.0 is off then we shouldn't be here */
                if(program_is_idle && !cutting_start){
                    state = IDLE;
                }
                z_offset_enable = TRUE;
                /* use feed_upm if it has a value */
                if(feed_upm){
                    if(gcode_scale == 1){
                        requested_feed_rate = feed_upm / adaptive_feed;
                    }else{
                        requested_feed_rate = feed_upm / adaptive_feed / gcode_scale;
                    }
                /* otherwise fall back to cut feed rate parameter */
                }else{
                    if(gcode_scale == 1){
                        requested_feed_rate = cut_feed_rate * feed_override;
                    }else{
                        requested_feed_rate = cut_feed_rate * feed_override / gcode_scale;
                    }
                }
                /* while cutting and it is not a dry run and mesh mode is not enabled:
                 * if thc is enabled then vary the torch height to keep the arc voltage constant
                 * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity */
                if(torch_on && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1){
                    if(thc_enabled){
                        /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                        if(cornerlock_enable){
                            if(current_velocity * 60 < requested_feed_rate * cornerlock_threshold * 0.01){
                                cornerlock_is_locked = TRUE;
                            }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * 0.99){
                                cornerlock_is_locked = FALSE;
                            }
                        }else{
                            cornerlock_is_locked = FALSE;
                        }
                        if(move_down && !cornerlock_is_locked){
                            if(z_offset_counts - thc_velocity <= offset_min){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                              "program is paused.\n");
                                state = MAX_HEIGHT;
                            }else{ /* move down at requested velocity */
                                z_offset_counts -= thc_velocity;
                                led_down = TRUE;
                            }
                        }else if(move_up && !cornerlock_is_locked){
                            if(z_offset_counts + thc_velocity + safe_min >= offset_max){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                              "program is paused.\n");
                                state = MAX_HEIGHT;
                            }else{ /* move up at requested velocity */
                                z_offset_counts += thc_velocity;
                                led_up = TRUE;
                            }
                        }else{
                            led_down = FALSE;
                            led_up = FALSE;
                        }
                    }
                    /* check if safe height is below maximum offset */
                    if(z_offset_counts > offset_datum){
                        safe_target += z_offset_counts - offset_datum;
                        offset_datum = z_offset_counts;
                        if(safe_target > offset_max){
                            safe_target = offset_max;
                            // warn if safe height less than 10mm (0.4")
                            if(!safe_height_is_limited && z_offset_counts > safe_alarm){
                                safe_height_is_limited = TRUE;
                                if(units_per_mm == 1){
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 13mm.\n");
                                }else{
                                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced to less than 0.5in.\n");
                                }
                                safe_available = offset_max - z_offset_counts;
                            }
                        }
                    }
                }
                cut_height_last = z_offset_counts;
                cut_length = cut_length + current_velocity * fperiod;
                cut_time = cut_time + fperiod;
                break;
            case PAUSE_AT_END:
                feed_hold = TRUE;
                pause_at_end_timer -= fperiod;
                if(pause_at_end_timer <= 0){
                    pause_at_end_timer = 0;
                    torch_on = FALSE;
                    if(program_is_idle){
                        state = MAX_HEIGHT;
                    }else{
                        state = SAFE_HEIGHT;
                    }
                }
                break;
            case SAFE_HEIGHT:
                z_offset_enable = TRUE;
                feed_hold = TRUE;
                torch_on = FALSE;
                if(!torch_off_timer || !torch_on){
                    cornerlock_is_locked = FALSE;
                    if(!probe_test || probe_test_error){
                        if(z_offset_counts == safe_target){
                            if((int)(z_offset_current * offset_res) == (int)(safe_target * offset_scale * offset_res)){
                                if(stop_type == WAIT){
                                    feed_hold = FALSE;
                                }
                                first_cut_finished = TRUE;
                                /* do height override here for for remainder of job */
                                height_ovr_old = 0;
                                state = END_CUT;
                            }
                        /* move to safe height at setup velocity*/
                        }else{
                            z_offset_counts = offset_move(z_offset_counts, setup_velocity, safe_target);
                        }
                    }
                }
                break;
            case MAX_HEIGHT:
                z_offset_enable = TRUE;
                feed_hold = TRUE;
                torch_on = FALSE;
                cornerlock_is_locked = FALSE;
                if(!probe_test || probe_test_error){
                    if(z_offset_counts == 0){
                        if((int)(z_offset_current * offset_res) == 0){
                            if(stop_type == WAIT){
                                feed_hold = FALSE;
                            }
                            /* do height override here for remainder of job */
                            height_ovr_old = 0;
                            if(consumable_change){
                                state = CONSUMABLE_CHANGE_ON;
                            }else if(cut_recovery && stop_type != STOP){
                                state = CUT_RECOVERY_ON;
                            /* clear x/y probe offsets if required */
                            }else if((offset_probe_x || offset_probe_y) && (x_offset_counts || y_offset_counts)){
                                if(x_offset_counts != 0){
                                    x_offset_counts = offset_move(x_offset_counts, op_x_velocity, 0);
                                }
                                if(y_offset_counts != 0){
                                    y_offset_counts = offset_move(y_offset_counts, op_y_velocity, 0);
                                }
                            }else{
                                    state = END_CUT;
                            }
                        }
                    /* move to maximum height at setup velocity */
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    }
                }
                break;
            case END_CUT:
                /* clean up and return to idle state */
                target_volts = 0;
                cornerlock_is_locked = FALSE;
                voidlock_is_locked = FALSE;
                led_down = FALSE;
                led_up = FALSE;
                ohmic_enable = FALSE;
                probe_test_error = FALSE;
                cutting_stop = 0;
                if(program_is_idle){
                    state = END_JOB;
                }else{
                    state = IDLE;
                }
                break;
            case END_JOB:
                auto_cut = FALSE;
                manual_cut = FALSE;
                program_run = FALSE;
                paused_motion = FALSE;
                adaptive_feed = 1;
                cut_height_first = 0;
                cut_height_last = 0;
                if(program_is_idle){
                    z_offset_enable = TRUE;
                    if (z_offset_counts == 0){
                        if(!offsets_active){
                            first_cut_finished = FALSE;
                            stop_type = NONE;
                            safe_height_is_limited = FALSE;
                            safe_available = 0;
                            cut_started = FALSE;
                            /* do height override here for one cut only */
                            /* height_ovr_old = 0; */
                            if(consumable_changing){
                                state = CONSUMABLE_CHANGE_OFF;
                            }else if(cut_recovering){
                                angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                                x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                                y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                                state = CUT_RECOVERY_OFF;
                                cut_recovering = FALSE;
                                laser_recovery_state = OFF;
                            }else{
                                state = IDLE;
                            }
                        }
                    /* clear z offset at setup velocity */
                    }else{
                        z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    }
                }
                break;
            case TORCHPULSE:
                /* single pulse the torch on and off */
                if(!torch_on){
                    torch_pulse_timer = torch_pulse_time;
                    if(torch_enable){
                        torch_on = TRUE;
                    }
                }else{
                    if(torch_pulse_time == 0){
                        torch_pulse_timer = 0;
                    }
                    if(torch_pulse_timer > 0){
                        torch_pulse_timer -= fperiod;
                    }else{
                        torch_on = FALSE;
                        if(!torch_pulse_start){
                            if(cut_recovering){
                                state = CUT_RECOVERY_ON;
                            }else{
                                state = IDLE;
                            }
                        }
                    }
                }
                break;
            case PAUSED_MOTION:
                if(paused_motion_speed){
                    paused_motion = TRUE;
                    adaptive_feed = paused_motion_speed;
                    program_resume = TRUE;
                    feed_hold = FALSE;
                }else if(program_is_running){
                    program_pause = TRUE;
                    feed_hold = TRUE;
                    adaptive_feed = 1;
                }else if(program_is_paused && feed_hold){
                    paused_motion = FALSE;
                    state = CUT_RECOVERY_ON;
                }
                break;
            case OHMIC_TEST:
                /* wait here until ohmic_test input released */
                if (!ohmic_test){
                    ohmic_enable = FALSE;
                    if(cut_recovering){
                        state = CUT_RECOVERY_ON;
                    }else{
                        state = IDLE;
                        }
                }
                break;
            case PROBE_TEST:
                z_offset_enable = TRUE;
                /* wait here until probe_test input released */
                if(!probe_test){
                    /* clear z offset at setup velocity */
                    z_offset_counts = offset_move(z_offset_counts, setup_velocity, 0);
                    if((offset_probe_x || offset_probe_y) && (x_offset_counts || y_offset_counts)){
                        x_offset_counts = offset_move(x_offset_counts, op_x_velocity, 0);
                        y_offset_counts = offset_move(y_offset_counts, op_y_velocity, 0);
                    }
                    if(!x_offset_counts && !y_offset_counts && !z_offset_counts){
                        probe_inhibit = FALSE;
                        probe_testing = FALSE;
                        probe_required = TRUE;
                        state = END_CUT;
                    }
                }
                break;
            case SCRIBING:
                if(tool == SCRIBE){
                    if(!program_is_paused){
                        scribe_arm = TRUE;

                        if(scribe_arm_timer){
                            feed_hold = TRUE;
                            scribe_arm_timer -= fperiod;
                            if(scribe_arm_timer < 0){
                                scribe_arm_timer = 0;
                            }
                        }else if(scribe_on_timer){
                            feed_hold = TRUE;
                            scribe_on_timer -= fperiod;
                            if(scribe_on_timer < 0){
                                scribe_on_timer = 0;
                            }
                        }else if(scribe_arm && !scribe_arm_timer && !scribe_on){
                            feed_hold = TRUE;
                            scribe_on_timer = scribe_on_delay;
                            scribe_on = TRUE;
                        }else if(scribe_on && !scribe_on_timer){
                            feed_hold = FALSE;
                        }
                    }else{
                        scribe_arm = FALSE;
                        scribe_on = FALSE;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_on_timer = 0;
                    }
                }else{
                    scribe_arm = FALSE;
                    scribe_on = FALSE;
                    scribe_arm_timer = 0;
                    scribe_on_timer = 0;
                    state = IDLE;
                }
                break;
            case CONSUMABLE_CHANGE_ON:
                xy_offset_enable = TRUE;
                feed_hold = TRUE;
                if(sensor_active){
                    if(!error_message){
                        error_message = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "breakaway, float, or ohmic activated during consumable change, motion paused.\n"
                                        "WARNING: MOTION WILL RESUME IMMEDIATELY UPON RESOLVING THIS CONDITION!\n");
                    }
                    break;
                }
                error_message = FALSE;
                if(!consumable_changing){
                    if(x_offset == 0 && y_offset == 0){
                        x_velocity = 0;
                        y_velocity = 0;
                    }else if(x_offset == 0){
                        x_velocity = 0;
                        y_velocity = xy_feed_rate * velocity_scale;
                    }else if(y_offset == 0){
                        x_velocity = xy_feed_rate * velocity_scale;
                    }else{
                        angle_x_y = atan2(y_offset, x_offset);
                        x_velocity = fabs(xy_feed_rate * velocity_scale * cos(angle_x_y));
                        y_velocity = fabs(xy_feed_rate * velocity_scale * sin(angle_x_y));
                    }
                    consumable_changing = TRUE;
                }else{
                    if(((int)(x_offset_current * offset_res) == (int)(x_offset * offset_scale * offset_res) &&
                      (int)(y_offset_current * offset_res) == (int)(y_offset * offset_scale * offset_res)) ||
                      !consumable_change){
                        state = IDLE;
                    }else if(consumable_change){
                        if(x_velocity && x_offset_counts != x_offset){
                            if(x_offset > 0){
                                if(x_offset_counts + x_velocity < x_offset){
                                    x_offset_counts += x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }else{
                                if(x_offset_counts - x_velocity > x_offset){
                                    x_offset_counts -= x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }
                        }
                        if(y_velocity && y_offset_counts != y_offset){
                            if(y_offset > 0){
                                if(y_offset_counts + y_velocity < y_offset){
                                    y_offset_counts += y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }else{
                                if(y_offset_counts - y_velocity > y_offset){
                                    y_offset_counts -= y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }
                        }
                    }
                }
                break;
            case CONSUMABLE_CHANGE_OFF:
                xy_offset_enable = TRUE;
                if(sensor_active){
                    if(!error_message){
                        error_message = TRUE;
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "breakaway, float, or ohmic activated during consumable change, motion paused.\n"
                                        "WARNING: MOTION WILL RESUME IMMEDIATELY UPON RESOLVING THIS CONDITION!\n");
                    }
                    break;
                }
                error_message = FALSE;
                if(x_offset_counts == 0 && y_offset_counts == 0){
                    if((int)(x_offset_current * offset_res) == 0 && (int)(y_offset_current * offset_res) == 0){
                        consumable_changing = FALSE;
                        cons_change_clear = FALSE;
                        feed_hold = FALSE;
                        state = IDLE;
                    }
                }else{
                    if(x_velocity && x_offset_counts != 0){
                        if(x_offset_counts > 0){
                            if(x_offset_counts - x_velocity > 0){
                                x_offset_counts -= x_velocity;
                            }else{
                                x_offset_counts = 0;
                            }
                        }else{
                            if(x_offset_counts + x_velocity < 0){
                                x_offset_counts += x_velocity;
                            }else{
                                x_offset_counts = 0;
                            }
                        }
                    }
                    if(y_velocity && y_offset_counts != 0){
                        if(y_offset_counts > 0){
                            if(y_offset_counts - y_velocity > 0){
                                y_offset_counts -= y_velocity;
                            }else{
                                y_offset_counts = 0;
                            }
                        }else{
                            if(y_offset_counts + y_velocity < 0){
                                y_offset_counts += y_velocity;
                            }else{
                                y_offset_counts = 0;
                            }
                        }
                    }
                }
                break;
            case CUT_RECOVERY_ON:
                xy_offset_enable = TRUE;
                if(program_is_running){
                    state = IDLE;
                }
                if(!cut_recovering){
                    cut_recovering = TRUE;
                    if(puddle_jump_delay || puddle_jump_percent != 100){
                        rtapi_print_msg(RTAPI_MSG_ERR, "Puddle Jump is disabled during Cut Recovery.\n");
                    }
                }
                if(torch_pulse_start && torch_enable && !breakaway && !float_switch && !ohmic_probe){
                    feed_hold = TRUE;
                    state = TORCHPULSE;
                }
                if(ohmic_test && ohmic_probe_enable){
                    feed_hold = TRUE;
                    ohmic_enable = TRUE;
                    state = OHMIC_TEST;
                }
                /* offset for laser recovery if required */
                if(laser_recovery_start && laser_recovery_state == OFF){
                    laser_recovery_state = SET;
                }else if(laser_recovery_state == SET){
                    angle_x_y = atan2(laser_y_offset, laser_x_offset);
                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                    laser_x_target = x_offset_counts + laser_x_offset;
                    laser_y_target = y_offset_counts + laser_y_offset;
                    laser_recovery_state = SETTING;
                }else if(laser_recovery_state == SETTING){
                    if(x_offset_counts == laser_x_target && y_offset_counts == laser_y_target){
                        laser_recovery_state = ON;
                    }else{
                        if(x_offset_counts != laser_x_target){
                            x_offset_counts = offset_move(x_offset_counts, x_velocity, laser_x_target);
                        }
                        if(y_offset_counts != laser_y_target){
                            y_offset_counts = offset_move(y_offset_counts, y_velocity, laser_y_target);
                        }
                    }
                /* laser recovery offset is clear */
                }else if(cut_recovery){
                    /* move x axis to recovery position at recovery velocity */
                    if(x_offset_counts != x_offset + laser_x_offset * (laser_recovery_state > 1)){
                        x_offset_counts = offset_move(x_offset_counts, recovery_velocity, x_offset + laser_x_offset * (laser_recovery_state > 1));
                    }
                    /* move y axis to recovery position at recovery velocity */
                    if(y_offset_counts != y_offset + laser_y_offset * (laser_recovery_state > 1)){
                        y_offset_counts = offset_move(y_offset_counts, recovery_velocity, y_offset + laser_y_offset * (laser_recovery_state > 1));
                    }
                }else{
                    state = CUT_RECOVERY_OFF;
                }
                if(paused_motion_speed){
                    state = PAUSED_MOTION;
                }
                break;
            case CUT_RECOVERY_OFF:
                xy_offset_enable = TRUE;
                angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                if(program_is_running){
                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                }else{
                    x_velocity = fabs(recovery_velocity * cos(angle_x_y));
                    y_velocity = fabs(recovery_velocity * sin(angle_x_y));
                }
                if(x_offset_counts == 0 && y_offset_counts == 0){
                    if((int)(x_offset_current * offset_res) == 0 && (int)(y_offset_current * offset_res) == 0){
                        laser_recovery_state = OFF;
                        if(cut_recovering){
                            cut_recovering = FALSE;
                            feed_hold = FALSE;
                            thc_delay_timer = thc_delay;
                            if(cut_recovery){
                                if(mode < 2){
                                    voidlock_on_count = 0;
                                    state = CUT_MODE_01;
                                }else{
                                    state = CUT_MODE_2;
                                }
                            }else{
                                state = IDLE;
                            }
                        }else{
                            state = IDLE;
                        }
                    }
                }else{
                    /* clear x axis offset at recovery velocity */
                    if(x_offset_counts != 0){
                        x_offset_counts = offset_move(x_offset_counts, x_velocity, 0);
                    }
                    /* clear y axis offset at recovery velocity */
                    if(y_offset_counts != 0){
                        y_offset_counts = offset_move(y_offset_counts, y_velocity, 0);
                    }
                }
                break;
            case DEBUG:
                /* holding state for debugging */
                rtapi_print_msg(RTAPI_MSG_ERR, "We should never end up here...\n");
                break;
        }
    }

    /* set status pins */
    state_out = state;
    stop_type_out = stop_type;

    /* debug print */
    if(debug_print && state_old != state){
        state_old = state;
        switch(state){
            case 0:
                rtapi_print_msg(RTAPI_MSG_INFO, "IDLE\n");
                break;
            case 1:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_HEIGHT\n");
                break;
            case 2:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_DOWN\n");
                break;
            case 3:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_UP\n");
                break;
            case 4:
                rtapi_print_msg(RTAPI_MSG_INFO, "ZERO_HEIGHT\n");
                break;
            case 5:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_HEIGHT\n");
                break;
            case 6:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCH_ON\n");
                break;
            case 7:
                rtapi_print_msg(RTAPI_MSG_INFO, "ARC_OK\n");
                break;
            case 8:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_DELAY\n");
                break;
            case 9:
                rtapi_print_msg(RTAPI_MSG_INFO, "PUDDLE_JUMP\n");
                break;
            case 10:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_HEIGHT\n");
                break;
            case 11:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_MODE_01\n");
                break;
            case 12:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_MODE_2\n");
                break;
            case 13:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSE_AT_END\n");
                break;
            case 14:
                rtapi_print_msg(RTAPI_MSG_INFO, "SAFE_HEIGHT\n");
                break;
            case 15:
                rtapi_print_msg(RTAPI_MSG_INFO, "MAX_HEIGHT\n");
                break;
            case 16:
                rtapi_print_msg(RTAPI_MSG_INFO, "END_CUT\n");
                break;
            case 17:
                rtapi_print_msg(RTAPI_MSG_INFO, "END_JOB\n\n");
                break;
            case 18:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCHPULSE\n");
                break;
            case 19:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSED_MOTION\n");
                break;
            case 20:
                rtapi_print_msg(RTAPI_MSG_INFO, "OHMIC_TEST\n");
                break;
            case 21:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_TEST\n");
                break;
            case 22:
                rtapi_print_msg(RTAPI_MSG_INFO, "SCRIBING\n");
                break;
            case 23:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_ON\n");
                break;
            case 24:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_OFF\n");
                break;
            case 25:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_ON\n");
                break;
            case 26:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_OFF\n");
                break;
            case 27:
                rtapi_print_msg(RTAPI_MSG_INFO, "DEBUG\n");
                break;
        }
    }

}
