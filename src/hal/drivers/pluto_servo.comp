//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

component pluto_servo """Hardware driver and firmware for the Pluto-P parallel-port FPGA, for use with servo machines.

.B loadrt pluto_servo ioaddr=\\fIaddr\\fB ioaddr_hi=\\fIaddr\\fB epp_wide=\\fI[0|1]\\fB

.RS 4
.TP
\\fBioaddr\\fR [default: 0x378]
The base address of the parallel port.

.TP
\\fBioaddr_hi\\fR [default: 0]
The secondary address of the parallel port, used to set EPP
mode.  0 means to use ioaddr + 0x400.  -1 means there is no
secondary address.

.\\" .TP
.\\" \\fBepp_soft\\fR [default: 0]
.\\" Enables "soft EPP mode".  This emulates the EPP communication
.\\" protocol using a bidirectional parallel port.  This mode is slower, and
.\\" cannot detect communication errors.
.\\"
.TP
\\fBepp_wide\\fR [default: 1]
Set to zero to disable "wide EPP mode".  "Wide" mode allows 16- and 32-bit EPP
transfers, which can reduce the time spent in the read and write functions.
However, this mode may not work on all EPP parallel ports.
.RE""";

description """
Pluto_servo is an emc2 software driver and associated firmware that allow the Pluto-P board to be used to control a servo-based CNC machine.

The driver has 4 PWM channels, 4 quadrature channels with index pulse, 18
digital outputs (8 shared with PWM), and 20 digital inputs (12 shared with
quadrature).

.SS Encoders
The encoder pins and parameters conform to the `canonical encoder' interface
described in the HAL manual.  It operates in `x4 mode'.

The sample rate of the encoder is 40MHz.  The maximum number quadrature rate is
8191 counts per emc2 servo cycle.  For correct handling of the index pulse, the
number of encoder counts per revolution must be less than 8191.

.SS PWM
The PWM pins and parameters conform to the `canonical analog output' interface
described in the HAL manual.  The output pins are `up/down' or `pwm/dir'
pins as described in the documentation of the `pwmgen' component.

Internally the PWM generator is based on a 12-bit, 40MHz counter, giving 4095
duty cycles from -100% to +100% and a frequency of approximately 19.5kHz.  In
PDM mode, the duty periods are approximately 100ns long.

.SS Digital I/O
The digital output pins conform to the `canonical digital output' interface
described in the HAL manual.

The digital input pins conform to the `canonical digital input' interface
described in the HAL manual.
""";
pin out s32 encoder.#.count[4];
pin out float encoder.#.position[4];
pin out float encoder.#.velocity[4];
pin in bit encoder.#.reset[4];
pin io bit encoder.#.index-enable[4] """encoder-\\fIM\\fR corresponds to the
pins labeled QA\\fIM\\fR, QB\\fIM\\fR, and QZ\\fIM\\fR on the pinout diagram""";
param rw float encoder_#_scale[4] =1;

param rw bit encoder.z-polarity "Set to TRUE if the index pulse is active low, FALSE if it is active high.  Affects all encoders.";

pin in float pwm.#.value[4];
pin in bit pwm_#_enable[4] "pwm-\\fIM\\fR corresponds to the pins labeled UP\\fIM\\fR and DN\\fIM\\fR on the pinout diagram";
param rw float pwm.#.offset[4];
param rw float pwm.#.scale[4]=1;
param rw float pwm.#.max-dc[4]=1;
param rw float pwm.#.min-dc[4]=0;
param rw bit pwm.#.pwmdir[4]=0
"Set to TRUE use PWM+direction mode.  Set to FALSE to use Up/Down mode.";

param rw bit pwm.is-pdm "Set to TRUE to use PDM (also called interleaved PWM) mode.  Set to FALSE to use traditional PWM mode.  Affects all PWM outputs.";


pin in bit dout.##[20]
"""dout.\\fI0M\\fR corresponds to the pin labeled
OUT\\fIM\\fR on the pinout diagram.  Other pins are shared with the PWM
function, as follows:
.RS 12
.ta T 14 8 14 6
.PP
.PD 0
\\fBPin\tShared\tPin\tShared
\twith\t\twith\\fR
.PP
dout.10\tUP0\tdout.11\tDOWN1
.PP
dout.12\tUP2\tdout.13\tDOWN2
.PP
dout.14\tUP3\tdout.15\tDOWN3
.PP
dout.18\tUP4\tdout.19\tDOWN4
.RE
.PD
.DT""";
param rw bit dout.##-invert[20]
"If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.";

pin out bit din.##[20];
pin out bit din.##_not[20]
"""For M=0 through 7, din.\\fI0M\\fR corresponds to the pin labeled
IN\\fIM\\fR on the pinout diagram.  Other pins are shared with the encoder
function, as follows:
.RS 12
.ta T 14 8 14 6
.PP
.PD 0
\\fBPin\tShared\tPin\tShared
\twith\t\twith\\fR
.PP
din.8\tQZ0\tdin.9\tQZ1
.PP
din.10\tQZ2\tdin.11\tQZ3
.PP
din.12\tQB0\tdin.13\tQB1
.PP
din.14\tQB2\tdin.15\tQB3
.PP
din.16\tQA0\tdin.17\tQA1
.PP
din.18\tQA2\tdin.19\tQA3
.RE
.PD
.DT""";

param rw s32 debug_0;
param rw s32 debug_1;

param rw u32 communication_error """Incremented each time 
pluto-servo.read detects an error code in the EPP status register.  While
this register is nonzero, new values are not being written to the Pluto-P
board, and the status of digital outputs and the PWM duty cycle of the PWM
outputs will remain unchanged.  To continue after a communication error,
set this parameter back to zero.""";

option singleton;
option extra_setup;
option extra_cleanup;

option data internal;

function read "Read all the inputs from the pluto-servo board";
function write "Write all the outputs on the pluto-servo board";

see_also """The \\fIpluto_servo\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.""";
;;
MODULE_LICENSE("GPL");

#ifdef SIM
#include <sys/io.h>
#else
#include <asm/io.h>
#endif

int ioaddr = 0x378;
int ioaddr_hi = 0;
int epp_wide = 1;
int epp_soft = 0;

typedef struct {
    long last_index[4];
    long last_count[4];
    long reset_count[4];
} internal;

long extend(long oldval, int newbits) {
    int oldhighbits = oldval & 0x3000;
    int newhighbits = newbits & 0x3000;
    long newval = (oldval & ~0x3fff) | newbits;

    if(oldhighbits == 0x3000 && newhighbits == 0)
	newval += 0x4000;	
    else if(oldhighbits == 0 && newhighbits == 0x3000)
	newval -= 0x4000;	

    return newval;
}

void EPP_DIR_WRITE(void) {
    if(epp_soft) {
	// set write LOW to indicate write
	outb(4 | 1, ioaddr+2);
    }
}
void EPP_DIR_READ(void) {
    if(epp_soft) {
	// set write HIGH to indicate read
	// set port direction to input
	outb(32 | 4, ioaddr+2);
	
    }
}
void ADDR(int w) {
    if(epp_soft) {
	// Write address
	outb(w, ioaddr);
	// set address strobe low
	outb(4 | 8 | 1, ioaddr + 2);
	// (port would be polled here for WAIT/ if we didn't know the device
	// was faster than us)
	// set address strobe high
	outb(4 | 1, ioaddr + 2);
    } else {
	outb(w, ioaddr+3);
    }
}

void WRITE(int w) {
    if(epp_soft) {
	// Write data
	outb(w, ioaddr);
	// set data strobe low
	outb(4 | 2 | 1, ioaddr+2);
	// (port would be polled here for WAIT/ if we didn't know the device
	// was faster than us)
	// set data strobe high
	outb(4 | 1, ioaddr+2);
    } else
	outb(w, ioaddr+4);
}

int READ(void) {
    if(epp_soft) {
	int result;
	// set data strobe low
	outb(32 | 4 | 1, ioaddr+2);
	// (port would be polled here for WAIT/ if we didn't know the device
	// was faster than us)
	// read data
	result = inb(ioaddr);
	// set data strobe high
	outb(32 | 4, ioaddr+2);
	return result;
    } else
	return inb(ioaddr+4);
}


unsigned long read32(void) {
    unsigned char a, b, c, d;

    if(epp_wide && !epp_soft)
	return inl(ioaddr+4);

    a = READ();
    b = READ();
    c = READ();
    d = READ();

    return a + (b<<8) + (c<<16) + (d<<24);
}

void write32(long w) {
    if(epp_wide && !epp_soft) {
	outl(w, ioaddr+4);
	return;
    }

    WRITE(w);
    WRITE(w >> 8);
    WRITE(w >> 16);
    WRITE(w >> 24);
}

void write16(int w) {
    if(epp_wide && !epp_soft) {
	outw(w, ioaddr+4);
	return;
    }

    WRITE(w & 0xff);
    WRITE(w >> 8);
}

int PWM(int enable, float value, float offset, float scale, float min_dc, float max_dc, int dio0, int dio1, int is_pdm, int is_pwmdir) {
    int result;
    if(enable == 0) return 0;

    value = value / scale + offset;
    if(value < -max_dc) value = -max_dc;
    else if(value > -min_dc && value < 0) value = -min_dc;
    else if(value > 0 && value < min_dc) value = min_dc;
    else if(value > max_dc) value = max_dc;

    value = 2047 * value;
    if(value < -2047) value = -2047;
    if(value > 2047) value = 2047;

    if(value < 0) {
	if(is_pwmdir) {
	     result = (1<<13) | (int)(-value);
	} else {
	     result = (1<<15) | (int)(-value);
	}
    } else result = value;
    if(is_pdm) result |= 1<<14;
    if(dio0) result ^= 1<<12;
    if(dio1) result ^= 1<<13;

    return result;
}

FUNCTION(write) {
    int r = 0;
    int i;
    if(communication_error) return;

    ADDR(0);

    for(i=0; i<4; i++) {
        if(pwm_max_dc(i) > 1) pwm_max_dc(i) = 1;
        else if(pwm_max_dc(i) < 0) pwm_max_dc(i) = 0;
        if(pwm_min_dc(i) < 0) pwm_min_dc(i) = 0;
        else if(pwm_min_dc(i) > pwm_max_dc(i)) pwm_min_dc(i) = pwm_max_dc(i);
    }

#define D(x) (!dout(x) ^ !dout_invert(x))
#define P(x,y) PWM(pwm_enable(x), pwm_value(x), pwm_offset(x), pwm_scale(x), \
        pwm_min_dc(x), pwm_max_dc(x), D(y), D(y+1), pwm_pwmdir(i), pwm_is_pdm)
    write32( P(0,10) | (P(1, 12) << 16));
    write32( P(2,14) | (P(3, 16) << 16));

    for(i=0; i<10; i++) {
        if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);
    }
    if (encoder_z_polarity) r |= 0x8000;
    write16(r);
}

FUNCTION(read) {
    int i;
    u32 ppdata;

    ADDR(0);
    EPP_DIR_READ();

    for(i=0; i<4; i++) {
        long count, index;
        ppdata = read32();
        int reset = encoder_reset(i);
        if(i == 0) {
            int status = inb(ioaddr+1) & 1;
            if(status) communication_error ++;
            if(communication_error) { EPP_DIR_WRITE(); return; }
        }
        count = extend(data.last_count[i], ppdata & 0x3fff);;
        index = extend(data.last_index[i], (ppdata >> 14) & 0x3fff);

        if(encoder_index_enable(i) && index != data.last_index[i]) {
            encoder_index_enable(i) = 0;
            data.reset_count[i] = index;
        }
        if(reset) encoder_velocity(i) = 0;
        else encoder_velocity(i) = (count - data.last_count[i]) /
            encoder_scale(i) / fperiod;
        data.last_index[i] = index;
        data.last_count[i] = count;
        if(reset) data.reset_count[i] = count;
        encoder_count(i) = count - data.reset_count[i];
        encoder_position(i) = encoder_count(i) / encoder_scale(i);

        if(i == 2) {
            debug_0 = count; debug_1 = index;
        }
    }

    ppdata = read32();

    for(i=0; i< 20; i++) {
        int b = ppdata & (1<<i);
        din(i) = !!b; din_not(i) = !b;
    }

    EPP_DIR_WRITE();
}

#include "hal/drivers/pluto_servo_rbf.h"
#define SZ 19895

void program(int base, unsigned char firmware[SZ]) {
    int byte, bit;
    int i;
    rtapi_print_msg(RTAPI_MSG_INFO, "uploading firmware\n");

    // pull the reset low -- bit 2 of status register
    // keep it low 2 microseconds
    for(i=0; i<4; i++) outb(0, base+2);

    // let it go high again
    // delay 10 microseconds to guarantee nStatus high
    for(i=0; i<20; i++) outb(4, base+2);

    // Now program the device...
    for(byte = 0; byte < SZ; byte++) {
	for(bit = 0; bit < 8; bit++) {
	    int v = firmware[byte] & (1<<bit);
	    if(v) outb(0xff, base); else outb(0, base);
	    outb(0|4, base+2);
	    outb(1|4, base+2);
	    outb(0|4, base+2);
	}
    }
    rtapi_print_msg(RTAPI_MSG_INFO, "done\n");
}

EXTRA_SETUP() {
    if(ioaddr_hi == 0) ioaddr_hi = ioaddr + 0x400;

    outb(4, ioaddr + 2);        // set control lines and input mode
    if(ioaddr_hi != -1)
	outb(0, ioaddr_hi + 0x2);    // select SPP mode in ECR
    program(ioaddr, firmware);

    if(ioaddr_hi != -1) {
	if(epp_soft)
	    outb(0x20, ioaddr_hi + 0x2); // select EPP mode in ECR
	else
	    outb(0x80, ioaddr_hi + 0x2); // select EPP mode in ECR
    }

    return 0;
}

EXTRA_CLEANUP() {
    outb(0, ioaddr+2); // set nInitialize low and reset the FPGA
    // ADDR(11);
    // WRITE(0xEE);		// resets the FPGA
    rtapi_print_msg(RTAPI_MSG_ERR, "cleanup\n");
}

RTAPI_MP_INT(ioaddr, "Address of parallel port where pluto-p is attached");
RTAPI_MP_INT(ioaddr_hi, "Secondary address of parallel port (0 to use ioaddr+0x400)");
RTAPI_MP_INT(epp_soft, "Emulate EPP mode on bidirectional port");
RTAPI_MP_INT(epp_wide, "Use 16- and 32-bit EPP transfers with hardware EPP");
