// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motcmds.proto

#ifndef PROTOBUF_motcmds_2eproto__INCLUDED
#define PROTOBUF_motcmds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "emcclass.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motcmds_2eproto();
void protobuf_AssignDesc_motcmds_2eproto();
void protobuf_ShutdownFile_motcmds_2eproto();

class MotionCommand;

enum MotionType {
  EMC_MOTION_TYPE_TRAVERSE = 1,
  EMC_MOTION_TYPE_FEED = 2,
  EMC_MOTION_TYPE_ARC = 3,
  EMC_MOTION_TYPE_TOOLCHANGE = 4,
  EMC_MOTION_TYPE_PROBING = 5,
  EMC_MOTION_TYPE_INDEXROTARY = 6
};
bool MotionType_IsValid(int value);
const MotionType MotionType_MIN = EMC_MOTION_TYPE_TRAVERSE;
const MotionType MotionType_MAX = EMC_MOTION_TYPE_INDEXROTARY;
const int MotionType_ARRAYSIZE = MotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionType_descriptor();
inline const ::std::string& MotionType_Name(MotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionType_descriptor(), value);
}
inline bool MotionType_Parse(
    const ::std::string& name, MotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionType>(
    MotionType_descriptor(), name, value);
}
enum cmd_code_t {
  EMCMOT_ABORT = 4000,
  EMCMOT_AXIS_ABORT = 4001,
  EMCMOT_ENABLE = 4002,
  EMCMOT_DISABLE = 4003,
  EMCMOT_ENABLE_AMPLIFIER = 4004,
  EMCMOT_DISABLE_AMPLIFIER = 4005,
  EMCMOT_ENABLE_WATCHDOG = 4006,
  EMCMOT_DISABLE_WATCHDOG = 4007,
  EMCMOT_ACTIVATE_JOINT = 4008,
  EMCMOT_DEACTIVATE_JOINT = 4009,
  EMCMOT_PAUSE = 4010,
  EMCMOT_RESUME = 4011,
  EMCMOT_STEP = 4012,
  EMCMOT_FREE = 4013,
  EMCMOT_COORD = 4014,
  EMCMOT_TELEOP = 4015,
  EMCMOT_SPINDLE_SCALE = 4016,
  EMCMOT_SS_ENABLE = 4017,
  EMCMOT_FEED_SCALE = 4018,
  EMCMOT_FS_ENABLE = 4019,
  EMCMOT_FH_ENABLE = 4020,
  EMCMOT_AF_ENABLE = 4021,
  EMCMOT_OVERRIDE_LIMITS = 4022,
  EMCMOT_HOME = 4023,
  EMCMOT_UNHOME = 4024,
  EMCMOT_JOG_CONT = 4025,
  EMCMOT_JOG_INCR = 4026,
  EMCMOT_JOG_ABS = 4027,
  EMCMOT_SET_LINE = 4028,
  EMCMOT_SET_CIRCLE = 4029,
  EMCMOT_SET_TELEOP_VECTOR = 4030,
  EMCMOT_CLEAR_PROBE_FLAGS = 4031,
  EMCMOT_PROBE = 4032,
  EMCMOT_RIGID_TAP = 4033,
  EMCMOT_SET_POSITION_LIMITS = 4034,
  EMCMOT_SET_BACKLASH = 4035,
  EMCMOT_SET_MIN_FERROR = 4036,
  EMCMOT_SET_MAX_FERROR = 4037,
  EMCMOT_SET_VEL = 4038,
  EMCMOT_SET_VEL_LIMIT = 4039,
  EMCMOT_SET_JOINT_VEL_LIMIT = 4040,
  EMCMOT_SET_JOINT_ACC_LIMIT = 4041,
  EMCMOT_SET_ACC = 4042,
  EMCMOT_SET_TERM_COND = 4043,
  EMCMOT_SET_NUM_AXES = 4044,
  EMCMOT_SET_WORLD_HOME = 4045,
  EMCMOT_SET_HOMING_PARAMS = 4046,
  EMCMOT_SET_DEBUG = 4047,
  EMCMOT_SET_DOUT = 4048,
  EMCMOT_SET_AOUT = 4049,
  EMCMOT_SET_SPINDLESYNC = 4050,
  EMCMOT_SPINDLE_ON = 4051,
  EMCMOT_SPINDLE_OFF = 4052,
  EMCMOT_SPINDLE_INCREASE = 4053,
  EMCMOT_SPINDLE_DECREASE = 4054,
  EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055,
  EMCMOT_SPINDLE_BRAKE_RELEASE = 4056,
  EMCMOT_SET_MOTOR_OFFSET = 4057,
  EMCMOT_SET_JOINT_COMP = 4058,
  EMCMOT_SET_OFFSET = 4059
};
bool cmd_code_t_IsValid(int value);
const cmd_code_t cmd_code_t_MIN = EMCMOT_ABORT;
const cmd_code_t cmd_code_t_MAX = EMCMOT_SET_OFFSET;
const int cmd_code_t_ARRAYSIZE = cmd_code_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_code_t_descriptor();
inline const ::std::string& cmd_code_t_Name(cmd_code_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_code_t_descriptor(), value);
}
inline bool cmd_code_t_Parse(
    const ::std::string& name, cmd_code_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_code_t>(
    cmd_code_t_descriptor(), name, value);
}
enum cmd_status_t {
  EMCMOT_COMMAND_OK = 0,
  EMCMOT_COMMAND_UNKNOWN_COMMAND = 1,
  EMCMOT_COMMAND_INVALID_COMMAND = 2,
  EMCMOT_COMMAND_INVALID_PARAMS = 3,
  EMCMOT_COMMAND_BAD_EXEC = 4
};
bool cmd_status_t_IsValid(int value);
const cmd_status_t cmd_status_t_MIN = EMCMOT_COMMAND_OK;
const cmd_status_t cmd_status_t_MAX = EMCMOT_COMMAND_BAD_EXEC;
const int cmd_status_t_ARRAYSIZE = cmd_status_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_status_t_descriptor();
inline const ::std::string& cmd_status_t_Name(cmd_status_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_status_t_descriptor(), value);
}
inline bool cmd_status_t_Parse(
    const ::std::string& name, cmd_status_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_status_t>(
    cmd_status_t_descriptor(), name, value);
}
// ===================================================================

class MotionCommand : public ::google::protobuf::Message {
 public:
  MotionCommand();
  virtual ~MotionCommand();

  MotionCommand(const MotionCommand& from);

  inline MotionCommand& operator=(const MotionCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionCommand& default_instance();

  void Swap(MotionCommand* other);

  // implements Message ----------------------------------------------

  MotionCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionCommand& from);
  void MergeFrom(const MotionCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cmd_code_t command = 10;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 10;
  inline ::cmd_code_t command() const;
  inline void set_command(::cmd_code_t value);

  // required fixed32 commandNum = 20;
  inline bool has_commandnum() const;
  inline void clear_commandnum();
  static const int kCommandNumFieldNumber = 20;
  inline ::google::protobuf::uint32 commandnum() const;
  inline void set_commandnum(::google::protobuf::uint32 value);

  // optional double motor_offset = 30;
  inline bool has_motor_offset() const;
  inline void clear_motor_offset();
  static const int kMotorOffsetFieldNumber = 30;
  inline double motor_offset() const;
  inline void set_motor_offset(double value);

  // optional double maxLimit = 40;
  inline bool has_maxlimit() const;
  inline void clear_maxlimit();
  static const int kMaxLimitFieldNumber = 40;
  inline double maxlimit() const;
  inline void set_maxlimit(double value);

  // optional double minLimit = 50;
  inline bool has_minlimit() const;
  inline void clear_minlimit();
  static const int kMinLimitFieldNumber = 50;
  inline double minlimit() const;
  inline void set_minlimit(double value);

  // optional .EmcPose pos = 60;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 60;
  inline const ::EmcPose& pos() const;
  inline ::EmcPose* mutable_pos();
  inline ::EmcPose* release_pos();
  inline void set_allocated_pos(::EmcPose* pos);

  // optional .PmCartesian center = 70;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 70;
  inline const ::PmCartesian& center() const;
  inline ::PmCartesian* mutable_center();
  inline ::PmCartesian* release_center();
  inline void set_allocated_center(::PmCartesian* center);

  // optional .PmCartesian normal = 80;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 80;
  inline const ::PmCartesian& normal() const;
  inline ::PmCartesian* mutable_normal();
  inline ::PmCartesian* release_normal();
  inline void set_allocated_normal(::PmCartesian* normal);

  // optional fixed32 turn = 90;
  inline bool has_turn() const;
  inline void clear_turn();
  static const int kTurnFieldNumber = 90;
  inline ::google::protobuf::uint32 turn() const;
  inline void set_turn(::google::protobuf::uint32 value);

  // optional double vel = 100;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 100;
  inline double vel() const;
  inline void set_vel(double value);

  // optional double ini_maxvel = 110;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 110;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // optional .MotionType motion_type = 120;
  inline bool has_motion_type() const;
  inline void clear_motion_type();
  static const int kMotionTypeFieldNumber = 120;
  inline ::MotionType motion_type() const;
  inline void set_motion_type(::MotionType value);

  // optional double spindlesync = 130;
  inline bool has_spindlesync() const;
  inline void clear_spindlesync();
  static const int kSpindlesyncFieldNumber = 130;
  inline double spindlesync() const;
  inline void set_spindlesync(double value);

  // optional double acc = 140;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 140;
  inline double acc() const;
  inline void set_acc(double value);

  // optional double backlash = 150;
  inline bool has_backlash() const;
  inline void clear_backlash();
  static const int kBacklashFieldNumber = 150;
  inline double backlash() const;
  inline void set_backlash(double value);

  // optional fixed32 id = 160;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 160;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional fixed32 termCond = 170;
  inline bool has_termcond() const;
  inline void clear_termcond();
  static const int kTermCondFieldNumber = 170;
  inline ::google::protobuf::uint32 termcond() const;
  inline void set_termcond(::google::protobuf::uint32 value);

  // optional double tolerance = 180;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 180;
  inline double tolerance() const;
  inline void set_tolerance(double value);

  // optional fixed32 axis = 190;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 190;
  inline ::google::protobuf::uint32 axis() const;
  inline void set_axis(::google::protobuf::uint32 value);

  // optional double scale = 200;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 200;
  inline double scale() const;
  inline void set_scale(double value);

  // optional double offset = 210;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 210;
  inline double offset() const;
  inline void set_offset(double value);

  // optional double home = 220;
  inline bool has_home() const;
  inline void clear_home();
  static const int kHomeFieldNumber = 220;
  inline double home() const;
  inline void set_home(double value);

  // optional double home_final_vel = 230;
  inline bool has_home_final_vel() const;
  inline void clear_home_final_vel();
  static const int kHomeFinalVelFieldNumber = 230;
  inline double home_final_vel() const;
  inline void set_home_final_vel(double value);

  // optional double search_vel = 240;
  inline bool has_search_vel() const;
  inline void clear_search_vel();
  static const int kSearchVelFieldNumber = 240;
  inline double search_vel() const;
  inline void set_search_vel(double value);

  // optional double latch_vel = 250;
  inline bool has_latch_vel() const;
  inline void clear_latch_vel();
  static const int kLatchVelFieldNumber = 250;
  inline double latch_vel() const;
  inline void set_latch_vel(double value);

  // optional fixed32 flags = 260;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 260;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional fixed32 home_sequence = 270;
  inline bool has_home_sequence() const;
  inline void clear_home_sequence();
  static const int kHomeSequenceFieldNumber = 270;
  inline ::google::protobuf::uint32 home_sequence() const;
  inline void set_home_sequence(::google::protobuf::uint32 value);

  // optional fixed32 volatile_home = 280;
  inline bool has_volatile_home() const;
  inline void clear_volatile_home();
  static const int kVolatileHomeFieldNumber = 280;
  inline ::google::protobuf::uint32 volatile_home() const;
  inline void set_volatile_home(::google::protobuf::uint32 value);

  // optional double minFerror = 290;
  inline bool has_minferror() const;
  inline void clear_minferror();
  static const int kMinFerrorFieldNumber = 290;
  inline double minferror() const;
  inline void set_minferror(double value);

  // optional double maxFerror = 300;
  inline bool has_maxferror() const;
  inline void clear_maxferror();
  static const int kMaxFerrorFieldNumber = 300;
  inline double maxferror() const;
  inline void set_maxferror(double value);

  // optional fixed32 wdWait = 310;
  inline bool has_wdwait() const;
  inline void clear_wdwait();
  static const int kWdWaitFieldNumber = 310;
  inline ::google::protobuf::uint32 wdwait() const;
  inline void set_wdwait(::google::protobuf::uint32 value);

  // optional fixed32 debug = 320;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 320;
  inline ::google::protobuf::uint32 debug() const;
  inline void set_debug(::google::protobuf::uint32 value);

  // optional int32 now = 330;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 330;
  inline ::google::protobuf::int32 now() const;
  inline void set_now(::google::protobuf::int32 value);

  // optional int32 out = 340;
  inline bool has_out() const;
  inline void clear_out();
  static const int kOutFieldNumber = 340;
  inline ::google::protobuf::int32 out() const;
  inline void set_out(::google::protobuf::int32 value);

  // optional int32 start = 350;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 350;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 360;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 360;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // optional int32 mode = 370;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 370;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional double comp_nominal = 380;
  inline bool has_comp_nominal() const;
  inline void clear_comp_nominal();
  static const int kCompNominalFieldNumber = 380;
  inline double comp_nominal() const;
  inline void set_comp_nominal(double value);

  // optional double comp_forward = 390;
  inline bool has_comp_forward() const;
  inline void clear_comp_forward();
  static const int kCompForwardFieldNumber = 390;
  inline double comp_forward() const;
  inline void set_comp_forward(double value);

  // optional double comp_reverse = 400;
  inline bool has_comp_reverse() const;
  inline void clear_comp_reverse();
  static const int kCompReverseFieldNumber = 400;
  inline double comp_reverse() const;
  inline void set_comp_reverse(double value);

  // optional int32 probe_type = 410;
  inline bool has_probe_type() const;
  inline void clear_probe_type();
  static const int kProbeTypeFieldNumber = 410;
  inline ::google::protobuf::int32 probe_type() const;
  inline void set_probe_type(::google::protobuf::int32 value);

  // optional .EmcPose tool_offset = 420;
  inline bool has_tool_offset() const;
  inline void clear_tool_offset();
  static const int kToolOffsetFieldNumber = 420;
  inline const ::EmcPose& tool_offset() const;
  inline ::EmcPose* mutable_tool_offset();
  inline ::EmcPose* release_tool_offset();
  inline void set_allocated_tool_offset(::EmcPose* tool_offset);

  // @@protoc_insertion_point(class_scope:MotionCommand)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_commandnum();
  inline void clear_has_commandnum();
  inline void set_has_motor_offset();
  inline void clear_has_motor_offset();
  inline void set_has_maxlimit();
  inline void clear_has_maxlimit();
  inline void set_has_minlimit();
  inline void clear_has_minlimit();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_turn();
  inline void clear_has_turn();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_motion_type();
  inline void clear_has_motion_type();
  inline void set_has_spindlesync();
  inline void clear_has_spindlesync();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_backlash();
  inline void clear_has_backlash();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_termcond();
  inline void clear_has_termcond();
  inline void set_has_tolerance();
  inline void clear_has_tolerance();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_home();
  inline void clear_has_home();
  inline void set_has_home_final_vel();
  inline void clear_has_home_final_vel();
  inline void set_has_search_vel();
  inline void clear_has_search_vel();
  inline void set_has_latch_vel();
  inline void clear_has_latch_vel();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_home_sequence();
  inline void clear_has_home_sequence();
  inline void set_has_volatile_home();
  inline void clear_has_volatile_home();
  inline void set_has_minferror();
  inline void clear_has_minferror();
  inline void set_has_maxferror();
  inline void clear_has_maxferror();
  inline void set_has_wdwait();
  inline void clear_has_wdwait();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_out();
  inline void clear_has_out();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_comp_nominal();
  inline void clear_has_comp_nominal();
  inline void set_has_comp_forward();
  inline void clear_has_comp_forward();
  inline void set_has_comp_reverse();
  inline void clear_has_comp_reverse();
  inline void set_has_probe_type();
  inline void clear_has_probe_type();
  inline void set_has_tool_offset();
  inline void clear_has_tool_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int command_;
  ::google::protobuf::uint32 commandnum_;
  double motor_offset_;
  double maxlimit_;
  double minlimit_;
  ::EmcPose* pos_;
  ::PmCartesian* center_;
  ::PmCartesian* normal_;
  double vel_;
  ::google::protobuf::uint32 turn_;
  int motion_type_;
  double ini_maxvel_;
  double spindlesync_;
  double acc_;
  double backlash_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 termcond_;
  double tolerance_;
  double scale_;
  double offset_;
  double home_;
  ::google::protobuf::uint32 axis_;
  ::google::protobuf::uint32 flags_;
  double home_final_vel_;
  double search_vel_;
  double latch_vel_;
  ::google::protobuf::uint32 home_sequence_;
  ::google::protobuf::uint32 volatile_home_;
  double minferror_;
  double maxferror_;
  ::google::protobuf::uint32 wdwait_;
  ::google::protobuf::uint32 debug_;
  ::google::protobuf::int32 now_;
  ::google::protobuf::int32 out_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  double comp_nominal_;
  double comp_forward_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 probe_type_;
  double comp_reverse_;
  ::EmcPose* tool_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];

  friend void  protobuf_AddDesc_motcmds_2eproto();
  friend void protobuf_AssignDesc_motcmds_2eproto();
  friend void protobuf_ShutdownFile_motcmds_2eproto();

  void InitAsDefaultInstance();
  static MotionCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// MotionCommand

// required .cmd_code_t command = 10;
inline bool MotionCommand::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionCommand::clear_command() {
  command_ = 4000;
  clear_has_command();
}
inline ::cmd_code_t MotionCommand::command() const {
  return static_cast< ::cmd_code_t >(command_);
}
inline void MotionCommand::set_command(::cmd_code_t value) {
  assert(::cmd_code_t_IsValid(value));
  set_has_command();
  command_ = value;
}

// required fixed32 commandNum = 20;
inline bool MotionCommand::has_commandnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_commandnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionCommand::clear_has_commandnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionCommand::clear_commandnum() {
  commandnum_ = 0u;
  clear_has_commandnum();
}
inline ::google::protobuf::uint32 MotionCommand::commandnum() const {
  return commandnum_;
}
inline void MotionCommand::set_commandnum(::google::protobuf::uint32 value) {
  set_has_commandnum();
  commandnum_ = value;
}

// optional double motor_offset = 30;
inline bool MotionCommand::has_motor_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_motor_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionCommand::clear_has_motor_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionCommand::clear_motor_offset() {
  motor_offset_ = 0;
  clear_has_motor_offset();
}
inline double MotionCommand::motor_offset() const {
  return motor_offset_;
}
inline void MotionCommand::set_motor_offset(double value) {
  set_has_motor_offset();
  motor_offset_ = value;
}

// optional double maxLimit = 40;
inline bool MotionCommand::has_maxlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_maxlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionCommand::clear_has_maxlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionCommand::clear_maxlimit() {
  maxlimit_ = 0;
  clear_has_maxlimit();
}
inline double MotionCommand::maxlimit() const {
  return maxlimit_;
}
inline void MotionCommand::set_maxlimit(double value) {
  set_has_maxlimit();
  maxlimit_ = value;
}

// optional double minLimit = 50;
inline bool MotionCommand::has_minlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_minlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionCommand::clear_has_minlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionCommand::clear_minlimit() {
  minlimit_ = 0;
  clear_has_minlimit();
}
inline double MotionCommand::minlimit() const {
  return minlimit_;
}
inline void MotionCommand::set_minlimit(double value) {
  set_has_minlimit();
  minlimit_ = value;
}

// optional .EmcPose pos = 60;
inline bool MotionCommand::has_pos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_pos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionCommand::clear_has_pos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionCommand::clear_pos() {
  if (pos_ != NULL) pos_->::EmcPose::Clear();
  clear_has_pos();
}
inline const ::EmcPose& MotionCommand::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::EmcPose* MotionCommand::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::EmcPose;
  return pos_;
}
inline ::EmcPose* MotionCommand::release_pos() {
  clear_has_pos();
  ::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_pos(::EmcPose* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional .PmCartesian center = 70;
inline bool MotionCommand::has_center() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_center() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionCommand::clear_has_center() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionCommand::clear_center() {
  if (center_ != NULL) center_->::PmCartesian::Clear();
  clear_has_center();
}
inline const ::PmCartesian& MotionCommand::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::PmCartesian* MotionCommand::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::PmCartesian;
  return center_;
}
inline ::PmCartesian* MotionCommand::release_center() {
  clear_has_center();
  ::PmCartesian* temp = center_;
  center_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_center(::PmCartesian* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// optional .PmCartesian normal = 80;
inline bool MotionCommand::has_normal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_normal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionCommand::clear_has_normal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionCommand::clear_normal() {
  if (normal_ != NULL) normal_->::PmCartesian::Clear();
  clear_has_normal();
}
inline const ::PmCartesian& MotionCommand::normal() const {
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::PmCartesian* MotionCommand::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::PmCartesian;
  return normal_;
}
inline ::PmCartesian* MotionCommand::release_normal() {
  clear_has_normal();
  ::PmCartesian* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_normal(::PmCartesian* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
}

// optional fixed32 turn = 90;
inline bool MotionCommand::has_turn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_turn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionCommand::clear_has_turn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionCommand::clear_turn() {
  turn_ = 0u;
  clear_has_turn();
}
inline ::google::protobuf::uint32 MotionCommand::turn() const {
  return turn_;
}
inline void MotionCommand::set_turn(::google::protobuf::uint32 value) {
  set_has_turn();
  turn_ = value;
}

// optional double vel = 100;
inline bool MotionCommand::has_vel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_vel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionCommand::clear_has_vel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionCommand::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double MotionCommand::vel() const {
  return vel_;
}
inline void MotionCommand::set_vel(double value) {
  set_has_vel();
  vel_ = value;
}

// optional double ini_maxvel = 110;
inline bool MotionCommand::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionCommand::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionCommand::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionCommand::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double MotionCommand::ini_maxvel() const {
  return ini_maxvel_;
}
inline void MotionCommand::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
}

// optional .MotionType motion_type = 120;
inline bool MotionCommand::has_motion_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MotionCommand::set_has_motion_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MotionCommand::clear_has_motion_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MotionCommand::clear_motion_type() {
  motion_type_ = 1;
  clear_has_motion_type();
}
inline ::MotionType MotionCommand::motion_type() const {
  return static_cast< ::MotionType >(motion_type_);
}
inline void MotionCommand::set_motion_type(::MotionType value) {
  assert(::MotionType_IsValid(value));
  set_has_motion_type();
  motion_type_ = value;
}

// optional double spindlesync = 130;
inline bool MotionCommand::has_spindlesync() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MotionCommand::set_has_spindlesync() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MotionCommand::clear_has_spindlesync() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MotionCommand::clear_spindlesync() {
  spindlesync_ = 0;
  clear_has_spindlesync();
}
inline double MotionCommand::spindlesync() const {
  return spindlesync_;
}
inline void MotionCommand::set_spindlesync(double value) {
  set_has_spindlesync();
  spindlesync_ = value;
}

// optional double acc = 140;
inline bool MotionCommand::has_acc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MotionCommand::set_has_acc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MotionCommand::clear_has_acc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MotionCommand::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double MotionCommand::acc() const {
  return acc_;
}
inline void MotionCommand::set_acc(double value) {
  set_has_acc();
  acc_ = value;
}

// optional double backlash = 150;
inline bool MotionCommand::has_backlash() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MotionCommand::set_has_backlash() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MotionCommand::clear_has_backlash() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MotionCommand::clear_backlash() {
  backlash_ = 0;
  clear_has_backlash();
}
inline double MotionCommand::backlash() const {
  return backlash_;
}
inline void MotionCommand::set_backlash(double value) {
  set_has_backlash();
  backlash_ = value;
}

// optional fixed32 id = 160;
inline bool MotionCommand::has_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MotionCommand::set_has_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MotionCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MotionCommand::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MotionCommand::id() const {
  return id_;
}
inline void MotionCommand::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional fixed32 termCond = 170;
inline bool MotionCommand::has_termcond() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MotionCommand::set_has_termcond() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MotionCommand::clear_has_termcond() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MotionCommand::clear_termcond() {
  termcond_ = 0u;
  clear_has_termcond();
}
inline ::google::protobuf::uint32 MotionCommand::termcond() const {
  return termcond_;
}
inline void MotionCommand::set_termcond(::google::protobuf::uint32 value) {
  set_has_termcond();
  termcond_ = value;
}

// optional double tolerance = 180;
inline bool MotionCommand::has_tolerance() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MotionCommand::set_has_tolerance() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MotionCommand::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MotionCommand::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double MotionCommand::tolerance() const {
  return tolerance_;
}
inline void MotionCommand::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
}

// optional fixed32 axis = 190;
inline bool MotionCommand::has_axis() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MotionCommand::set_has_axis() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MotionCommand::clear_has_axis() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MotionCommand::clear_axis() {
  axis_ = 0u;
  clear_has_axis();
}
inline ::google::protobuf::uint32 MotionCommand::axis() const {
  return axis_;
}
inline void MotionCommand::set_axis(::google::protobuf::uint32 value) {
  set_has_axis();
  axis_ = value;
}

// optional double scale = 200;
inline bool MotionCommand::has_scale() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MotionCommand::set_has_scale() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MotionCommand::clear_has_scale() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MotionCommand::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double MotionCommand::scale() const {
  return scale_;
}
inline void MotionCommand::set_scale(double value) {
  set_has_scale();
  scale_ = value;
}

// optional double offset = 210;
inline bool MotionCommand::has_offset() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MotionCommand::set_has_offset() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MotionCommand::clear_has_offset() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MotionCommand::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double MotionCommand::offset() const {
  return offset_;
}
inline void MotionCommand::set_offset(double value) {
  set_has_offset();
  offset_ = value;
}

// optional double home = 220;
inline bool MotionCommand::has_home() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MotionCommand::set_has_home() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MotionCommand::clear_has_home() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MotionCommand::clear_home() {
  home_ = 0;
  clear_has_home();
}
inline double MotionCommand::home() const {
  return home_;
}
inline void MotionCommand::set_home(double value) {
  set_has_home();
  home_ = value;
}

// optional double home_final_vel = 230;
inline bool MotionCommand::has_home_final_vel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MotionCommand::set_has_home_final_vel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MotionCommand::clear_has_home_final_vel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MotionCommand::clear_home_final_vel() {
  home_final_vel_ = 0;
  clear_has_home_final_vel();
}
inline double MotionCommand::home_final_vel() const {
  return home_final_vel_;
}
inline void MotionCommand::set_home_final_vel(double value) {
  set_has_home_final_vel();
  home_final_vel_ = value;
}

// optional double search_vel = 240;
inline bool MotionCommand::has_search_vel() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MotionCommand::set_has_search_vel() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MotionCommand::clear_has_search_vel() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MotionCommand::clear_search_vel() {
  search_vel_ = 0;
  clear_has_search_vel();
}
inline double MotionCommand::search_vel() const {
  return search_vel_;
}
inline void MotionCommand::set_search_vel(double value) {
  set_has_search_vel();
  search_vel_ = value;
}

// optional double latch_vel = 250;
inline bool MotionCommand::has_latch_vel() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MotionCommand::set_has_latch_vel() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MotionCommand::clear_has_latch_vel() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MotionCommand::clear_latch_vel() {
  latch_vel_ = 0;
  clear_has_latch_vel();
}
inline double MotionCommand::latch_vel() const {
  return latch_vel_;
}
inline void MotionCommand::set_latch_vel(double value) {
  set_has_latch_vel();
  latch_vel_ = value;
}

// optional fixed32 flags = 260;
inline bool MotionCommand::has_flags() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MotionCommand::set_has_flags() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MotionCommand::clear_has_flags() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MotionCommand::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MotionCommand::flags() const {
  return flags_;
}
inline void MotionCommand::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional fixed32 home_sequence = 270;
inline bool MotionCommand::has_home_sequence() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MotionCommand::set_has_home_sequence() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MotionCommand::clear_has_home_sequence() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MotionCommand::clear_home_sequence() {
  home_sequence_ = 0u;
  clear_has_home_sequence();
}
inline ::google::protobuf::uint32 MotionCommand::home_sequence() const {
  return home_sequence_;
}
inline void MotionCommand::set_home_sequence(::google::protobuf::uint32 value) {
  set_has_home_sequence();
  home_sequence_ = value;
}

// optional fixed32 volatile_home = 280;
inline bool MotionCommand::has_volatile_home() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MotionCommand::set_has_volatile_home() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MotionCommand::clear_has_volatile_home() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MotionCommand::clear_volatile_home() {
  volatile_home_ = 0u;
  clear_has_volatile_home();
}
inline ::google::protobuf::uint32 MotionCommand::volatile_home() const {
  return volatile_home_;
}
inline void MotionCommand::set_volatile_home(::google::protobuf::uint32 value) {
  set_has_volatile_home();
  volatile_home_ = value;
}

// optional double minFerror = 290;
inline bool MotionCommand::has_minferror() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MotionCommand::set_has_minferror() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MotionCommand::clear_has_minferror() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MotionCommand::clear_minferror() {
  minferror_ = 0;
  clear_has_minferror();
}
inline double MotionCommand::minferror() const {
  return minferror_;
}
inline void MotionCommand::set_minferror(double value) {
  set_has_minferror();
  minferror_ = value;
}

// optional double maxFerror = 300;
inline bool MotionCommand::has_maxferror() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MotionCommand::set_has_maxferror() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MotionCommand::clear_has_maxferror() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MotionCommand::clear_maxferror() {
  maxferror_ = 0;
  clear_has_maxferror();
}
inline double MotionCommand::maxferror() const {
  return maxferror_;
}
inline void MotionCommand::set_maxferror(double value) {
  set_has_maxferror();
  maxferror_ = value;
}

// optional fixed32 wdWait = 310;
inline bool MotionCommand::has_wdwait() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MotionCommand::set_has_wdwait() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MotionCommand::clear_has_wdwait() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MotionCommand::clear_wdwait() {
  wdwait_ = 0u;
  clear_has_wdwait();
}
inline ::google::protobuf::uint32 MotionCommand::wdwait() const {
  return wdwait_;
}
inline void MotionCommand::set_wdwait(::google::protobuf::uint32 value) {
  set_has_wdwait();
  wdwait_ = value;
}

// optional fixed32 debug = 320;
inline bool MotionCommand::has_debug() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MotionCommand::set_has_debug() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MotionCommand::clear_has_debug() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MotionCommand::clear_debug() {
  debug_ = 0u;
  clear_has_debug();
}
inline ::google::protobuf::uint32 MotionCommand::debug() const {
  return debug_;
}
inline void MotionCommand::set_debug(::google::protobuf::uint32 value) {
  set_has_debug();
  debug_ = value;
}

// optional int32 now = 330;
inline bool MotionCommand::has_now() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_now() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MotionCommand::clear_has_now() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MotionCommand::clear_now() {
  now_ = 0;
  clear_has_now();
}
inline ::google::protobuf::int32 MotionCommand::now() const {
  return now_;
}
inline void MotionCommand::set_now(::google::protobuf::int32 value) {
  set_has_now();
  now_ = value;
}

// optional int32 out = 340;
inline bool MotionCommand::has_out() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_out() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MotionCommand::clear_has_out() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MotionCommand::clear_out() {
  out_ = 0;
  clear_has_out();
}
inline ::google::protobuf::int32 MotionCommand::out() const {
  return out_;
}
inline void MotionCommand::set_out(::google::protobuf::int32 value) {
  set_has_out();
  out_ = value;
}

// optional int32 start = 350;
inline bool MotionCommand::has_start() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_start() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MotionCommand::clear_has_start() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MotionCommand::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 MotionCommand::start() const {
  return start_;
}
inline void MotionCommand::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 end = 360;
inline bool MotionCommand::has_end() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_end() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MotionCommand::clear_has_end() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MotionCommand::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 MotionCommand::end() const {
  return end_;
}
inline void MotionCommand::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// optional int32 mode = 370;
inline bool MotionCommand::has_mode() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_mode() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MotionCommand::clear_has_mode() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MotionCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 MotionCommand::mode() const {
  return mode_;
}
inline void MotionCommand::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// optional double comp_nominal = 380;
inline bool MotionCommand::has_comp_nominal() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_comp_nominal() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MotionCommand::clear_has_comp_nominal() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MotionCommand::clear_comp_nominal() {
  comp_nominal_ = 0;
  clear_has_comp_nominal();
}
inline double MotionCommand::comp_nominal() const {
  return comp_nominal_;
}
inline void MotionCommand::set_comp_nominal(double value) {
  set_has_comp_nominal();
  comp_nominal_ = value;
}

// optional double comp_forward = 390;
inline bool MotionCommand::has_comp_forward() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_comp_forward() {
  _has_bits_[1] |= 0x00000040u;
}
inline void MotionCommand::clear_has_comp_forward() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void MotionCommand::clear_comp_forward() {
  comp_forward_ = 0;
  clear_has_comp_forward();
}
inline double MotionCommand::comp_forward() const {
  return comp_forward_;
}
inline void MotionCommand::set_comp_forward(double value) {
  set_has_comp_forward();
  comp_forward_ = value;
}

// optional double comp_reverse = 400;
inline bool MotionCommand::has_comp_reverse() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_comp_reverse() {
  _has_bits_[1] |= 0x00000080u;
}
inline void MotionCommand::clear_has_comp_reverse() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void MotionCommand::clear_comp_reverse() {
  comp_reverse_ = 0;
  clear_has_comp_reverse();
}
inline double MotionCommand::comp_reverse() const {
  return comp_reverse_;
}
inline void MotionCommand::set_comp_reverse(double value) {
  set_has_comp_reverse();
  comp_reverse_ = value;
}

// optional int32 probe_type = 410;
inline bool MotionCommand::has_probe_type() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_probe_type() {
  _has_bits_[1] |= 0x00000100u;
}
inline void MotionCommand::clear_has_probe_type() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void MotionCommand::clear_probe_type() {
  probe_type_ = 0;
  clear_has_probe_type();
}
inline ::google::protobuf::int32 MotionCommand::probe_type() const {
  return probe_type_;
}
inline void MotionCommand::set_probe_type(::google::protobuf::int32 value) {
  set_has_probe_type();
  probe_type_ = value;
}

// optional .EmcPose tool_offset = 420;
inline bool MotionCommand::has_tool_offset() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_tool_offset() {
  _has_bits_[1] |= 0x00000200u;
}
inline void MotionCommand::clear_has_tool_offset() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void MotionCommand::clear_tool_offset() {
  if (tool_offset_ != NULL) tool_offset_->::EmcPose::Clear();
  clear_has_tool_offset();
}
inline const ::EmcPose& MotionCommand::tool_offset() const {
  return tool_offset_ != NULL ? *tool_offset_ : *default_instance_->tool_offset_;
}
inline ::EmcPose* MotionCommand::mutable_tool_offset() {
  set_has_tool_offset();
  if (tool_offset_ == NULL) tool_offset_ = new ::EmcPose;
  return tool_offset_;
}
inline ::EmcPose* MotionCommand::release_tool_offset() {
  clear_has_tool_offset();
  ::EmcPose* temp = tool_offset_;
  tool_offset_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_tool_offset(::EmcPose* tool_offset) {
  delete tool_offset_;
  tool_offset_ = tool_offset;
  if (tool_offset) {
    set_has_tool_offset();
  } else {
    clear_has_tool_offset();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MotionType>() {
  return ::MotionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmd_code_t>() {
  return ::cmd_code_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmd_status_t>() {
  return ::cmd_status_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motcmds_2eproto__INCLUDED
