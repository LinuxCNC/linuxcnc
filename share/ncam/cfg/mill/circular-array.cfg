[SUBROUTINE]
icon = circular-array.png
name = Radial Array
image = circular-array.png
type = array-c
help = 	<b>Create radial array of items</b>
order = act h1 cx cy num d opt h3 ang fill rot items

[PARAM_ACT]
name = Active
type = bool
value = 1
tool_tip = Disabling will disable ALL items

[PARAM_H1]
type = sub-header
name = Coords and size

[PARAM_H3]
type = sub-header
name = Rotation and ends

[PARAM_NUM]
name = Number of copies
type = int
minimum_value = 1
icon = num.png
tool_tip = Number of copies
value = 6
header = h1

[PARAM_CX]
name = cX
type = float
icon = center.png
tool_tip = Array center
value = 0
metric_value = 0
header = h1

[PARAM_CY]
name = cY
type = float
icon = center.png
tool_tip = Array center
value = 0
metric_value = 0
header = h1

[PARAM_OPT]
name = Dimension is
type = combo
options = Radius=0:Diameter=1:Distance between groups=2
icon = diameter.png
tool_tip = Select what dimension means
value = 1
header = h1

[PARAM_D]
name = Dimension
type = float
icon = circ-array-diam.png
tool_tip = Diameter of array or
 distance between group of items
value = 2
metric_value = 50
header = h1

[PARAM_ANG]
name = Start
type = float
digits = 2
icon = angle.png
tool_tip = Angle of the first item
value = 0
header = h3
suffix = °

[PARAM_FILL]
name = Fill angle
type = float
digits = 2
icon = angle.png
tool_tip = Angle covered by items
value = 360
header = h3
suffix = °

[PARAM_ROT]
name = Rotate items
type = bool
tool_tip = Rotate each group of items
value = 1
header = h3

[PARAM_ITEMS]
name = Items
type = items
icon = items.png
tool_tip = Items to copy

[DEFINITIONS]
content =
;	<eval>self.include_once(file name here)</eval>

[CALL]
content =

[BEFORE]
content =
	(radial array)
	(authors : Nick Drobchenko and Fernand Veilleux)
	o<#self_id_active> if [#param_act]
		(calc radius)
		o<#self_id_option> if [#param_opt EQ 0] (distance is radius)
			#<radius#ID> = [#param_d * #<_units_radius>]
		o<#self_id_option> elseif [#param_opt EQ 1] (distance is diameter)
			#<radius#ID> = [#param_d / 2 * #<_units_radius>]
		o<#self_id_option> else (distance is between groups of items)
			o<#self_id_optiona> if [[#param_fill MOD 360] EQ 0]
				#<radius#ID> = [#param_d / 2 / SIN[180 / #param_num] * #<_units_radius>]
			o<#self_id_optiona> else
				#<radius#ID> = [#param_d / SIN[#param_fill / #param_num] * #<_units_radius>]
			o<#self_id_optiona> endif
		o<#self_id_option> endif
	
		o<#self_id_fill> if [[[#param_fill MOD 360] NE 0] AND [#param_num GT 1]]
			#<fill#ID> = [#param_fill * #param_num / [#param_num - 1]]
		o<#self_id_fill> else
			#<fill#ID> = #param_fill
		o<#self_id_fill> endif
	
		(get and save current coords system offsets)
		#<old_coord_system#ID> = [#<_coord_system> / 10]
		o<get_offsets> CALL
		#<offset_x#ID> = #<_offsets_x>
		#<offset_y#ID> = #<_offsets_y>
		#<offset_z#ID> = #<_offsets_z>
		#<offset_r#ID> = #<_offsets_r>
	
		(calc new offsets)
		#<cx#ID>    = [#<_offsets_x> + #param_cx]
		#<cy#ID>    = [#<_offsets_y> + #param_cy]
		#<angle#ID> = [#<_offsets_r> + #param_ang]
	
		(change coords system)
		G#<_off_rot_coord_system>
	
		o<#self_id_loop> repeat [#param_num]
			(get rotated coordinates then apply to new coords)
			o<rotate_xy> CALL [#<cx#ID> + #<radius#ID>] [#<cy#ID>] [#<cx#ID>] [#<cy#ID>] [#<angle#ID>]
	
			o<#self_id_rotate_choice> if [#param_rot] (enable rotations of items)
				G10 L2 P#5220 X#<_rotated_x> Y#<_rotated_y> Z#<offset_z#ID> R#<angle#ID>
			o<#self_id_rotate_choice> else
				G10 L2 P#5220 X#<_rotated_x> Y#<_rotated_y> Z#<offset_z#ID> R#<offset_r#ID>
			o<#self_id_rotate_choice> endif
	
			(radial array items)


[AFTER]
content =
			(end radial array items)
			
			(angular increment)
			#<angle#ID>  = [#<angle#ID> + #<fill#ID> / #param_num]
		o<#self_id_loop> endrepeat
	
		(restore coordinate system)
		G#<old_coord_system#ID>
		G10 L2 P#5220 X#<offset_x#ID> Y#<offset_y#ID> Z#<offset_z#ID> R#<offset_r#ID>
	o<#self_id_active> endif
	(end radial array)

