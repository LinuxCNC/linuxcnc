#! /bin/bash
#
# @configure_input@ 
# on @DATE@
#

# Basic variables
export LANG=C
prefix=@prefix@
exec_prefix=@exec_prefix@
RTAPI_INI=@EMC2_SYSTEM_CONFIG_DIR@/rtapi.ini
INIVAR=@libexecdir@/inivar
LSMOD=@LSMOD@
PIDOF=@PIDOF@

# Basic checks
if ! test -r "$RTAPI_INI"; then
    echo "RTAPI configuration file unreadable:  $RTAPI_INI" >&2
    exit 1
fi
if ! test -x "$INIVAR"; then
    echo "Config file tool unusable:  $INIVAR" >&2
    exit 1
fi

# Helper function to get variables from config
getvar() {
    # getvar <variable> [ --flavor ]
    # set variable from rtapi_ini;
    # with --flavor, if $FLAVOR is set, look in the [flavor_$FLAVOR] section
    var=$1
    flav_var=$2

    if test "$flav_var" = "--flavor" -a ! -z "$FLAVOR"; then
	SEC="-sec flavor_$FLAVOR"
    else
	SEC=""
    fi

    eval "$var='$($INIVAR -var $var -ini $RTAPI_INI $SEC 2>/dev/null)'"
}

# Fill in other variable values
#
# Executables
getvar flavor
getvar linuxcnc_module_helper
getvar rtapi_msgd

# Flavor configuration
FLAVOR=$($flavor)
BUILD_SYS=`${flavor} -b`
getvar MODULES --flavor
getvar rtapi_app --flavor

# Other
getvar USE_SHMDRV
if [ "$DEBUG" == "" ]  ; then
    getvar DEBUG
fi
getvar HAL_SIZE


# set the default instance, if not already set
INSTANCE=`printf '%d' $INSTANCE`
if [ "$INSTANCE_NAME" != "" ]  ; then
    NAME_CMD=--instance_name="$INSTANCE_NAME"
else
    unset NAME_CMD
fi


# Compute module lists
#
# kernel threads also need the rtapi and hal_lib kernel modules
test $BUILD_SYS = kbuild && MODULES="$MODULES rtapi hal_lib"
#
# reverse list of modules for unloading
MODULES_UNLOAD=
for MOD in $MODULES; do
    MODULES_UNLOAD="$MOD $MODULES_UNLOAD"
done



# wait for a list of pids to all exit
anywait(){
    for pid in "$@"; do
        while kill -0 "$pid" >/dev/null 2>&1 ; do
            sleep 0.5
        done
    done
}

CheckStatus(){
    if test $BUILD_SYS = user-dso; then
        if [ -z "$($PIDOF rtapi:${INSTANCE})" ]; then
            exit 1
        else
            exit 0
        fi
    else
        # check loaded/unloaded status of modules
        unset NOTLOADED
        for MOD in $MODULES_UNLOAD ; do
            if $LSMOD | awk '{print $1}' | grep -x $MOD >/dev/null ; then
                echo "$MOD is loaded"
            else
                echo "$MOD is not loaded"
                NOTLOADED=NOT
            fi
        done
        if [ -z "$NOTLOADED" ]; then
            exit 0
        else
            exit 1
        fi
    fi
}

Load(){

    # when not running shmdrv, perform shm + instance checks and cleanups
    #
    # FIXME:  how to do these for shmdrv?
    if test $BUILD_SYS = 'user-dso' -a $USE_SHMDRV = no; then
        # check for instance running
	# this is the case if the global segment exists
        # and any processes exist which have it attached
	GLOBALSEG=`printf '/dev/shm/linuxcnc-%d-%2.2d154711' $INSTANCE $INSTANCE` 
	if fuser $GLOBALSEG >/dev/null 2>&1 ; then
	    echo instance $INSTANCE already running!
	    exit 1
	fi

	# check for any leftover shm keys from aborted previous sessions
	INSTKEY=`printf 'linuxcnc-%d-' $INSTANCE` 
	SHMKEYS=`ls /dev/shm/${INSTKEY}* >/dev/null 2>&1`

	if [ "$SHMKEYS" != "" ]  ; then
	    echo -n "warning: leftover shared memory segments detected" >&2
	    echo "- removing: $SHMKEYS" >&2
	    rm  -f  "$SHMKEYS" >/dev/null 2>&1
	fi
    fi

    # kernel threads must have shmdr.ko loaded
    # userland threads optionally may use the shmdrv module
    if test $BUILD_SYS = kbuild -o $USE_SHMDRV = yes; then
	if ! test -c /dev/shmdrv ; then
	    $linuxcnc_module_helper insert shmdrv || return $?
	    # give some time to let shmdrv initialize
	    CheckLoaded
	fi
    fi

    # rtapi_msgd creates the global segment containing the error ring buffer
    # so start this first:

    if ! ${rtapi_msgd} --instance=$INSTANCE $NAME_CMD \
	--rtmsglevel=$DEBUG \
	--usrmsglevel=$DEBUG \
	--halsize=$HAL_SIZE $MSGD_OPTS  ; then
	exitcode=$?
	echo "rtapi_msgd startup failed - aborting" 1>&2
	exit $?
    fi

    # load kernel modules, including shmdrv for userland
    for MOD in $MODULES; do
	# if loading rtapi.ko, tack on parameters
	if test $MOD = rtapi; then
	    $linuxcnc_module_helper insert $MOD \
		rtapi_instance=$INSTANCE $NAME_CMD || return $?
	else
	    $linuxcnc_module_helper insert $MOD || return $?
	fi
    done

    if test $BUILD_SYS = user-dso; then
        # run rtapi_app for userland
	if [ "$DEBUG" != "" ] ; then
	    if ! ${rtapi_app} --instance=$INSTANCE $RTAPI_APP_OPTS ; then
		exitcode=$?
		echo "rtapi_app startup failed - aborting" 1>&2
		exit $?
	    fi
	else
	    if ! ${rtapi_app} --instance=$INSTANCE  $RTAPI_APP_OPTS 2>&1 >/dev/null ; then
		exitcode=$?
		echo "rtapi_app startup failed - aborting" 1>&2
		exit $?
	    fi
        fi

    else  # BUILD_SYS = 'kbuild'
	# help debugging startup issues for kthreads
        if [ "$DEBUG" != "" ] && [ -w /proc/rtapi/debug ] ; then
            echo "$DEBUG" > /proc/rtapi/debug
        fi
    fi
}

CheckLoaded(){
    # this abomination is needed because udev sometimes doesn't
    # have the device ready for us in time.

    # If the shmdrv module isn't in the $MODULES list, skip checks
    if test "${MODULES/shmdrv/}" = "${MODULES}"; then
	# no shmdrv module
	return
    fi

    SHM_DEV=/dev/shmdrv
    n=0
    while [ $n -lt 100 ]; do
        [ -w $SHM_DEV ] && return 0
        echo "." 1>&2
        sleep .1
        n=$(($n+1))
    done
    echo "Can't write to $SHM_DEV - aborting" 1>&2
    exit 1
}



Unload(){
    if test $BUILD_SYS = user-dso; then

	# shutdown rtapi if it exists

	RTAPI_PID=`$PIDOF rtapi:$INSTANCE`
	if [ "$RTAPI_PID" != "" ] ; then
	    if [ "$DEBUG" != "" ] ; then
		${rtapi_app} --instance=$INSTANCE exit
	    else
		${rtapi_app} --instance=$INSTANCE exit            >/dev/null 2>&1
            fi
	fi

	if test $USE_SHMDRV = no; then

	    # remove any linuxcnc-specific POSIX shm segments if they exist
	    # see src/rtapi/rtapi_shmkeys.h: SHM_FMT

	    INSTKEY=`printf 'linuxcnc-%d-' $INSTANCE`
	    rm  -f  /dev/shm/${INSTKEY}* >/dev/null 2>&1
	fi
    fi

    # wait until rtapi_msgd has vanished. This assures
    # that the last user of the global data segment has vanished,
    # making sure an immediate restart of realtime does not find
    # shm segments still hanging around. The only realistic scenario
    # which could trigger this is runtests.

    MSGD_PID=`$PIDOF msgd:$INSTANCE`
    if [ "$MSGD_PID" != "" ] ; then
	kill $MSGD_PID
	anywait $MSGD_PID
    fi

    for module in $MODULES_UNLOAD ; do
	# FIXME: this will fail if another instance is using shmdrv
	# shmdrv is really per-machine, not per-instance
        $linuxcnc_module_helper remove $module
	if [ "$module" == "shmdrv" ] ; then
                # shmdrv needs a bit of time until rtapi+hal_lib
		# have detached shm segments
	    sleep 1
	fi
    done
}

CheckUnloaded(){

    # if msgd:$INSTANCE is still around, this might still be a running instance 
    # after all - this applies to all flavors - msgd is always there, so cop out

    MSGD_PID=`$PIDOF msgd:$INSTANCE`
    if [ "$MSGD_PID" != "" ] ; then
	echo "instance $INSTANCE still running - process msgd:$INSTANCE present (pid $MSGD_PID) !"
	exit 1
    fi

    # if msgd:$INSTANCE isnt running but rtapi:$INSTANCE is, that's bad - msgd
    # should be last to exit
    # this is a noop in kthreads, but clearly an error in uthreads

    RTAPI_PID=`$PIDOF rtapi:$INSTANCE`
    if [ "$RTAPI_PID" != "" ] ; then
	echo "instance $INSTANCE inproperly shutdown!"
	echo "msgd:$INSTANCE gone, but rtapi:$INSTANCE alive (pid $RTAPI_PID)"
	exit 1
    fi

    # regardless if shmdrv is loaded or not, Posix shm segments for this
    # particular instance should not exist and be in use at this point, which 
    # could be the case if a HAL usercomp were still hanging around

    # if any, determine if a process is still using it; complain if so,
    # else remove with a note

    POSIXSHM=`printf '/dev/shm/linuxcnc-%d-*' $INSTANCE`

    for seg in `ls $POSIXSHM 2>/dev/null` ; do
	if pids=`fuser $seg  2>/dev/null` ; then
	    echo instance $INSTANCE: shared memory $seg still in use by pid: $pids !
	else
	    echo instance $INSTANCE: leftover shared memory $seg unused, removing
	    rm -f $seg
	fi
    done

    # TBD: if fuser /dev/shm indicates a process is using shmdrv, then
    # this is likely another instance, so dont try to unload shmdrv
    # because it's going to fail anyway

    # checks to see if all modules were unloaded

    STATUS=
    for module in $MODULES_UNLOAD ; do
	# check to see if the module is installed
	if $LSMOD | awk '{print $1}' | grep -x $module >/dev/null ; then
	    echo "ERROR: Could not unload '$module'"
	    STATUS=error
	fi
    done
    if [ -n "$STATUS" ] ; then
	exit 1
    fi
}

CMD=$1

case "$CMD" in

  start|load)
	Load || exit $?
	CheckLoaded
	;;
  restart|force-reload)
	Unload
	CheckUnloaded
	Load || exit $?
	CheckLoaded
	;;
  stop|unload)
	Unload || exit $?
	;;
  status)
	CheckStatus
	;;
  # for script debugging
  unloadcheck)
	CheckUnloaded
	;;
  # for script debugging
  loadcheck)
	CheckLoaded
	;;
  *)
	echo "Usage: $0 {start|load|stop|unload|restart|force-reload|status}" >&2
	exit 1
	;;
esac

exit 0

