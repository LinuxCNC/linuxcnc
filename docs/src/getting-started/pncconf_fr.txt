:lang: fr

= Assistant graphique de configuration Mesa

[[cha:Assistant-graphique-PNCConf]]

L'assistant de configuration PNCconf couvre toute la gamme  des cartes d'entrées/
sorties Mesa et jusqu'à trois ports parallèles. Il est destiné à la
configuration de systèmes à servomoteurs en boucle fermée ou de systèmes à
moteurs pas à pas avec pilotage _matériel_ externe. Il utilise une approche
d'assistance similaire à celle de StepConf qui est lui, utilisé pour configurer
les systèmes avec pilotage _logiciel_ des moteurs pas à pas, au travers de ports
parallèles. Pour une machine n'utilisant qu’un à trois ports parallèles
standards, le logiciel StepConf est un assistant mieux adapté.

L'assistant PNCconf permet de produire des configurations avancées sans
connaitre quoi que ce soit de HAL.

PNCconf en est encore au stade du développement (Beta 1) il peut exister
quelques bogues et manques de fonctionnalités.
Merci de rapporter les bogues et les suggestions à la page du forum ou par
courriel à la liste de diffusion.

Il y a deux manières d'utiliser PNCconf:

. La première consiste à l'utiliser pour configurer le système et si, par
la suite, certaines options doivent être modifiées, il suffira alors de
recharger PNCconf et d'apporter les modifications aux réglages.
Cela fonctionne bien si la machine est assez standard, pour les machines
particulières il est possible d'ajouter à la main les nouvelles fonctionnalités.
PCNConf est bien adapté pour cette utilisation.
 
. La seconde consiste à l'utiliser pour construire une configuration la plus
proche possible de ce qui est souhaité, puis à la modifier à la main pour
l'adapter aux besoins. C'est le bon choix si les besoins de modifications vont
au-delà des possibilités de PNCconf ou pour expérimenter et en apprendre plus
sur LinuxCNC.

Il est possible de naviguer dans l'assistant, revenir sur des pages, annuler des
choix, obtenir de l'aide et des diagrammes puis enfin, de valider la
configuration par la page de sortie du programme.

****
NDT: Certaines divergences entre cette traduction et l'aspect réel de
l'interface peuvent apparaitre pendant la phase de développement de PNCconf.
Elles disparaitront quand le logiciel sera finalisé.
****

== Instructions pas à pas

Démarrer le programme depuis le menu _Applications → CNC → PNCconf_ ou
depuis un terminal avec la commande:

----
pncconf
---- 

.Écran d'accueil de PnCConf

image::images/pncconf-splash_fr.png[alt="Écran d'accueil de PnCConf"]

== Créer ou éditer une configuration

.Créer ou éditer

image::images/pncconf-file_fr.png[alt="Créer ou éditer"]

Il est possible de créer une nouvelle configuration ou d'en modifier une
existante.
Si _Modifier une configuration déjà créée_ est choisi, suivi d'un clic
sur _Suivant_, un sélecteur de fichier apparait pour choisir la configuration
existante à modifier. Par défaut, Pncconf présélectionne le dernier fichier
enregistré. Il est possible de cocher les options _Créer un lien sur le
bureau_ qui créera un lien sur le bureau pointant sur ce nouveau fichier de
configuration, _Créer un lanceur_ qui créera un lanceur sur le bureau qui
démarrera LinuxCNC dans cette configuration.
Si ces options ne sont pas utilisées, le nouveau fichier de configuration se
trouvera dans le dossier _~/linuxcnc/configs_. Il est toujours  possible de
lancer LinuxCNC normalement et de sélectionner la configuration souhaitée dans
la liste.

== Informations machine

.Informations machine

image::images/pncconf-basic_fr.png[alt="Informations machine"]

_Éléments de base_

Nom de la machine::
    Préciser ici le nom de la machine à configurer, les espaces dans les noms
    seront remplacés par des *'_'* (en règle générale,  Linux n'aime pas les
    espaces dans les noms de fichiers).

Configuration des axes::
    Cette liste déroulante précise le nombre d'axes de la machine,
    sélectionner selon la machine XYZ (fraiseuse 3 axes), XYZA (fraiseuse 4
    axes) ou XZ (tour).

Unité machine::
    Définit l'unité de mesure utilisée par la machine, pouce ou millimètre,
    toutes les données introduites par la suite devront être données dans
    l'unité choisie ici.

    Les valeurs introduites par défaut dans cet assistant ne sont pas converties
    automatiquement dans l'unité choisie ici, bien vérifier toutes ces valeurs.

_Temps de réponse de l'ordinateur_

Période servo actuelle::
    La période d'asservissement. C'est l'horloge du système. La latence donne
    la variation de cette horloge. LinuxCNC demande une chronologie serrée et
    cohérente, sinon des problèmes surviendront.

Quelques explications:
LinuxCNC requiert et utilise un système d'exploitation temps réel, ce qui
signifie qu'il a une latence très faible et un temps de réponse très court. Les
évènements arrivent avec précision dans le temps quand LinuxCNC nécessite pour
ses calculs, de ne pas être interrompu par des demandes de priorité inférieure
(interruptions) comme des saisies au clavier ou des demandes d'affichage.

Le test de latence est très important, il est un élément clef qui doit être
effectué au plus tôt. Heureusement les cartes Mesa se chargent des tâches
critiques en temps de réponse, comme le comptage d'impulsions, la génération de
PWM et cela leur permet de supporter une latence supérieure à celle d'un système
utilisant les ports parallèles de la carte mère.

Le test standard dans LinuxCNC, consiste à vérifier la latence de base du PC. Un
appui sur le bouton _Test de latence_ lancera le test de latence, il est
également possible de le lancer depuis le menu _application → cnc → latency
test_. Une fenêtre s'ouvre dans laquelle s'affichent les temps mesurés.
Ce test doit fonctionner plusieurs minutes, en fait, le plus longtemps possible.
15 minutes est un minimum. Pendant le test, essayer d'utiliser le plus possible
l'ordinateur, le réseau, le port USB, les disques durs, l'affichage.
Observer et noter si une action particulière dégrade le temps de latence.
A la fin, il sera possible de connaitre la _base period jitter_, la latence de
base. Une valeur en dessous de 20000 est excellente et permet une génération
rapide des impulsions de pas avec cette machine.+
20000 à 50000 est assez bon pour la génération de pas. +
50000 à 100000 ce n'est pas très bon mais la machine peu encore servir pour la
génération de pas avec une carte ayant des temps de réponse courts. +
Plus grand que 100000, la machine n'est pas utilisable pour cette fonction

Si la latence est médiocre ou si des problèmes intermittents surviennent
régulièrement il sera toujours possible de l'améliorer.

TIP: Il y a une liste d'équipements et de leurs temps de latence sur
http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Latency-Test[le wiki de LinuxCNC] +
SVP, pensez à ajouter vos infos à la liste. Sur cette page il y a des liens vers
des informations pour résoudre certains problèmes de latence.

Maintenant que nous avons un temps de latence acceptable nous devons choisir
une période d'asservissement (Période servo actuelle).
Dans la plupart des cas une période d'asservissement de 1000000ns est bonne,
cela donne un taux de calcul de 1 kHz soit 1000 calculs par seconde.
Si le système d'asservissement est construit en boucle fermée avec contrôle
de couple (courant) plutôt que de vitesse (tension) le taux sera meilleur,
quelque chose comme 5000 calculs par seconde (5 kHz). Le problème avec
l'abaissement de la période, c'est qu'elle laisse moins de temps disponible à
l'ordinateur pour faire d'autres choses. Typiquement la réponse de l'affichage
(GUI) est moins bonne. Il faut choisir un équilibre. Garder à l'esprit que sur
un mécanisme en boucle fermée, une modification de la période d'asservissement
nécessitera de réajuster l'ensemble des paramètres de la boucle.

_Ports et cartes d'entrées/sorties_

PNCconf est capable de configurer une machines avec deux cartes Mesa et
trois ports parallèles. Les ports parallèles ne sont utilisables que pour
des actions simples et peu rapide.

Mesa::
     Au moins une carte Mesa doit être choisie. PNCconf ne peut pas configurer
    les ports parallèles pour des codeurs, des signaux de pas ou pour la
    génération de signaux PWM. La liste de sélection des cartes Mesa présentes
    dans la liste de sélection est construite selon les micros logiciels des
    cartes trouvées sur le système. Il existe des options permettant d'ajouter
    des micros logiciels personnalisés ou pour ignorer (blacklister) certaines
    versions de micros logiciels ou certaines cartes, en utilisant un fichier
    de préférences.
     Si aucune carte n'est détectée PNCconf affichera un avertissement et
    utilisera des valeurs par défaut mais aucun test ne sera possible. Il faut
    noter que, si plusieurs cartes Mesa sont utilisées, il n'existe aucun moyen
    de déterminer laquelle sera la carte N°0 ou N°1 et il sera indispensable de
    le tester. Déplacer les cartes dans les ports PCI, peut changer leur ordre.
    Si la configuration est créée pour deux cartes, elles doivent être
    installées pour que les tests fonctionnent.

Ports parallèles::
     Jusqu'à 3 ports parallèles, appelés parports par Mesa, peuvent être
    utilisés comme de simples entrées sorties. L'adresse du port parallèle doit
    être définie. Il est possible soit d'entrer le N° du port parallèle selon le
    système de numérotation de Linux 0, 1 ou 2 ou, d'entrer l'adresse réelle en
    hexadécimal. Les adresses des ports parallèles intégrés à la carte mère son
    le plus souvent aux adresses 0x0378 et 0x0278, elles peuvent être trouvées
    dans la configuration du BIOS. Le Bios s'ouvre en enfonçant une touche du
    clavier au tout début du cycle de démarrage de l'ordinateur, souvent (Del
    ou F2) se reporter au document de la carte mère. Sur une des pages du BIOS,
    il est possible de choisir l'adresse des ports parallèles et de définir
    leurs modes de fonctionnement comme SPP, EPP, etc, sur certains ordinateurs
    cette information est affichée pendant quelques secondes lors du démarrage
    du PC. Pour les ports parallèles sur carte PCI les adresses sont trouvées
    en cliquant sur le bouton _Outil d'aide à la recherche d'adresse de ports
    parallèles_ qui affichera la liste des périphériques PCI découverts. Dans
    cette liste, se trouvera une référence aux ports parallèles avec une liste
    d'adresses. Une de ces adresses doit fonctionner. Noter que tous les ports
    parallèles PCI ne fonctionnent pas correctement en EPP. Chaque port peut être
    sélectionné comme _Entrée_ pour augmenter le nombre d'entrées sur ce port
    ou _Sortie_ pour un maximum de sorties. Par défaut, les ports parallèles
    sont configurés avec leurs broches 2 à 9 en _Sortie_.

_Liste des interfaces graphiques_

Spécifie les interfaces utilisateur graphiques que LinuxCNC peut utiliser.
Chacune dispose d'options particulières.

_AXIS_

* Supporte les tours.
* C'est l'interface la plus utilisée et la plus développée.
* Elle est conçue pour être utilisée à la souris est avec un clavier.
* Elle est basée sur tkinter et intègre donc PYVCP (contrôle visuel python).
* Elle dispose d'un affichage graphique en 3D.
* Elle est intégrable sur les barres de tâches ou sur le bureau.

_TOUCHY_

* Touchy est une interface conçue pour les écrans tactiles.
* Elle ne nécessite que quelques interrupteurs physiques et une manivelle de
jog.
* Elle nécessite les boutons _Départ cycle_, _Abandon_, _Marche par pas_.
* Elle nécessite également un bouton sélecteur d'axe sur le jog.
* Elle est basée sur GTK et intègre naturellement GladeVCP (création de
panneaux de contrôle).
* Elle permet d'intégrer les panneaux de contrôle virtuels (VCP).
* Elle n'a pas de fenêtre de suivi du parcours d'outil.
* L'aspect peut être modifié avec des thèmes personnalisés.

*MINI_

* Est fourni en standard sur les machines Sherline.
* N'utilise pas d'arrêt d'urgence (ESTOP).
* Pas de possibilité d'intégrer un panneau de contrôle.
            
_TkLinuxCNC_

* Contraste élevé grâce à un fond bleu.
* Fenêtre graphique séparée.
* Pas d'intégration de panneau de contrôle possible.

== Contrôles externes

Cette page permet de sélectionner des contrôles externes pour la commande
manuelle de déplacement des axes (jog) ou des curseurs des correcteurs de vitesse.

.Contrôles externes

image::images/pncconf-external_fr.png[alt="Contrôles externes"]

Si une manette de jeu externe est sélectionnée pour le jog, il faudra
toujours la connecter à LinuxCNC avant de démarrer celui-ci. Si la manette est
analogique il faudra probablement ajouter du code personnalisé à HAL.
Les manivelles de jog à vernier et micro impulsion nécessitent d'être
connectées à une carte Mesa sur un compteur de codeur. Pour les correcteurs de
vitesses externe il est possible d'utiliser un mécanisme à générateur
d'impulsions ou à commutation comme un commutateur rotatif.
Les boutons externes peuvent être ceux d'une manette de jeu.

Joystick USB pour le jog::
     Demande des règlages spécifiques personnalisés pour être installé dans le
    système. Il s'agi d'un fichier qui est utilisé par LinuxCNC pour se connecter
    à la liste des périphériques Linux. PNCconf aidera à la construction de ce
    fichier.

* Ajouter règle dispositif: s'utilise pour configurer un nouveau périphérique
    en suivant les instructions. Le périphérique doit être branché et disponible.

* test dispositif: permet de charger un périphérique, d'afficher les noms de
    ses broches et de visualiser ses fonctions avec l’outil halmeter.

* Rechercher règles pour le dispositif: va rechercher les règles dans le
    système, utilisable pour trouver le nom des périphériques déjà construits
    avec PNCconf.

Les manettes de jeu utilisées en jog utilisent HALUI et le composant
hal_input.

Boutons de jog externes::
     Permet le jog de l'axe avec de simples boutons à une vitesse spécifiée.
    Probablement mieux adapté pour le jog en vitesse rapide.

Manivelle de jog externe::
     Permet d'utiliser un générateur d'impulsions manuel pour faire du
    jog sur les axes de la machine.
    Les manivelles à impulsions (MPG) sont souvent présentes sur les machines
    de bonne qualité. Elles délivrent en sortie des impulsions en quadrature qui
    peuvent être comptées avec un compteur de codeur MESA. PNCconf gère une
    manivelle par axe ou une manivelle partagée entre les axes.
    Il permet la sélection des vitesses de jog en utilisant des commutateurs
    rotatifs. L'option  de sélection des incréments de jog utilise le
    composant mux16. Ce composant dispose d'options telles que l'anti-rebond et
    l'utilisation du code Gray pour filtrer l'entrée physique du commutateur.

Correcteurs de vitesses::
     PNCconf permet de modifier les vitesses d'avances ou de broche en utilisant
    une manivelle à micros impulsions ou un commutateur rotatif. Les
    incréments sont configurables.

== Configuration des GUI

Ici il est possible de  configurer l'interface graphique utilisateur (GUI), lui
ajouter des panneaux de commande virtuels (VCP) et définir certaines options
d'LinuxCNC.

.Configuration des GUI

image::images/pncconf-gui_fr.png[alt="Configuration des GUI"]

_Options des interfaces graphiques_

Valeurs communes par défaut::
    Permet de fixer des valeurs générales par défaut, communes à toutes les
    interfaces graphiques.

Options par défaut d'AXIS:: 
     Ici se trouve les options spécifiques à AXIS. Si une des options _Taille_,
    _Position_ ou _Forcer à maximiser_ et choisie, il sera possible de modifier
    les valeurs de vitesse minimale ou maximale, le choix de l'éditeur de fichiers,
    la géométrie de la machine affichée. Ensuite, PNCconf demandera si il peut
    écraser le fichier de préférences (.Axisrc).
    Ce qui écrasera les données qui aurait été ajoutées extérieurement dans ce
    fichier.
 
Touchy:: 
     Ici se trouve les options spécifiques à Touchy. La plupart des options de
    Touchy peuvent être modifiées dans la page des préférences de l'application
    même quand elle est en marche. Touchy utilise GTK pour dessiner son écran,
    et supporte les thèmes GTK. Les thèmes modifient l'apparence et l'ergonomie
    du programme. il est possible de télécharger des thèmes depuis le net ou
    de les modifier soit-même. Il y a déjà une liste des thèmes utilisables sur
    le système. PNCconf permet de modifier facilement le thème par défaut.

_Panneaux de contrôle virtuels_

Les panneaux de contrôle virtuels permettent d'ajouter des contrôles
et des afficheurs personnalisés. AXIS et Touchy peuvent intégrer ces
contrôles dans une zone déterminée de leur écran. Il y a deux sortes de
panneaux de contrôle (VCP), pyVCP qui utilise _Tkinter_ pour dessiner
l'écran ou GLADE VCP qui utilise _GTK_.

Panneau PyVCP::
     PyVCP est un écran construit par un fichier XML. Il ne peut pas être
    construit à la main. Les PyVCP s'intègrent naturellement avec AXIS car ils
    utilisent tous les deux Tkinter. Des _HAL pins_ sont créées pour que
    l'utilisateur puisse les connecter dans son fichier HAL personnalisé.
    Il existe par exemple, un tachymètre pour la vitesse de broche ou un panneau
    de boutons XYZ pour le jog, l'utilisateur peut les utiliser tel quel ou
    les reconstruire à son gout.
    Sélectionner un fichier vide où les contrôles (widgets) personnels seront
    enregistrés ou sélectionner un des modèles d'affichage prêts à l'emploi,
    PCCcong établira alors lui-même les bonnes connexions avec HAL.
    Si AXIS est utilisé, le panneau sera intégré sur le côté droit.
    Si AXIS n'est pas utilisé, le panneau sera distinct de l'écran frontal.
    Il est possible d'utiliser les options de géométrie et de dimensions
    et de déplacer le panneau, par exemple si le système le permet vers un second
    écran. Si le bouton _Ouvrir un panneau simple_ est pressé, les données de
    géométrie et de dimensions seront utilisées et le panneau affiché.

Panneau GladeVCP::
     GladeVCP s'intègre naturellement à l'intérieur de l'écran TOUCHY car ils
    utilisent tous les deux GTK pour leurs interfaces, mais en modifiant le thème
    de GladeVCP il se fond très bien dans AXIS. Il utilise un éditeur graphique
    pour créer ses fichiers XML. Des _HAL pins_ sont créées, que l'utilisateur
    pourra connecter dans son fichier HAL personnalisé.
    GladeVCP permet aussi une interaction de programmation beaucoup plus
    sophistiquée et compliquée, ce qui n'est actuellement pas possible par PNCconf.
    Voir le chapitre sur GladeVCP et <<cha:GladeVCP, la création d'interfaces
    graphiques>>

PNCconf propose des exemples de panneaux à utiliser tel quel ou à reconstruire.
Avec PNCconf, GladeVCP permettra de sélectionner différentes options d'affichage
sur le modèle. Sous _Echantillon d'options_ sélectionner les options souhaitées.
Les boutons de zéro utilisent des commandes HALUI qui pourront être modifiées
ultérieurement dans la section HALUI. Le bouton _Toucher Z automatique_
nécessite le programme _Touch-off_ de classicladder et que l'entrée de sonde
soit sélectionnée. Il faut aussi un palpeur qui peut être réalisé avec une
plaque conductrice reliée à la masse. Pour avoir une idée sur la façon dont
cela fonctionne, voir:
//http://wiki.linuxcnc.org/cgi-bin/wiki.pl?ClassicLadderExamples#Single_button_probe_touchoff[ Simple bouton "Toucher"]

Sous _Options d'affichage_, les options de géométrie et de dimensions
permettent de déplacer le panneau, par exemple vers un second écran, si le
système le permet. Sélectionner un thème GTK pour définir l'aspect du panneaux.
En général, on le souhaite identique à l'aspect de l'écran frontal.
Le panneau créé et ses options seront visibles en appuyant sur le
bouton _Ouvrir un panneau simple_. GladeVCP placé sur l'écran frontal permet de
sélectionner la position du panneau sur celui-ci. Il peut fonctionner de
manière autonome ou avec AXIS, il peut être au centre ou sur le côté droit,
avec Touchy il peut être au centre.

_Défauts et options_

Prise d'origine requise avant tout mouvement::
    Pour pouvoir déplacer la machine sans passer par une recherche du point
    d'origine machine décocher la case. Dans ce cas la plus grande vigilance est
    nécessaire pour ne pas percuter une limite.

Dialogue pour le changement d'outil::
    Permet le choix entre l'utilisation d'un dialogue de changement d'outil et
    l'exportation d'un signal standard pour utiliser un changeur d'outils
    automatique externe et la table d'outils.

Laisser tourner la broche pendant le changement d'outil::
    Laisse tourner la broche pendant le changement d'outil. Utile pour les tours.

Forcer la prise d'origine individuelle en manuel::
    Oblige à effectuer la prise d'origine individuelle de chaque axe en manuel.

Relever la broche avant le changement d'outil::
    Met la broche en position haute avant le changement d'outil.
  
Récupérer position jointure après arrêt::
    Mémorise la position des articulations lors de l'arrêt. Utilisé pour les
    machines a cinématique complexe.

Changeur d'outil à position aléatoire::
    Utilisé pour les changeurs d'outils qui ne reçoivent pas toujours les outils
au mêmes emplacements. Des codes HAL doivent être ajoutés pour le support de ces
changeurs d'outils.

== Configuration Mesa

Les pages de configuration Mesa permettent d'utiliser les différents micros
logiciels. Sur la page de configuration, si une carte Mesa a été sélectionnée,
ici s'effectue le choix du micro logiciel parmi ceux disponibles, puis le choix et
le paramétrage des composants nécessaires à la machine.

.Configuration Mesa

image::images/pncconf-mesa-config_fr.png[alt="Configuration Mesa"]

Adresse du port parallèle MESA::
     Un port parallèle est utilisé seulement avec la carte Mesa 7i43.
    Les ports parallèles sur la carte mère ont généralement les adresses 0x378 et
    0x278 il est possible de trouver l'adresse sur la page du BIOS.
    Le 7i43 nécessite de programmer le port parallèle dans le mode EPP,
    encore une fois cela se configure dans la page du BIOS. Si un port parallèle
    sur carte PCI est utilisé, les adresses peuvent être recherchées en utilisant
    le bouton de recherche sur la page de base de PNCConf.

IMPORTANT: Noter que beaucoup de cartes PCI ne prennent pas en charge le
    protocole EPP correctement.

Fréquence de base PWM, PDM et 3PWM:: footnote:[PDM: acronyme de Modulation de
Densité d'Impulsions, PWM: acronyme de Modulation de Largeur d'Impulsions]
    Règle l'équilibrage entre entrainement et linéarité.
    Si des cartes filles Mesa sont utilisées, les documents de celles-ci
    devraient donner des recommandations. Il est important de les suivre pour
    éviter des dommages et obtenir les meilleures performances.

Par exemple....::
- La carte 7i33 demande un PDM et une fréquence de base de 6 mHz.
- La carte 7i29 demande un PWM et une fréquence de base de 20 Khz.
- La carte 7i30 demande un PWM et une fréquence de base de 20 Khz.
- La carte 7i40 demande un PWM et une fréquence de base de 50 Khz.
- La carte 7i48 demande un PWM et une fréquence de base de 24 Khz.

Délai du chien de garde::
     Définit le délai durant lequel la carte Mesa va attendre avant de
    déconnecter les sorties si la communication est interrompue avec l'ordinateur.
    Les carte Mesa utilisent sur ce contact un niveau actif bas ce qui signifie
    que lorsque la sortie est activée son niveau logique est à 0 et si la sortie
    est inactive son niveau logique est à 1 soit environ 5 volts. S'assurer
    que l'équipement est en sécurité quand le chien de garde est déclenché.

Nombre de codeurs::
Nombre de générateur de PWM::
Nombre de générateur de PAS::
     Il est possible de choisir les composants en dé-sélectionnant ceux qui sont
    inutilisés. Les types de composants disponibles varient selon le micro
    logiciel et les cartes installées.
    Si des composants ne sont pas sélectionnés, des broches GPIO seront gagnées.
    Si des cartes filles sont utilisées, garder à l'esprit que les pins que
    les cartes utilisent ne doivent pas être dé-sélectionnées. Par exemple,
    certain micros logiciels supportent deux cartes 7i33, si une seule est
    installée, il est possible de dé-sélectionner assez de composants non
    nécessaires pour utiliser le connecteur qui était prévus pour la seconde
    7i33. Les composants sont dé-sélectionnés numériquement en commençant par le
    plus grand nombre d'abord, puis en descendant sans en sauter. Si en faisant
    cela, les composants ne sont pas là où il devraient, alors il faut utiliser
    un micro logiciel différent. Le micro logiciel dicte où, quoi et les nombre
    maximum de composants. Un micro logiciel personnalisé est possible en le
    demandant gentiment aux développeurs LinuxCNC et Mesa.
    Les micros logiciels dans PNCconf nécessitent des procédures spéciales et ce
    n'est pas toujours possible. Bien que nous essayons de rendre PNCconf aussi
    souple que possible.
    Après avoir choisi toutes les options, appuyer sur le bouton
    _Accepter le changement de composants_ et PNCconf mettra à jour les pages
    de configuration des E / S. Seuls les onglets nécessaires seront affichés
    pour les connexions disponibles, selon les documents de Mesa.

== Réglages des E/S Mesa

Les onglets sont utilisés pour configurer les broches d'entrée et de sortie
des cartes Mesa. PNCconf permet de créer des noms de signaux personnalisés
à utiliser dans les fichiers de HAL personnalisés.

.Réglages des E/S Mesa C2

image::images/pncconf-mesa-io2_fr.png[alt="Réglages des E/S Mesa C2"]
Sur cet onglet, avec ce micro logiciel, les composants sont liés à l'installation
d'une carte fille 7i33, généralement utilisée avec des servomoteurs en boucle fermée.
Noter que les numéros de composant des codeurs, des compteurs et des pilotes PWM
ne sont pas dans l'ordre numérique. Cela fait suite aux exigences de
l'architecture des cartes filles.

.Réglages des E/S Mesa C3

image::images/pncconf-mesa-io3_fr.png[alt="Réglages des E/S Mesa C3"]
Sur cet onglet, il n'y a que des broches GPIO. Noter les numéros à trois
chiffres, ils correspondent au numéros des _HAL pins_. Les broches GPIO
peuvent être sélectionnées comme des entrées ou des sorties et elles peuvent
être inversées.

.Réglages des E/S Mesa C4

image::images/pncconf-mesa-io4_fr.png[alt="Réglages des E/S Mesa C4"]
Sur cet onglet, il y a un mélange entre des broches GPIO et des générateurs de pas.
Les sorties générateur de pas et de direction peuvent être inversées.
Noter que l'inversion d'un signal Step Gen modifie les délais de pas,
il doivent correspondre à ce que le contrôleur attend.

_Configuration des ports parallèles_

image::images/pncconf-parport_fr.png[alt="Configuration des ports parallèles"]

Les ports parallèles peuvent être utilisés pour de simples E/S similaires aux
broches GPIO Mesa.

== Configuration des axes


.Configuration des axes

image::images/pncconf-axis-drive_fr.png[alt="Configuration des axes"]

Cette page permet de configurer et tester un moteur combiné ou non à un codeur.
Si un servomoteur est utilisé, un test en boucle ouverte est disponible.
si un moteur pas à pas est utilisé, un test de réglage est disponible.

Test en boucle ouverte::
     Le test en boucle ouverte est important car il confirme la bonne direction du
    moteur et du codeur. Le moteur doit se déplacer dans le sens positif sur l'axe
    lorsque le bouton est pressé dans le sens positifs et aussi le codeur doit compter
    dans le même sens. Le mouvement de l'axe doit suivre les normes conventionnelles
    des machine-outil, sinon l'affichage graphique de l'axe n'aura pas de sens.
    Espérons que la page d'aide et le diagramme vous aideront à comprendre cela.
    Noter que les directions des axes sont celles du mouvement de l'outil et non
    celle du mouvement de la table. Il n'y a pas de rampe d'accélération lors du test
    en boucle ouverte, il convient donc de commencer avec une valeur faible du DAC.
    Déplacer l'axe sur une distance connue, confirmera la bonne mise à l'échelle du
    codeur. Le codeur doit compter dans le même sens, même sans la puissance sur le
    moteur, mais cela dépend de la manière dont le codeur est alimenté.

[red]#AVERTISSEMENT:# Si le moteur et le codeur ne comptent pas dans le même sens,
le servomoteur sera incontrôlable et s'emballera lors de l'utilisation en boucle
fermée sous régulation PID.footnote:[ PID: acronyme de Proportionnelle, Intégrale,
Dérivée. Ce sont les 3 composantes de la régulation en boucle fermée de type PID.]

Pour le moment les paramètres PID ne peuvent pas être testés dans PNCconf,
ces réglages sont vraiment, pour quand vous rééditerez une configuration pour y
mettre vos paramètres PID testés...

Echelle du DAC:: footnote:[ DAC, acronyme pour Convertisseur Analogique Digital]
     Deux valeurs de mise à l'échelle, _Max Output_ et _Offset_ sont utilisées
    pour linéariser le DAC.

Théorie::
     Ces deux valeurs sont les facteurs d'échelle et d'offset de la sortie vers
    l’amplificateur moteur, de l'axe. La deuxième valeur, l'offset, est soustraite
    de la sortie calculée (en Volts) et divisée par la première valeur (le facteur
d'échelle),
    avant d'être écrite dans le DAC. La valeur d'échelle (Scale) s'exprime en
    Volts/Volts de sortie du DAC. Le décalage (offset) s'exprime en Volts.
    Elles peuvent être utilisées pour linéariser le DAC. Plus précisément, lors
    de l'écriture des sorties, LinuxCNC convertit d'abord la valeur effective de la
    sortie concernée, qui est en quasi-unités SI, en valeurs brute d'actionneur.
    Par exemple, des Volts pour un amplificateur DAC. La valeur de l'échelle peut
    être obtenue en analysant l'unité c'est-à-dire en déterminant le rapport
    [sortie unités SI]/[unités actionneur].
    Par exemple, sur une machine avec un amplificateur en mode vitesse, qui fourni
    1 Volt pour une vitesse résultante de 250 mm/s. Noter que les unités de
    l'offset sont en unités machine, ici des mm/s et qu'elles sont pré-soustraites
    des lectures capteur. La valeur de cet offset est obtenue en trouvant la
    valeur de sortie qui donne 0,0 sur la sortie de l'actionneur. Si le DAC est
    linéarisé, cet offset est normalement de 0,0.
    L'échelle et l'offset peuvent être utilisés pour linéariser le DAC, il en
    résultera des valeurs qui reflèteront les effets combinés du gain de
    l'amplificateur, de la non-linéarité du DAC, des unités du DAC, etc.
    Pour le faire, suivre cette procédure:

.Construire une table de calibration pour la sortie.
Piloter le DAC avec la tension souhaitée et mesurer le résultat:

Mesure des tensions de sortie:

[width="50%"]
|========================================
|*Sortie brute* | *Mesure*
|-10            | *-9.93*
| -9            | *-8.83*
|  0            | *-0.96*
|  1            | *-0.03*
|  9            | *9.87*
| 10            | *10.07*
|========================================

* Par la méthode des moindres carrés, déterminer les coefficients *+a+*, *+b+* tels que
   *+Mesure=a*Sortiebrute+b+*
* Noter que nous voulons une sortie effective telle que la valeur mesurée soit
    identique à la consigne. Cela signifie
** *+cmd=a*Sortiebrute+b+*
** *+Sortiebrute=(cmd-b)/a+*
* Par conséquent, les coefficients *+a+* et *+b+* de l'ajustement linéaire peuvent être
    utilisés directement comme échelle et offset pour le contrôleur.

Valeur maximale de sortie::
     La valeur maximale pour la sortie de compensation PID qui est écrite sur
    l'ampli moteur, exprimée en volts. La valeur de sortie calculée est alignée
    sur cette limite. La limite est appliquée avant la mise à l'échelle des unités
    de sortie effective. La valeur est appliquée de manière symétrique aux deux
    limites, positive et négative.

Test de réglage::
     Le test de réglage ne fonctionne, malheureusement, qu'avec les systèmes à
base moteur pas à pas. Encore une fois vérifier que les directions de déplacements
sur l'axe sont correctes. Puis tester le système en déplaçant l'axe d’avant en arrière,
si l'accélération ou la vitesse maximum sont trop élevées, des pas seront perdus.
Attention: Au cours de ce déplacement manuel garder à l'esprit que la distance
d’arrêt est inversement proportionnelle à l’accélération et qu'avec une accélération
faible il faut du temps et de la distance pour arrêter l’axe. Les fins de course
ne sont pas fonctionnels pendant ce test. Un temps de pause peut être défini
entre chaque mouvement d'essai. Cela permet de vérifier la position de l’axe et
de voir si des pas sont perdus.

Timing des moteur pas à pas::
     La séquence de signaux des sorties pas a pas, doit être adaptée aux exigences
du pilote des moteurs. Pncconf propose par défaut, certaines de ces séquences et il
est possible de les personnaliser.
Voir http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Stepper_Drive_Timing pour y
trouver des séquences pour le matériel le plus commun (n'hésitez pas à ajouter
celles que vous avez expérimenté). En cas de doute utiliser une valeur élevée
comme 5000, cela ne fera que limiter la vitesse maximale.

Contrôle de moteur Brushless::
     Ces options sont utilisées pour permettre le contrôle bas niveau des
moteurs _brushless_ avec un micro logiciel spécial et des cartes filles.
Elles permettent également la conversion des capteurs à effet Hall d'un fabricant
à l'autre. Ce n'est que partiellement pris en charge et aura besoin d’une
intervention pour terminer les connexions de HAL. Contacter la mail-liste ou un
forum pour avoir de l'aide.

.Calcul de l'échelle d'axe

image::images/pncconf-scale-calc_fr.png[alt="Calcul de l'échelle d'axe"]
Les paramètres d'échelle peuvent être saisis directement ou, on peut utiliser le
bouton _calculer échelle_ pour être assisté. Utiliser alors les cases à cocher
pour sélectionner les calculs appropriés. Noter que _Dents des poulies_ exige
le nombre de dents et non le rapport de réduction. _Rapport de réduction_,
le rapport de réduction est exactement le contraire, il exige le rapport
entre poulie menante et poulie menée (Entrée/Sortie). Si l'échelle à déjà été
calculée manuellement, il est possible de la saisir directement sans passer par
l'assistant.

.Configuration des axes

image::images/pncconf-axis-config_fr.png[alt="Configuration des axes"]

Se référer également à l'onglet diagramme pour deux exemples de disposition des
contacts de fin de course d'origine machine et de limites. Ce sont deux exemples
parmi les nombreuses façons différentes de placer ces contacts.

IMPORTANT: Il est très important de commencer avec l'axe se déplaçant dans la
bonne direction sinon l’acquisition du point d'origine est impossible !

Se souvenir que les directions positives et négatives se référent toujours à
l'outil et jamais à la table.

Sur une fraiseuse classique::
- Lorsque la table se déplace vers l'opérateur, c'est la direction positive de l'axe Y.
- Lorsque la table se déplace à gauche, c'est la direction positive de l'axe X.
- Lorsque la table se déplace vers le bas, c'est la direction positive de l'axe Z.
- Lorsque la tête se déplace vers le haut, c'est aussi la direction positive de l'axe Z.

Sur un tour classique::
- Lorsque l'outil se déplace à droite, en s'éloignant du mandrin,  c'est le sens
    positif de l'axe Z.
- Lorsque l'outil se déplace vers l'opérateur, c’est le sens positif de l'axe X.
- Certains tours ont un axe X opposé, dans ce cas l'outil est à l'arrière, cela
   fonctionne bien, mais l'affichage graphique d'AXIS ne peut pas refléter cette
   configuration.

Lorsque des contacts d'origine machine et des contacts de fin de course sont utilisés,
LinuxCNC attend des signaux de HAL au niveaux haut lorsque le contact est actionné.
Si le signal d'un fin de course est inversé, LinuxCNC détectera en permanence que
la machine est en bout de course. Si la logique de recherche du contact d'origine
machine est mauvaise (fichier ini), LinuxCNC lancera la séquence de recherche d'origine
machine de l'axe dans la mauvaise direction.

Décider de l'emplacement des fins de courses::
     Les fins de course de limite d'axe sont au delà des limites logicielles, ils
    protègent la machine en cas de problème électrique, par exemple, l'emballement
    d'un servomoteur.
    Les fins de course doivent être placés de manière à ce que l'axe ne puisse pas
    percuter une butée mécanique. Attention: si la distance d'activation du contact
    de fin de course est trop faible, avec l'inertie du mobile il pourra le dépasser.
    Les fins de course des limites d'axes, doivent être actifs à l'état bas et
    ils doivent aussi couper la puissance sur l'axe concerné. Le contact doit
    s'ouvrir à l'activation du fin de course. Utiliser un autre câblage est
    possible mais il est moins sécurisé.
    Il peut être nécessaire d'inverser le signal de HAL dans LinuxCNC pour avoir un
    état actif haut, TRUE signifie que le contact a été activé. Lorsqu'au
    démarrage de LinuxCNC un avertissement de limite et affiché même si l'axe n'est
    pas sur un des fins de course, le signal est probablement inversé. Utiliser
    HALMETER pour vérifier l'état du signal de HAL correspondant, par exemple,
    axis.0.pos-lim-sw-in, fin de course positif de l'axe X.

Décider de l'emplacement des contacts d'origine machine::
    Si des fins de course de limite d'axe sont utilisés, il est possible de les
    utiliser également comme contacts d'origine machine.
    Un contact d'origine machine séparé est utile si les axes sont longs et que
    le déplacement vers un fin de course dure trop longtemps pour un usage normale
    ou que le déplacement vers une extrémité présente des problèmes d'interférences
    avec le porte-pièce ou la pièce.
    Par exemple sur un tour, le déplacement en bout de banc n'est pas efficace
    pour un point d'origine machine et un contact placé vers le centre est
    certainement meilleur.
    Si codeur avec un index est utilisé, le contact agit comme point de référence
    et l'index suivant sera le point d'origine machine effectif.
  
Décider de la position de l'origine machine::
     L'origine machine dans LinuxCNC sert de référence à tous les systèmes de coordonnées
    utilisateur. Il n'y a pas d'emplacement particulier pour ce point. Seuls
    quelques G-codes accèdent au système de coordonnées machine (G53, G30 et G28).
    Si l'option de changement d'outil sur G30 est utilisée, placer l'origine machine
    à cet endroit peut être commode. Par convention, il est plus simple d'avoir
    l'origine machine sur le contact d'origine.

Décider de la position finale de l'origine::
     Ça consiste simplement à placer le chariot ou la broche à la position
    la plus commode après que LinuxCNC soit initialisé et que les points d'origines
    machine de chacun des axes lui soit connus.

Définition des côtés positifs/négatifs et des longueurs de courses maximales::
    Placer l'axe à l'origine. Faire un repère sur le mobile et un autre sur la
    partie fixe. Déplacer la machine jusqu'au contact de limite d'axe. Mesurer
    la distance entre les deux repères pour obtenir la longueur de déplacement
    maximale dans ce sens. Déplacer dans l'autre sens, sur le contact de limite
    de l'autre côté. Mesurer de nouveau les repères pour obtenir la longueur de
    déplacement maximale dans l'autre sens. Si l'origine machine est située sur
    une des limites d'axe, alors cette distance de déplacement sera évidemment
    de zéro.

Point d'origine machine::
    Ce point est le point de référence de la machine. (Ne pas confondre avec le
    point zéro de l'outil ou de la pièce). LinuxCNC référence tout à partir de ce point.
    Il doit être à l'intérieur des limites logicielles sinon la machine ne pourrait
    jamais l'atteindre. LinuxCNC utilise la position du contact d'origine machine
    pour calculer la position d'origine. Si la machine ne dispose pas de contact
    il faudra la positionner manuellement sur les points d'origine, cocher les axes
    l'un après l'autre et pour chacun, presser le bouton _POM des axes_.
    Dans Axis, le symbole indiquant que l'origine machine de l'axe est connue
    s'affichera alors à droite de la visu de l'axe concerné.

Course de la table::
     C'est la distance maximale que l'axe peut parcourir dans chaque direction.
    Ceci peut ou ne peut pas être mesuré directement de l'origine aux contacts
    de fin de course. Le cumul des courses positives et négatives sera égal à la
    longueur de course totale.

Course positive::
     C'est la distance depuis l'origine de l'axe, jusqu'au fin de course de limite
    du côté positif. Si l'origine de l'axe est placée sur le fin de course de
    limite positive, cette valeur est égale à zéro. Les valeurs possibles sont
    positives ou égales à zéro.

Course négative::
     C'est la distance depuis l'origine de l'axe, jusqu'au fin de course de limite
    du coté négatif. Ou la course totale moins la course positive. Si l'origine de l'axe
    est placée sur le fin de course de limite négative, cette valeur est de zéro.
    Les valeurs possibles sont négatives égales à zéro.
    Si la valeur entrée dans PNCconf n'est pas négative, elle sera déduite des
    autres valeurs.

Position de l'origine::
     C'est la position ou se termine la séquence de prise d'origine machine.
    Elle est référencée par rapport à l'origine et peut être positive, si cette
    position finale est du coté positif ou négative, si cette position finale est
    du coté négatif.

Position du contact d'origine machine::
     C'est la distance depuis le contact d'origine jusqu'à la position de l'origine.
    Il peut être négatif ou positif selon de quel côté de l'origine il est placé.
    Depuis ce point, si l'axe doit être déplacé dans la direction positive pour
    arriver à l'origine, alors la valeur sera négative, sinon elle sera positive.
    Si il est mis à zéro, l'origine sera à l'emplacement du contact (plus la distance
    éventuelle pour attendre l'index suivant, si une règle de mesure, ou un codeur
    de position avec index sont utilisés).

Vitesse de recherche du contact d'origine machine::
    Vitesse utilisée pendant le déplacement vers le contact d'origine machine en
    unités par minute.

Direction de recherche du contact d'origine machine::
    Direction de la recherche de l'origine machine. Négatif ou Positif selon le
    coté de l'axe où se trouve le contact d'origine machine. 

Vitesse d'acquisition du contact d'origine machine::
    Vitesse lente de détection du contact d'origine machine, en unités par minute.

Vitesse vers la position de l'origine::
     Vitesse utilisée pour déplacer le mobile de la position d'acquisition du contact
    d'origine machine, vers la position finale de l'origine, en unités par minute.
    Si réglée à 0 c'est la vitesse de déplacement rapide qui sera utilisée.

Direction d'acquisition du contact d'origine machine::
     Direction d'acquisition de l'origine machine, peut être dans la même direction
    que la recherche, ou à l'opposé.

Origine machine sur l'index du codeur::
     LinuxCNC attendra l'impulsion d'index du codeur après l’acquisition du contact
    d'origine machine.

Utiliser un fichier de compensation de jeu::
    Permet de spécifier le nom et le type d'un fichier de compensation de jeu.
    Permet une compensation sophistiquée. Voir le manuel.

Utiliser la compensation de jeu::
     Permet de régler la compensation du jeu de la vis, ne peut pas être utilisé
    en même temps qu'un fichier de compensation. Voir le manuel.

.Dessin d'aide à l'identification des axes et fins de course

image::images/pncconf-diagram-lathe_fr.png[alt="Dessin d'aide à l'identification des axes et fins de course"]

Ce dessin devrait aider à comprendre un exemple de positionnement des contacts
de fin de course et les directions standards sur un tour.
Sur ce tour, l'axe Z a deux contacts de fin de course, le contact positif est
utilisé également comme contact de prise d'origine machine. La position du zéro
machine (origine machine de l'axe) est placée à la limite négative.
Le bord gauche du chariot est la came qui active le fin de course de la limite
négative et le côté droit, la came qui active le fin de course de la limite positive.
Nous voyons que la position finale de l'origine se trouve à 4 pouces de distance
de l'origine de l'axe, du côté positif.
Si le chariot était déplacé jusqu'à la limite positive, nous mesurerions 10 pouces
entre la limite négative et la came du côté négatif du chariot (fin de course
bord gauche du chariot).

Configuration de la broche

Si un signal de contrôle de la broche est présent, cette page permet de le configurer.

TIP: Beaucoup d'options de cette page ne sont visibles que si les sélections
appropriées ont été choisies dans les pages précédentes. Si des signaux de broche
ont été sélectionnés, alors cette page est disponible pour les configurer.

.Configuration de la broche

image::images/pncconf-spindle-config_fr.png[alt="Configuration de la broche"]

Cette page est semblable à la page de configuration des moteurs d'axe mais il y a
quelques différences: À moins que l'on ait choisi un moteur pas à pas pour la
conduite de la broche il n'y a pas d'accélération ni de limitation de vitesse.
Il n'y a pas de support pour les changements de vitesse ni pour les gammes de vitesses.
Si une option VCP d'affichage de vitesse broche est choisie, alors la
_Vitesse broche atteinte_, _l'échelle_, _la vitesse_ et _les réglages des
filtres_ seront visibles. L’information sur la vitesse de broche permet à LinuxCNC
d'attendre que celle-ci ait atteint la vitesse de consigne, avant de déplacer les axes.
C'est particulièrement pratique sur les tours, lors de l'utilisation d'une vitesse
de coupe constante avec de grands changements de diamètre. Il exige un retour
d'information par codeur ou par un signal de vitesse broche numérique, typiquement
connecté à un variateur de vitesse (VFD).

En utilisant le retour d'information d'un codeur, il est possible de choisir une
plage de _vitesse broche atteinte_ comme tolérance de vitesse, au delà de laquelle,
la vitesse broche sera admise comme étant la vitesse de consigne.

En utilisant le retour d'information d'un codeur, l'affichage de vitesse VCP peut
être irrégulier, des filtres peuvent dans ce cas, être utilisés pour corriger
l'affichage. L'échelle du codeur doit être réglée à la valeur
_comptage codeur/rapport de réduction utilisé_.
Si une seule entrée est utilisée pour le codeur de broche, la ligne suivante doit
être ajoutée:

----
setp hm2_7i43.0.encoder.00.counter-mode 1
----

(Changer le nom de la carte et le numéro de codeur selon besoins) dans le
fichier HAL personnalisé. Lire la section codeurs dans Hostmot2 pour plus
d'information sur les modes de comptage.

== Options avancées

Cette page permet de régler les commandes HALUI, de charger classicladder. Elle
propose des exemples de programmes en Ladder.
Si l'option GladeVCP a été choisie, comme pour la mise à zéro de l'axe sur
l'origine pièce.  Les commandes nécessaires s'afficheront.
Voir le manuel de HALUI pour utiliser des commandes personnalisées halcmds.
Parmi les exemples de programmes ladder: Le programme Estop permet de gérer un
contact externe d'arrêt d'urgence ou permet à l'interface graphique de déclencher
l'arrêt d'urgence. La commande périodique de la pompe du graissage centralisé est
disponible. +
Le contact de mise au zéro pièce de l'axe Z (longueur d'outil) s'utilise avec
une plaque de référence, le contact (touch-off) de GladeVCP et les commandes
spéciales HALUI sont là pour permettre rapidement, une recherche de l'origine pièce.

Le programme série _modbus_ est un squelette de programme, vierge, préréglé pour
l'utilisation de classicladder avec le protocole série modbus. Voir la section
classicladder dans le manuel.


.Options avancées

image::images/pncconf-advanced_fr.png[alt="Options avancées"]

== Composants de HAL

Cette page permet d'ajouter des composants de HAL supplémentaires qui seront utilisés
dans les fichiers HAL personnalisés. De cette manière il n'est pas nécessaire
d'éditer le fichier HAL principal en permettant malgré tout à l'utilisateur de
définir ses propres composants.

.Composants de HAL

image::images/pncconf-hal_fr.png[alt="Composants de HAL"]

La première sélection est prévue pour les composants que pncconf utilise en interne.
Il est possible de configurer pncconf pour qu'il charge les instances additionnelles
pour votre fichier HAL personnalisé.
Sélectionner le nombres d'instances dont a besoin le fichier de personnalisation
et pncconf ajoutera ce qui est nécessaire.
Si 2 composants sont nécessaires et que pncconf à besoin d'un composant interne,
il chargera 3 composants et utilisera le dernier.

Composants de commande personnalisés::
     Cette sélection permettra de charger des composants de HAL que pncconf
    n'utilise pas.
    Ajoute les commandes loadrt ou loadusr dans l'entête _loading command_.
    Ajoute la commande addf dans l'entête _Thread command_.
    Les composants seront ajoutés au thread entre la lecture des entrées et
    l'écriture des sorties, dans l'ordre ou ils sont écrits dans thread command.

== Utilisation avancée de PNCConf

PNCconf fait de son mieux pour permettre un personnalisation souple à l'utilisateur,
PNCconf supporte les noms de signaux particuliers, le chargement de composants
personnalisés comme la personnalisation des fichiers de HAL et des microprogrammes.
Il y a aussi les noms de signaux que PNCconf fournit, indépendamment des options
choisies, pour les fichiers HAL personnalisés.

Avec une conception réfléchie, la plupart des personnalisations devraient fonctionner,
même si des options doivent être modifiées par la suite dans PNCCONF.
Finalement, si les personnalisations vont au-delà du périmètre de travail de PNCCONF,
il sera possible d'utiliser PNCCONF pour construire une configuration de base,
ou d'utiliser une des configurations fournies en standards par LinuxCNC et de l'éditer
pour obtenir ce que est souhaité.

Nom de signaux personnalisés::

Si un composant doit être connecté à quelque chose dans un fichier HAL personnalisé,
écrire un nom de signal unique dans la boîte de dialogue. Certains composants
ajouteront des suffixes au nom du signal personnalisé.

    Les codeurs ajoutent  < Nom personnalisé >:
    -position
    -count
    -velocity
    -index-enable
    -reset

    Les contrôles de moteurs pas à pas ajoutent:
    -enable
    -counts
    -position-cmd
    -position-fb
    -velocity-fb
    
    Les PWM ajoutent:
    -enable
    -value

    Les broches GPIO auront juste le nom du signal d'entrée qui leur est connecté.

De cette façon on peut établir des connexions à ces signaux dans les fichiers 
personnalisés de HAL et avoir toujours la possibilité de les déplacer plus tard.

Charger un microprogramme personnalisé::

PNCconf cherche le microprogramme sur le système et cherche ensuite le fichier XML
qu'il peut convertir et qu'il comprend. Ces fichiers XML sont seulement fournis
pour les microprogrammes officiellement délivrés par l'équipe LinuxCNC. Pour utiliser
un microprogramme personnalisé, il faut le convertir en tableau que PNCconf comprend
et ajouter son chemin dans le fichier de préférences de PNCCONF. Par défaut
le chemin recherché est sur le bureau, dans un dossier nommé _custom_firmware_
contenant un fichier nommé firmware.py.

Le fichier caché des préférence est dans le dossier home de l'utilisateur et se
nomme .pncconf-preferences, pour l'éditer il faut sélectionner _Afficher les
fichiers cachés_. On peut voir le contenu de ce fichier au premier démarrage de
PNCCONF. Presser le bouton d'aide et regarder la page de sortie.
Demander sur la liste de diffusion LinuxCNC ou sur le forum pour des renseignements
pour convertir un microprogramme personnalisé.
Tous les microprogrammes ne peuvent pas être utilisés avec PNCCONF.

Fichiers HAL Personnalisés::
    Il y a quatre fichiers personnalisés utilisables pour ajouter des commandes a HAL:
- custom.hal est prévu pour les commandes HAL utilisées avant le chargement de
    l'interface graphique. Il est exécuté après le fichier HAL de configuration
    nommé : non-de-la-configuration.hal
- custom_postgui.hal est prévu pour les commandes qui doivent être exécutées après
    le chargement de l'interface graphique Axis ou PYVCP autonomes.
// PYVCP a trouver
- custom_gvcp.hal est prévu pour les commandes qui doivent être exécutées après
    le chargement de GLADE VCP.
- shutdown.hal est prévu pour des commandes exécutées quand LinuxCNC se ferme de façon
    contrôlée.

// vim: set syntax=asciidoc:

