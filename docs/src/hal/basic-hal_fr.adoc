:lang: fr
:toc:
:toclevels: 3

[[sec:basiques-hal]]
= Basiques de HAL

This document provides a reference to the basics of HAL.

[[sec:commandes-hal]]
== Commandes de Hal

Des informations plus détaillées peuvent être trouvées dans la man
page en tapant 'man halcmd' dans une console.

Pour voir la configuration de HAL ainsi que le statut de ses pins et paramètres
utiliser la fenêtre HAL Configuration dans le menu 'Machine' d'AXIS.
Pour visualiser le statut des pins, ouvrir l'onglet 'Watch' puis
cliquer dans l'arborescence sur les pins qui doivent être visualisées dans la fenêtre watch.

.HAL Configuration Window
image::images/HAL_Configuration.png["Fenêtre de configuration de HAL",align="center"]

[[sub:hal-loart]]
=== loadrt(((HAL loadrt,loadrt)))

La commande 'loadrt' charge un composant temps réel de HAL. Les
composants temps réel doivent être ajoutés au thread temps réel pour
être fonctionnels. Il n'est pas possible de charger un composant de
l'espace utilisateur dans l'espace temps réel.

.loadrt Syntax and Example
----
loadrt <component> <options>

loadrt mux4 count=1
----

[[sub:hal-addf]]
=== addf(((HAL addf,addf)))

La commande 'addf' ajoute une fonction à un thread temps réel. Si
l'assistant StepConf a été utilisé pour créer la configuration, deux
threads ont été créés.

FIXME Adds function 'functname' to thread 'threadname'. Default is to add the function
in the order they are in the file. If 'position' is specified, adds the function
to that spot in the thread. Negative 'position' means position with respect to
the end of the thread. For example '1' is start of thread, '-1' is the end of
the thread, '-3' is third from the end.

FIXME Some functions it is important to load them in a certain order like the parport
read and write functions. The function name is usually the the component name
plus a number. In the following example the component 'or2' is loaded and 'show
function' shows the name of the or2 function

----
$ halrun
halcmd: loadrt or2
halcmd: show function
Exported Functions:
Owner   CodeAddr  Arg       FP   Users  Name
 00004  f8bc5000  f8f950c8  NO       0   or2.0
----

FIXME You have to add a function from a HAL real time component to a thread
to get the function to update at the rate of the thread.

FIXME Usually there are two threads as shown in this example. Some components use
floating point math and must be added to a thread that supports floating point
math. The 'FP' indicates if floating point math is supported in that thread.

----
$ halrun
halcmd: loadrt motmod base_period_nsec=55555 servo_period_nsec=1000000 num_joints=3
halcmd: show thread
Realtime Threads:
     Period  FP     Name               (     Time, Max-Time )
     995976  YES          servo-thread (        0,        0 )
      55332  NO            base-thread (        0,        0 )
----

- base-thread (le thread haute vitesse) ce thread prends en main les
  items nécessitant une réponse très rapide comme la génération
  d'impulsions, la lecture et l'écriture sur le port parallèle.
- servo-thread (le thread basse vitesse) ce thread prends en main les
  items n'étant pas influencés par la vitesse comme le contrôleur de
  mouvement, l'API Classic Ladder et les commandes manuelles.

.addf Syntaxe et Exemple
----
addf <function> <thread>

addf mux4.0 servo-thread
----

[NOTE]
If the component requires a floating point thread that is usually the slower
servo-thread.

[[sec:loadusr]]
=== loadusr(((HAL loadusr,loadusr)))

La commande 'loadusr' charge un composant de HAL de l'espace utilisateur. Les programmes de l'espace utilisateur ont leur propre
processus séparé qui optionnellement communique avec les autres composants
de HAL via leurs pins et paramètres. Il n'est pas possible de charger
un composant temps réel dans l'espace utilisateur.

Les drapeaux peuvent être un ou plusieurs parmi les suivants:

[horizontal]
-W:: pour attendre que le composant soit prêt. Le composant est supposé
     avoir le même nom que le premier argument de la commande.

-Wn <nom>:: pour attendre un composant, qui porte le nom donné sous la forme <nom>.
            FIXME This only applies if the component has a name option.

-w:: pour attendre la fin du programme

-i:: pour ignorer la valeur retournée par le programme (avec -w)

-n:: name a component when it is a valid option for that component.

.loadusr Syntax and Examples
----
loadusr <component> <options>

loadusr halui

loadusr -Wn spindle gs2_vfd -n spindle
----

En anglais ça donne 'loadusr wait for name spindle component gs2_vfd name spindle'. Le -n spindle est une partie du composant gs2_vfd et non de la commande loadusr.

[[sub:net]]
=== net(((net)))

La commande 'net' crée une 'connexion' entre un signal et une ou plusieurs pins.
Si le signal n'existe pas, net le crée.
Les flèches de direction '<=', '=>' et '<=>'
sont seulement là pour aider à la lecture de la logique, ils ne sont pas
utilisés par la commande net. Un espace doit séparer les flèches de direction 
des noms de pin.

.net Syntax and Example
----
net signal-name pin-name <optional arrow> <optional second pin-name>

net home-x joint.0.home-sw-in <= parport.0.pin-11-in
----

Dans l'exemple ci-dessus, 'home-x' est le nom du signal, 'axis.0.home-sw-in' est
une pin de direction IN, '<=' est une flèche de direction optionnelle et
'parport.0.pin-11-in' est une pin de direction OUT. Cela peut paraître déroutant
mais les labels in et out, pour une broche de port parallèle, indiquent la
direction physique dans laquelle travaille la broche et non comment elle est traitée dans HAL.

Une pin peut être connectée à un signal si elle obéit aux règles suivantes:

* Une pin IN peut toujours être connectée à un signal.
* Une pin IO peut être connectée à moins qu'une pin OUT soit présente sur le signal.
* Une pin OUT peut être connectée seulement si il n'y a pas d'autre pin OUT ou IO
  sur le signal.

Le même 'signal-name' peut être utilisé dans de multiples commandes net pour
connecter des pins additionnelles, tant que les règles précédentes sont observées.

[[cap:signal-direction]]
.Direction du signal
image::images/signal-direction.png["Direction du signal"align="center"]

Voici un exemple qui montre le signal xStep avec la source 
qui est stepgen.0.out
et avec deux lecteurs, parport.0.pin-02-out et parport.0.pin-08-out. Simplement
la valeur de stepgen.0.out est envoyée au signal xStep et cette valeur est alors
envoyée sur parport.0.pin-02-out et parport.0.pin-08-out.

----
#   signal    source            destination          destination
net xStep stepgen.0.out => parport.0.pin-02-out parport.0.pin-08-out
----

Puisque le signal xStep contient la valeur de stepgen.0.out (la source) il est
possible de ré-utiliser le même signal pour envoyer la valeur à d'autres lecteurs,
utiliser simplement le signal avec les autres lecteurs sur de nouvelles
lignes:

----
#   signal       destination2
net xStep => parport.0.pin-06-out
----

.Pins I/O
Les pins appelées I/O pins comme 'index-enable', ne suivent pas cette règle.

[[sub:setp]]
=== setp(((setp)))

La commande 'setp' ajuste la valeur d'une pin ou d'un paramètre. Les
valeurs valides dépendront du type de la pin ou du paramètre.
C'est une erreur si les types de donnée ne correspondent pas.

Certains composants ont des paramètres qui doivent être positionnés avant
utilisation. Il n'est pas possible d'utiliser 'setp' sur une pin connectée à
un signal.

.setp Syntax and Example
----
setp <pin/parameter-name> <value>

setp parport.0.pin-08-out TRUE
----

[[sub:sets]]
=== sets(((sets)))

La commande 'sets' positionne la valeur d'un signal.

.sets Syntax and Example:
----
sets <signal-name> <value>

net mysignal and2.0.in0 pyvcp.my-led

sets mysignal 1
----

C'est une erreur si:

* Le nom de signal n'existe pas
* Le signal à déjà été écrit
* La valeur n'est pas du type correct pour le signal

[[sub:hal-inlinkp]]
=== unlinkp(((HAL unlinkp,unlinkp)))

La commande 'unlinkp' déconnecte la pin du signal auquel elle est connectée.
Si aucun signal n'a été connecté à la pin avant de lancer cette commande,
rien ne se passe.

.unlinkp syntax and Example
----
unlinkp <pin-name>

unlinkp parport.0.pin-02-out
----

=== Commandes obsolètes

Les commandes suivantes sont dépréciées et seront retirées dans les futures
versions. Toute nouvelle configuration doit utiliser la commande <<sub:net,'net'>>.
FIXME These commands are included so older configurations will still work.

.linksp

La commande 'linksp' créait une 'connexion' entre un signal et une
pin.

.linksp Syntax and Example
----
linksp <signal-name> <pin-name>

linksp X-step parport.0.pin-02-out
----

La commande 'linksp' a été remplacée par la commande 'net'.

.linkps

La commande 'linksp' créait une 'connexion' entre une pin et un signal. C'est la
même chose que linksp mais les arguments sont inversés.

.linkps Syntax and Example
----
linkps <pin-name> <signal-name>

linkps parport.0.pin-02-out X-Step
----

La commande 'linkps' a été remplacée par la commande 'net'.

.newsig

the command 'newsig' creates a new HAL signal by the name <signame>
and the data type of <type>. Type must be 'bit', 's32', 'u32' or
'float'. Error if <signame> already exists.

.newsig Syntax and Example
----
newsig <signame> <type>

newsig Xstep bit
----

D'autres informations peuvent être trouvées dans le manuel de HAL ou
la man page de 'halrun'.

[[sec:HAL-Data]]
== HAL Data(((HAL Data)))

[[sub:hal-bit]]
=== Bit(((Bit)))

A bit value is an on or off.

- bit values = true or 1 and false or 0 (True, TRUE, true are all valid)

[[sub:hal-float]]
=== Float(((Float)))

A 'float' is a floating point number. In other words the decimal point
can move as needed.

- float values = a 64 bit floating point value, with approximately 53 bits of
  resolution and over 1000 bits of dynamic range.

For more information on floating point numbers see:

http://fr.wikipedia.org/wiki/Nombre_flottant[http://fr.wikipedia.org/wiki/Nombre_flottant]

[[sub:hal-s32]]
=== s32 (((s32)))

An 's32' number is a whole number that can have a negative or positive
value.

- s32 values = integer numbers -2147483648 to 2147483647

[[sub:hal-u32]]
=== u32 (((u32)))

A 'u32' number is a whole number that is positive only.

- u32 values = integer numbers 0 to 4294967295

[[sec:hal-files]]
== Fichiers Hal(((HAL Files)))

Si l'assistant StepConf a été utilisé pour générer la configuration
trois fichiers HAL ont dû être créés dans le répertoire de la configuration.

- ma-fraiseuse.hal (si ne nom de la config est "ma-fraiseuse") Ce
  fichier est chargé en premier, il ne doit pas être modifié sous peine de ne plus pouvoir l'utiliser avec l'assistant StepConf.
- custom.hal Ce fichier est le deuxième à être chargé et il l'est avant
  l'interface utilisateur graphique (GUI). C'est dans ce fichier que ce
  trouvent les commandes personnalisées de l'utilisateur devant être chargées avant la GUI.
- custom_postgui.hal Ce fichier est chargé après la GUI. C'est dans ce
  fichier que se trouvent les commandes personnalisées de l'utilisateur
  devant être chargées après la GUI. Toutes les commandes relatives aux
  widgets de pyVCP doivent être placées ici.

[[sec:hal-parameters]]
== Composants de HAL(((HAL Parameters)))

Deux paramètres sont automatiquement ajoutés à chaque composants HAL quand il
est créé. Ces paramètres permettent d'encadrer le temps d'exécution d'un
composant.

[horizontal]
`.time`(((HAL time))):: Time est le nombre de cycles du CPU qu'il a fallu pour exécuter la fonction.
`.tmax`(((HAL tmax))):: Tmax est le nombre maximum de cycles du CPU qu'il a fallu pour exécuter la
  fonction.

'tmax' est un paramètre en lecture/écriture, de sorte que l'utilisateur peut le
mettre à 0 pour se débarrasser du premier temps d'initialisation de la
fonction.

[[sec:hal-logic-components]]
== Composants de logiques combinatoire(((HAL Logic Components)))

Hal contient plusieurs composants logiques temps réel. Les composants
logiques suivent une tables de vérité montrant les états logiques des
sorties en fonction de l'état des entrées. Typiquement, la manipulation
des bits d'entrée détermine l'état électrique des sorties selon la table de vérité des portes.

FIXME For further components see <<sec:realtime-components, Realtime Components List>>
or the man pages.

[[sub:hal-and2]]
=== and2(((HAL and2,and2)))

Le composant 'and2' est une porte 'and' à deux entrées. Sa table de
vérité montre la sortie pour chaque combinaison des entrées.

.and2 Syntax
----
and2 [count=N] | [names=name1[,name2...]]
----

.and2 Functions
----
and2.n
----

.and2 Pins
----
and2.N.in0 (bit, in)
and2.N.in1 (bit, in)
and2.N.out (bit, out)
----

.and2 Truth Table
[width="90%", options="header"]
|======================
|in0   | in1   | out
|False | False | False
|True  | False | False
|False | True  | False
|True  | True  | True
|======================

[[sub:hal-not]]
=== not(((HAL not,not)))

Le composant 'not' est un simple inverseur d'état.

.not Syntax
----
not [count=n] | [names=name1[,name2...]]
----

.not Functions
----
not.all
not.n
----

.not Pins
----
not.n.in (bit, in)
not.n.out (bit, out)
----

.not Truth Table
[width="90%", options="header"]
|=============
|in    | out
|True  | False
|False | True
|=============

[[sub:hal-or2]]
=== or2(((HAL or2,or2)))

Le composant 'or2' est une porte OR à deux entrées.

.or2 Syntax
----
or2[count=n] | [names=name1[,name2...]]
----

.or2 Functions
----
or2.n
----

.or2 Pins
----
or2.n.in0 (bit, in)
or2.n.in1 (bit, in)
or2.n.out (bit, out)
----

.or2 Truth Table
[width="90%", options="header"]
|=====================
|in0   | in1   | out
|True  | False | True
|True  | True  | True
|False | True  | True
|False | False | False
|=====================

[[sub:hal-xor2]]
=== xor2(((HAL xor2,xor2)))

Le composant 'xor2' est une porte XOR à deux entrées (OU exclusif).

.xor2 Syntax
----
xor2[count=n] | [names=name1[,name2...]]
----

.xor2 Functions
----
xor2.n
----

.xor2 Pins
----
xor2.n.in0 (bit, in)
xor2.n.in1 (bit, in)
xor2.n.out (bit, out)
----

.xor2 Truth Table
[width="90%", options="header"]
|=====================
|in0   | in1   | out
|True  | False | True
|True  | True  | False
|False | True  | True
|False | False | False
|=====================

[[sec:hal-logic-examples]]
== Exemples en logique combinatoire(((HAL Logic Examples)))

.`and2` example connecting two inputs to one output
----
loadrt and2 count=1

addf and2.0 servo-thread

net my-sigin1 and2.0.in0 <= parport.0.pin-11-in

net my-sigin2 and2.0.in1 <= parport.0.pin-12-in

net both-on parport.0.pin-14-out <= and2.0.out
----

Dans cet exemple un and2 est chargé dans l'espace temps réel, puis
ajouté à servo thread. Ensuite la broche d'entrée 11 du port parallèle
est connectée à l'entrée in0 de la porte. Puis la broche d'entrée 12 du
port est connectée à l'entrée in1 de la porte. Enfin la sortie
and2.0.out de la porte est connectée à la broche de sortie 14 du port
parallèle. Ainsi en suivant la table de vérité du and2, si les broches 11 et 12 du port sont à 1, alors sa sortie 14 est à 1 aussi.

[[sec:hal-conversion-components]]
== Composants de conversion(((HAL Conversion Components)))

[[sub:hal-weighted-sum]]
=== Somme pondérée (weighted_sum)(((HAL weighted_sum,weighted_sum)))

La somme pondérée converti un groupe de bits en un entier. La conversion est la
somme des 'poids' des bits présents plus n'importe quel offset. C'est similaire
au 'binaire codé décimal' mais avec plus d'options. Le bit 'hold' interrompt le
traitement des entrées, de sorte que la valeur 'sum' ne change plus.

.weighted_sum component loading syntax
----
loadrt weighted_sum wsum_sizes=size[,size,...]
----

Crée des groupes de weighted_sum, chacun avec le nombre donné de bits d'entrée (size).

Pour mettre à jour la weighted_sum, le process_wsums doit être attaché à un thread.

.add `process_wsums` function
----
addf process_wsums servo-thread
----

Ce qui met à jour le composant weighted_sum.

Dans l'exemple suivant, une copie de la fenêtre de configuration de HAL d'Axis,
les bits '0' et '2' sont TRUE, ils n'ont pas d'offset. Le poids ('weight') du bit 0
est 1, celui du bit 2 est 4, la somme est donc 5.

.weighted_sum (somme pondérée)
----
Component Pins:
Owner   Type  Dir         Value  Name
    10  bit   In           TRUE  wsum.0.bit.0.in
    10  s32   I/O             1  wsum.0.bit.0.weight
    10  bit   In          FALSE  wsum.0.bit.1.in
    10  s32   I/O             2  wsum.0.bit.1.weight
    10  bit   In           TRUE  wsum.0.bit.2.in
    10  s32   I/O             4  wsum.0.bit.2.weight
    10  bit   In          FALSE  wsum.0.bit.3.in
    10  s32   I/O             8  wsum.0.bit.3.weight
    10  bit   In          FALSE  wsum.0.hold
    10  s32   I/O             0  wsum.0.offset
    10  s32   Out             5  wsum.0.sum
----
