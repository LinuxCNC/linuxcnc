:lang: en
:toc:

[[cha:halmodule]]
= Creating Non-realtime Python Components(((Creating Non-realtime Python Components)))

This section explains principles behind the implementation of HAL components with the Python programming language.

== Basic usage

A non-realtime component begins by creating its pins and parameters, then enters a loop which will periodically drive all the outputs from the inputs.
The following component copies the value seen on its input pin ('passthrough.in') to its output pin ('passthrough.out') approximately once per second.

[source,c]
----
#!/usr/bin/env python3
import hal, time
h = hal.component("passthrough")
h.newpin("in", hal.HAL_FLOAT, hal.HAL_IN)
h.newpin("out", hal.HAL_FLOAT, hal.HAL_OUT)
h.ready()
try:
    while 1:
        time.sleep(1)
        h['out'] = h['in']
except KeyboardInterrupt:
    raise SystemExit
----

Copy the above listing into a file named "passthrough", make it executable ('chmod +x'), and place it on your '$PATH'.
Then try it out:

.Screen copy with details on the execution of the newly created passthrough HAL module.
----
$ halrun

halcmd: loadusr passthrough

halcmd: show pin

    Component Pins:
    Owner Type  Dir     Value  Name
     03   float IN          0  passthrough.in
     03   float OUT         0  passthrough.out

halcmd: setp passthrough.in 3.14

halcmd: show pin

    Component Pins:
    Owner Type  Dir     Value  Name
     03   float IN       3.14  passthrough.in
     03   float OUT      3.14  passthrough.out
----

== Non-realtime components and delays

If you typed "show pin" quickly, you may see that 'passthrough.out' still had its old value of 0.
This is because of the call to 'time.sleep(1)', which makes the assignment to the output pin occur at most once per second.
Because this is a non-realtime component, the actual delay between assignments can be much longer if the memory used by the passthrough component is swapped to disk,
as the assignment could be delayed until that memory is swapped back in.

Thus, non-realtime components are suitable for user-interactive elements such as control panels (delays in the range of milliseconds are not noticed, and longer delays are acceptable),
but not for sending step pulses to a stepper driver board (delays must always be in the range of microseconds, no matter what).

== Create pins and parameters

----
h = hal.component("passthrough")
----

The component itself is created by a call to the constructor 'hal.component'.
The arguments are the HAL component name and (optionally) the prefix used for pin and parameter names.
If the prefix is not specified, the component name is used.

----
h.newpin("in", hal.HAL_FLOAT, hal.HAL_IN)
----

Then pins are created by calls to methods on the component object.
The arguments are: pin name suffix, pin type, and pin direction.
For parameters, the arguments are: parameter name suffix, parameter type, and parameter direction.

.HAL Option Names
[width="100%",cols="<3s,4*<"]
|===
|Pin and Parameter Types: |HAL_BIT |HAL_FLOAT |HAL_S32 |HAL_U32
|Pin Directions:          |HAL_IN  |HAL_OUT   |HAL_IO  |
|Parameter Directions:    |HAL_RO  |HAL_RW    |        |
|===

The full pin or parameter name is formed by joining the prefix and the
suffix with a ".", so in the example the pin created is called
'passthrough.in'.

----
h.ready()
----

Once all the pins and parameters have been created, call the
'.ready()' method.

=== Changing the prefix

The prefix can be changed by calling the '.setprefix()' method. The
current prefix can be retrieved by calling the '.getprefix()' method.

== Reading and writing pins and parameters

For pins and parameters which are also proper Python identifiers, the
value may be accessed or set using the attribute syntax:

----
h.out = h.in
----

For all pins, whether or not they are also proper Python identifiers,
the value may be accessed or set using the subscript syntax:

----
h['out'] = h['in']
----

To see all pins with their values, getpins returns all values in a dictionary
of that component.

----
h.getpins()
>>>{'in': 0.0, 'out': 0.0}
----

=== Driving output (HAL_OUT) pins

Periodically, usually in response to a timer, all HAL_OUT pins should
be "driven" by assigning them a new value. This should be done whether
or not the value is different than the last one assigned. When a pin is
connected to a signal, its old output value is not copied into the
signal, so the proper value will only appear on the signal once the
component assigns a new value.

=== Driving bidirectional (HAL_IO) pins

The above rule does not apply to bidirectional pins. Instead, a
bidirectional pin should only be driven by the component when the
component wishes to change the value. For instance, in the canonical
encoder interface, the encoder component only sets the 'index-enable'
pin to *FALSE* (when an index pulse is seen and the old value is
*TRUE*), but never sets it to *TRUE*. Repeatedly driving the pin
*FALSE*  might cause the other connected component to act as though
another index pulse had been seen.

== Exiting

A 'halcmd unload' request for the component is delivered as a
'KeyboardInterrupt' exception. When an unload request arrives, the
process should either
exit in a short time, or call the '.exit()' method on the component
if substantial work (such as reading or
writing files) must be done to complete the shutdown process.

== Helpful Functions

=== ready
Tells the HAL system the component is initialized. Locks out adding pins.

=== unready
Allows a component to add pins after 'ready()' has been called.
One should call 'ready()' on the component after.

=== component_exists

Does the specified component exist at this time.

.Example
----
hal.component_exists("testpanel")
----

=== component_is_ready

Is the specified component ready at this time.

.Example
----
hal.component_is_ready("testpanel")
----

=== get_msg_level

Get the current Realtime msg level.

=== set_msg_level

Set the current Realtime msg level.
used for debugging information.

=== connect

Connect a pin to a signal.

.Example
----
hal.connect("pinname","signal_name")
----

=== disconnect

Disconnect a pin from a signal.

.Example
----
hal.disconnect("pinname")
----

=== get_value

Read a pin, param, or signal directly.

.Example
----
value = hal.get_value("iocontrol.0.emc-enable-in")
----

=== get_info_pins()

Returns a list of dicts of all system pins.

[source,python]
----
listOfDicts = hal.get_info_pins()
pinName1 = listOfDicts[0].get('NAME')
pinValue1 = listOfDicts[0].get('VALUE')
pinType1 = listOfDicts[0].get('TYPE')
pinDirection1 = listOfDicts[0].get('DIRECTION')
----

=== get_info_signals()

Returns a list of dicts of all system signals.

[source,python]
----
listOfDicts = hal.get_info_signals()
signalName1 = listOfDicts[0].get('NAME')
signalValue1 = listOfDicts[0].get('VALUE')
driverPin1 = listOfDicts[0].get('DRIVER')
----

=== get_info_params()

Returns a list of dicts of all system parameters.

[source,python]
----
listOfDicts = hal.get_info_params()
paramName1 = listOfDicts[0].get('NAME')
paramValue1 = listOfDicts[0].get('VALUE')
paramDirection1 = listOfDicts[0].get('DIRECTION')
----

=== new_sig

Create a new signal of the type specified.

.Example
----
hal.new_sig("signalname",hal.HAL_BIT)
----

=== pin_has_writer

Does the specified pin have a driving pin connected. +
Returns True or False.

----
h.in.pin_has_writer()
----

=== get_name

Get the HAL object name. +
Return a string.

----
h.in.get_name()
----

=== get_type

Get the HAL object's type. +
Returns an integer.

----
h.in.get_type()
----

=== get_dir

Get the HAL object direction type. +
Returns an integer.

----
h.in.get_dir()
----

=== get

Get the HAL object value.

----
h.in.get()
----

=== set

Set the HAL object value.

----
h.out.set(10)
----

=== is_pin

Is the object a pin or parameter? +
Returns True or False.

----
h.in.is_pin()
----

=== sampler_base

TODO

=== stream_base

TODO

=== stream

TODO

=== set_p

Set a pin value of any pin in the HAL system.

.Example
----
hal.set_p("pinname","10")
----

== Constants

Use these to specify details rather then the value they hold.

* HAL_BIT
* HAL_FLOAT
* HAL_S32
* HAL_U32
* HAL_IN
* HAL_OUT
* HAL_RO
* HAL_RW
* MSG_NONE
* MSG_ALL
* MSG_DBG
* MSG_ERR
* MSG_INFO
* MSG_WARN

== System Information

Read these to acquire information about the realtime system.

* is_kernelspace
* is_rt
* is_sim
* is_userspace

== Use with hal_glib in GladeVCP Handler

GladeVCP uses the hal_glib library, which can be used to connect a "watcher" signal on a HAL input pin. +
This signal can be used to register a function to call when the HAL pin changes state. +

One must import the `hal_glib` and the `hal` modules:

[source,python]
----
import hal_glib
import hal
----

Then make a pin and connect a 'value-changed' (the watcher) signal to a function call:

[source,python]
----
class HandlerClass:
    def __init__(self, halcomp,builder,useropts):
        self.example_trigger = hal_glib.GPin(halcomp.newpin('example-trigger', hal.HAL_BIT, hal.HAL_IN))
        self.example_trigger.connect('value-changed', self._on_example_trigger_change)
----

And have a function to be called:

[source,python]
----
    def _on_example_trigger_change(self,pin,userdata=None):
        print("pin value changed to: {}".format(pin.get()))
        print("pin name= {}".format(pin.get_name()))
        print("pin type= {}".format(pin.get_type()))

        # this can be called outside the function
        self.example_trigger.get()
----

== Use with hal_glib in QtVCP Handler

QtVCP uses the hal_glib library, which can be used to connect a "watcher" signal on a HAL input pin.
This signal can be used to register a function to call when the HAL pin changes state.

One must import the `hal` module:

[source,python]
----
import hal
----

Then make a pin and connect a 'value_changed' (the watcher) signal to a function call:

[source,python]
----
    ########################
    # **** INITIALIZE **** #
    ########################
    # widgets allows access to  widgets from the qtvcp files
    # at this point the widgets and HAL pins are not instantiated
    def __init__(self, halcomp,widgets,paths):
        self.hal = halcomp
        self.testPin = self.hal.newpin('test-pin', hal.HAL_BIT, hal.HAL_IN)
        self.testPin.value_changed.connect(lambda s: self.setTestPin(s))
----

And have a function to be called.
This shows ways to get the pin value and information.

[source,python]
----
    #####################
    # general functions #
    #####################
    def setTestPin(self, data):
        print("Test pin value changed to:" % (data))
        print('halpin object =', self.w.sender())
        print('halpin name: ',self.sender().text())
        print('halpin type: ',self.sender().get_type())

        # this can be called outside the function
        print(self.testPin.get())
----

== Project ideas

* Create an external control panel with buttons, switches, and indicators.
  Connect everything to a microcontroller, and connect the microcontroller to the PC using a serial interface.
  Python has a very capable serial interface module called https://pyserial.readthedocs.io/en/latest/[pyserial]
  (Ubuntu package name "python3-serial", in the universe repository).
* Attach a http://lcdproc.omnipotent.net/[LCDProc]-compatible LCD module
  and use it to display a digital readout with information of your choice
  (Ubuntu package name "lcdproc", in the universe repository).
* Create a virtual control panel using any GUI library supported by Python (gtk, Qt, wxWindows, etc.).

// vim: set syntax=asciidoc:
