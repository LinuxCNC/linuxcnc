:lang: fr
:toc:

[[cha:Assistant-graphique-Mesa]]
= Assistant graphique de configuration Mesa PNCconf(((Assistant graphique de configuration Mesa pncconf)))

L'assistant de configuration PNCconf couvre toute la gamme  des cartes d'entrées/
sorties Mesa et des ports parallèles (3). Il est destiné à la configuration de 
systèmes à servomoteurs en boucle fermée ou de systèmes à moteurs pas à pas 
avec pilotage _matériel_ externe. Il utilise une approche d'assistance similaire 
à celle de StepConf qui est lui, utilisé pour configurer les systèmes avec 
pilotage _logiciel_ des moteurs pas à pas, au travers de ports parallèles. 
Pour une machine n'utilisant qu’un ou deux ports parallèles standards, le 
logiciel StepConf pourrait être un choix plus judicieux.

L'assistant PNCconf permet de produire des configurations avancées sans 
connaitre quoi que ce soit de HAL. 

PNCconf en est encore au stade du développement (Alpha) il peut exister 
quelques bogues et manques de fonctionnalités.
Merci de rapporter les bogues et les suggestions à la page du forum ou par 
courriel à la liste de diffusion.

Il y a deux manières d'utiliser PNCconf:

- La première consiste à l'utiliser pour configurer le système et si, par
la suite, certaines options doivent être modifiées, il suffira alors de
recharger PNCconf et d'apportez les modifications aux réglages.
Cela fonctionne bien si la machine est assez standard, pour les machines particulières 
il est possible d'ajouter à la main les nouvelles fonctionnalités. 
PCNConf est bien adapté pour cette utilisation.
 
- La seconde consiste à l'utiliser pour construire une configuration la plus 
proche possible de ce qui est souhaité, puis à la modifier à la main pour 
l'adapter aux besoins. C'est le bon choix si les besoins de modifications vont 
au-delà des possibilités de PNCconf ou pour expérimenter et en apprendre plus sur EMC2.

Il est possible de naviguer dans l'assistant, revenir sur des pages, annuler des 
choix, obtenir de l'aide et des diagrammes puis enfin, de valider la configuration 
par la page de sortie du programme.

****
NDT: Certaines divergences entre cette traduction et l'aspect réel de l'interface
peuvent apparaitre pendant la phase de développement de PNCconf. Elles disparaitront
quand le logiciel sera finalisé.
****

== Instructions pas à pas

Démarrer le programme depuis le menu CNC->PnCConf ou depuis un terminal
avec la commande *+pncconf+*. 

.Écran d'accueil de PnCConf

image::images/pncconf-splash.png[]

== Créer ou éditer une configuration

Il est possible de créer une nouvelle configuration ou d'en modifier une ancienne.
Si *+Modify a configuration+* est choisi, suivi d'un clic sur *+Next+*, une boite de 
sélection apparait. Pncconf présélectionne le dernier fichier enregistré. 
Choisir alors, la configuration à modifier. Vous pouvez aussi cocher les options 
suivantes *+Create a desktop shortcut+* qui créera un raccourci sur le bureau 
pointant sur ce nouveau fichier de configuration, *+Create a desktop launcher+* qui
créera un lanceur sur le bureau pour EMC2 dans cette configuration.
Si ces options ne sont pas utilisées, le nouveau fichier de configuration se trouvera
dans le dossier *+~/emc2/configs+*. Il est toujours  possible de lancez EMC2 
normalement et de sélectionner la configuration souhaitée dans la liste.

== Informations de base sur la machine

.Informations de base sur la machine

image::images/pncconf-basic.png[]


Machine Name::
     Préciser ici le nom de la configuration, les espaces dans les noms seront 
    remplacés par des '_' (en règle générale,  Linux n'aime pas les espaces dans 
    les noms de fichiers). 

Axis configuration:: 
     Cette liste déroulante précise le nombre d'axe de votre machine, 
    sélectionnez selon la machine XYZ (fraiseuse), XYZA (fraiseuse 4-axes) 
    ou XZ (tour).

Machine Units::
     Définit l'unité de mesure utilisée par la machine, impérial ou métrique 
    (Pouce ou mm), toutes les données de mesure introduites par la suite devront 
    être dans l'unité précisée ici.

    Les valeurs par défaut déjà introduites ne sont pas converties 
    dans l'unité choisie, bien vérifier ces valeurs.

Computer Response Time:

Actual servo period::
     C'est l'horloge du système. La latence donne la variation 
    de cette horloge. EMC2 demande une chronologie serrée et cohérente, sinon 
    des problèmes surviendront.
 
EMC2 requiert et utilise un système *temps réel*, ce qui signifie qu'il a une 
latence faible et un temps de réponse très court. Les évènements arrivent avec 
précision dans le temps quand EMC2 nécessite pour ses calculs, de ne pas être 
interrompu par des demandes (interruption) de priorités inférieures comme des 
saisies au clavier ou des demandes d'affichage.

Le test de latence est très important, il est un élément clef et doit être 
effectué au plus tôt. Heureusement les cartes Mesa se chargent des tâches critiques 
en temps de réponse, comme le comptage d'impulsions, la génération de PWM et cela 
leur permet de supporter une latence supérieure à celle d'un système utilisant 
les ports parallèles de la carte mère.

Le test standard dans EMC2, consiste à vérifier la latence de base. Un appui sur 
le bouton *_test base period jitter_* lancera le test de latence, il est également 
possible de le lancer depuis le menu *_application -> cnc -> latency test_*. 
Ce test doit fonctionner plusieurs minutes, en fait, le plus longtemps possible. 
15 minutes est un minimum. Pendant le test, essayer d'utilisez le plus possible 
l'ordinateur, le réseau, le port USB, les disques durs, l'affichage. 
Observer et noter si une action particulière dégrade le temps de latence. 
A la fin, il sera possible de connaitre la *base period jitter* +
Un valeur en dessous de 20000 est excellente et permet une génération rapide des 
impulsions de pas avec cette machine.+
20000 à 50000 est assez bon pour la génération de pas. +
50000 à 100000 ce n'est pas très bon mais la machine peu encore servir pour la 
génération de pas avec une carte ayant des temps de réponse courts. +
Plus grand que 100000, la machine n'est pas utilisable pour cette fonction.

Si la latence est médiocre ou si des problèmes intermittents surviennent 
régulièrement il sera toujours possible de l'améliorer.

TIP: Il y a une liste d'équipements et de leurs temps de latences sur 
http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?Latency-Test[le wiki d'EMC2] +
SVP, pensez à ajouter vos infos à la liste. Sur cette page il y a des liens vers 
des informations pour résoudre certains problèmes de latence.

Maintenant que nous avons un temps de latence acceptable nous devons choisir 
une période d'asservissement (servo period).
Dans la plupart des cas une période d'asservissement de 1000000ns est bonne, 
cela donne un taux (servo rate) de 1 kHz soit 1000 calculs par seconde.
Si vous construisez un système d'asservissement en boucle fermée qui contrôle 
le couple (courant) plutôt que la vitesse (tension) le taux sera meilleur,
quelque chose comme 200 000 (5 kHz). Le problème avec l'abaissement de la période 
c'est qu'elle laisse moins de temps disponible à l'ordinateur pour faire 
d'autres choses. Typiquement la réponse de l'affichage (GUI) est moins bonne. 
Il faut choisir un équilibre. Garder à l'esprit que sur un mécanisme en boucle fermée, 
une modification de la période d'asservissement nécessitera de réajuster l'ensemble 
des paramètres de la boucle.

Carte d'entrées/sorties::
     PNCconf est capable de configurer une machines avec deux cartes Mesa et 
    trois ports parallèles. Les ports parallèles ne sont utilisables que pour 
    des actions simples et peu rapide.

Mesa::
     Au moins une carte Mesa doit être choisie. PNCconf ne peut pas configurer 
    les ports parallèles pour des codeurs, des signaux de pas ou pour la 
    génération de signaux PWM. La liste de sélection des cartes Mesa présentes 
    dans la liste de sélection est construite selon les micros logiciels des 
    cartes trouvées sur le système. Il existe des options permettant d'ajouter 
    des micros logiciels personnalisés ou pour ignorer *blacklister* certaines 
    versions de micros logiciels ou certaines cartes, en utilisant un fichier 
    de préférence.
     Si aucune carte n'est détectée PNCconf affichera un avertissement et 
    utilisera des valeurs par défaut mais aucun test ne sera possible. Il faut 
    noter que, si plusieurs cartes Mesa sont utilisées, il n'existe aucun moyen 
    de déterminer laquelle sera la carte N°0 ou N°1 et il sera indispensable de
    le tester. Déplacer les cartes dans les ports PCI, peut changer leur ordre. 
    Si la configuration est créée pour deux cartes, elles doivent être installées 
    pour que les tests fonctionnent.

Ports parallèles::
     Jusqu'à 3 ports parallèles, appelés *parports* par Mesa, peuvent être utilisés 
    comme de simples entrées sorties. L'adresse du port parallèle doit être définie. 
    Il est possible soit d'entrer le N° du port parallèle selon le système
    de numérotation de Linux 0, 1 ou 2 ou, d'entrer l'adresse réelle en hexadécimal. 
    Les adresses des ports parallèles intégrés à la carte mère sont le plus souvent 
    aux adresses 0x0378 0x0278, elles peuvent être trouvées dans la configuration 
    du BIOS. Le Bios s'ouvre en enfonçant une touche du clavier au tout début du 
    cycle de démarrage de l'ordinateur, souvent (Del ou F2) reportez-vous au 
    document de votre carte mère. Sur une des pages du BIOS, il est possible de 
    choisir l'adresse des ports parallèles et de définir leurs modes de fonctionnement 
    comme SSP, EPP, etc, sur certains ordinateurs cette information est affichée
    pendant quelques secondes lors du démarrage du PC.
    Pour les ports parallèles sur carte PCI les adresses sont trouvées en cliquant 
    sur le bouton *parport address search* qui affichera la liste des périphériques 
    PCI découverts. Dans cette liste, se trouvera une référence aux ports 
    parallèles avec une liste d'adresses. Une de ces adresses doit fonctionner. 
    Noter que tous les ports parallèles PCI ne fonctionnent pas correctement. 
    Chaque port peut être sélectionné comme *in* pour augmenter le
    nombre d'entrées sur ce port ou *out* pour un maximum de sorties. Par défaut,
    les ports parallèles sont configurés en *out*.

Les interfaces graphiques::
    Spécifie les interfaces utilisateur graphiques que EMC2 peut utiliser.
    Chacune a des options particulières. 

*AXIS*::
 Supporte les tours.
 C'est l'interface le plus utilisée.
 Est conçu pour être utilisé avec la souris est un clavier.
 Est basé sur tkinter et intègre donc PYVCP (contrôle visuel python).
 Dispose d'un affichage graphique en 3D
 Est intégrable sur les barres de tâches ou sur le bureau.

*TOUCHY*::
 Touchy est une interface minimale conçue pour les écrans tactiles. 
 Permet l'usage de contacts physiques et d'une manivelle de jog à micro impulsions (MPG)
 Demande les boutons *Départ cycle*, *Abandon*, *Marche par pas*
 Demande aussi un bouton de sélection d'axe sur le jog si est multi-axes.  
 Il est basé sur GTK et intègre GladeVCP (création de panneaux de contrôle).
 Permet d'intégrer un panneau de contrôle virtuel (VCP).
 N'a pas de fenêtre de suivi du parcours d'outil.
 L'aspect peut être modifié avec des thèmes personnalisés.

*MINI*::
 Est en standard sur les machines Sherline.
 N'utilise pas d'arrêt d'urgence (ESTOP).
 Pas d'intégration d'un panneau de contrôle.
            
*TkEMC*::
 Contraste élevé grâce à un fond bleu.
 Fenêtre graphique séparée.
 Pas d'intégration de panneau de contrôle.

== Configuration externe

Cette page permet de sélectionner des contrôles externes pour la commande 
manuelle de déplacement des axes (jogging) ou des curseurs des correcteurs de vitesse.

.GUI externe

image::images/pncconf-external.png[]

Si une manette de jeu externe est sélectionnée pour le jogging, il faudra 
toujours la connecter à EMC2 avant de démarrer celui-ci. Si la manette est 
analogique il faudra probablement ajouter du code personnalisé à HAL. 
Les manivelles de jogging à vernier et micro impulsion (MPG) nécessitent d'être 
connectées à une carte Mesa sur un compteur de codeur. Pour les correcteurs de 
vitesses externe il est possible d'utiliser un mécanisme à générateur d'impulsions 
(MPG) ou à commutation comme un commutateur rotatif. 
Les boutons externes peuvent être ceux d'une manette de jeu.

Joystick USB pour le jogging:: 
     Demande des règlages spécifiques personnalisés pour être installé dans le 
    système. Il s'agi d'un fichier qui est utilisé par EMC2 pour se connecter à 
    liste des périphériques Linux. PNCconf aidera à la construction de ce fichier.
- *Search for device rule* va rechercher les règles dans le système, utilisable
    pour trouver le nom des périphériques déjà construits avec PNCconf.

- *Add a device rule* S'utilise pour configurer un nouveau périphérique 
    en suivant les instructions. Le périphérique doit être branché et disponible.

- *test device* permet de charger un périphérique et d'afficher ses noms de 
    broches et visualiser ses fonctions avec l’outil halmeter.

Les manettes de jeu utilisées en jogging utilisent HALUI et le composant hal_input.

Boutons externes::
     Permet le jogging de l'axe avec de simples boutons à une vitesse spécifiée.
    Probablement mieux adapté pour le jogging en vitesse rapide. 

Manivelle à micro impulsions::
     Permet d'utiliser un générateur d'impulsions (MPG) manuel pour faire du 
    jogging sur les axes de la machine.
    Les manivelles à micro impulsions sont souvent rencontrées sur les machines 
    de bonne qualité. Elles délivrent en sortie des impulsions en quadrature qui 
    peuvent être comptées avec un compteur de codeur MESA. PNCconf gère une 
    manivelle par axe ou une manivelle partagée entre les axes. 
    Il permet la sélection des vitesses de jogging en utilisant des commutateurs
    rotatifs. L'option  de sélection des incréments de jog utilise le 
    composant mux16. Ce composant dispose d'options telles que l'anti-rebond et 
    l'utilisation du code Gray pour filtrer l'entrée physique du commutateur.

Correcteurs de vitesses::
     PNCconf permet de modifier les vitesses d'avances ou de broche en utilisant 
    une manivelle à micros impulsions (MPG) ou un commutateur rotatif.

== Configuration de la GUI

Ici vous pouvez configurer l'interface graphique utilisateur (GUI), lui 
ajouter des panneaux de commande virtuels (VCP) et définir certaines options 
d'EMC2.

.Configuration de la GUI

image::images/pncconf-gui.png[]

Options de la façade GUI::

Les options par défaut permettent aux règles générales d'être choisies pour 
n'importe quel écran d'affichage.

AXIS defaults:: 
     Ici se trouve les options spécifiques à AXIS. Si une des options *size*, 
    *position* ou *maximisez la zone* et choisie, il sera possible de modifier 
    les valeurs de vitesse minimale ou maximale, le choix de l'éditeur de fichiers, 
    la géométrie de la machine affichée. Ensuite, PNCconf demandera si il peut
    écraser le fichier de préférences (.Axisrc). 
    Cela écrasera les données que vous auriez ajoutées à la main dans ce fichier. 
 
Touchy defaults:: 
     Ici se trouve les options spécifiques à Touchy. La plupart des options de 
    Touchy peuvent être modifiées dans la page des préférences de l'application
    même quand elle est en marche. Touchy utilise GTK pour dessiner son écran, 
    et supporte les thèmes GTK. Les thèmes modifient l'apparence et l'ergonomie
    du programme. il est possible de télécharger des thèmes depuis le net ou 
    de les modifier vous-même. Il y a déjà une liste des thèmes utilisables sur 
    le système. PNCconf permet de modifier facilement le thème par défaut.

Options de VCP::
     Les panneaux de contrôle virtuels permettent d'ajouter des contrôles 
    et des afficheurs personnalisés. AXIS et Touchy peuvent intégrer ces contrôles 
    dans une zone déterminée de leur écran. Il y a deux sortes de panneaux de 
    contrôle (VCP), pyVCP qui utilise *Tkinter* pour dessiner l'écran ou 
    GLADE VCP qui utilise *GTK*.

PyVCP::
     PyVCPs est un écran construit par un fichier XML. Il ne peut pas être 
    construit à la main. PyVCPs s'intègrent naturellement avec AXIS car ils 
    utilisent tous les deux Tkinter. Des *HAL pins* sont créées pour que 
    l'utilisateur puisse les connecter dans son fichier HAL personnalisé.
    Il existe par exemple, un tachymètre pour la vitesse de broche ou un panneau 
    de boutons XYZ pour le jogging, l'utilisateur peut les utiliser tel quel ou 
    les reconstruire à son gout.
    Sélectionner un fichier vide où les contrôles (widgets) personnels seront 
    enregistrés ou sélectionner un des modèles d'affichage prêts à l'emploi,
    PCCcong établira alors lui-même les bonnes connexions avec HAL.
    Si AXIS est utilisé, le panneau sera intégré sur le côté droit. 
    Si AXIS n'est pas utilisé, le panneau sera distinct ("stand-alone") de l'écran 
    frontal. Il est possible d'utiliser les options de géométrie et de dimensions 
    et de déplacer le panneau, par exemple si le système le permet vers un second 
    écran. Si le bouton *Display sample panel* est pressé, les données de 
    géométrie et de dimensions seront utilisées et le panneau affiché.

GladeVCP::
     GladeVCP s'intègre naturellement à l'intérieur de l'écran TOUCHY car ils 
    utilisent tous les deux GTK pour leurs interfaces, mais en modifiant le thème 
    de GladeVCP il se fond très bien dans AXIS. Il utilise un éditeur graphique 
    pour créer ses fichiers XML. Des *HAL pins* sont créées, que l'utilisateur 
    pourra connecter dans son fichier HAL personnalisé.
    GladeVCP permet aussi une interaction de programmation beaucoup plus 
    sophistiquée et compliquée, ce qui n'est actuellement pas possible par PNCconf. 
    Voir le chapitre sur GladeVCP et <<cha:GladeVCP, la création d'interfaces 
    graphiques>>

PNCconf propose des exemples de panneaux à utiliser tel quel ou à reconstruire. 
Avec PNCconf, GladeVCP permettra de sélectionner différentes options d'affichage 
sur le modèle. Sous *sample options* sélectionner l'option souhaitée. 
Les boutons de zéro utilisent des commandes HALUI qui pourront être modifiées 
ultérieurement dans la section HALUI. Auto Z nécessite le programme *Touch-off* de 
classicladder et que l'entrée de sonde soit sélectionnée. Il faut aussi un palpeur 
qui peut être réalisé avec une plaque conductrice reliée à la masse. Pour avoir 
une idée sur la façon dont cela fonctionne voir: http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?ClassicLadderExamples#Single_button_probe_touchoff[ Simple bouton "Toucher"] 

Sous *Display Options*, les options de géométrie et de dimensions permettent de
déplacer le panneau, par exemple vers un second écran, si le système le permet.
Sélectionner un thème GTK pour définir l'aspect du panneaux.
En général, on le souhaite identique à l'aspect de l'écran frontal.
Ces options seront utilisées en appuyant sur le bouton *Display sample button*.
GladeVCP placé sur l'écran frontal permet de sélectionner la position du panneau 
sur celui-ci. Il peut fonctionner de manière autonome ou avec AXIS, il peut être 
au centre ou sur le côté droit, avec Touchy il peut être dans le centre.

Defaults and Options::

Aquisition d'origine obligatoire avant MDI / exécution::
- Pour pouvoir déplacer la machine sans passer par une recherche du point 
    d'origine machine décochez la case.

Fenêtre de changement d'outils::
- Permet le choix entre l'utilisation d'un écran de changement d'outil et 
l'exportation d'un signal standard pour utiliser un changeur d'outils externe 
et la table d'outils.

Laisser tourner la broche pendant le changement d'outil::
- Laisse tourner la broche pendant le changement d'outil. Pour les tours.

Oblige à faire la POM de chaque axe individuellement::
- Oblige à fixer le point zéro de chaque axe individuellement.

Position haute de la broche avant le changement d'outil::
- Met la broche en position haute avant le changement d'outil.
  
Retrouver la position après une extinction:: 
- Mémorise la position des articulations à l'extinction. Utilisé pour les 
    machines a cinématique complexe.

Changeur d'outil à position changeante::		
- Utilisé pour les changeurs d'outils qui ne reçoivent pas toujours les outils
au mêmes emplacements. Des codes HAL doivent être ajoutés pour le support de ces 
changeurs d'outils.

== Configuration Mesa

Les pages de configuration Mesa permettent d'utiliser des micros logiciels 
différents. Sur la page de base, si une carte Mesa a été sélectionnée, ici 
s'effectue le choix du micro logiciel parmi ceux disponibles, puis le choix et 
le paramétrage des composants nécessaires à la machine.

.Configuration Mesa

image::images/pncconf-mesa-config.png[]

Adresse du port parallèle MESA:: 
     Un port parallèle est utilisé seulement avec la carte Mesa 7i43. 
    Les ports parallèles sur la carte mère ont généralement les adresses 0x378 et 
    0x278 il est possible de trouver l'adresse sur la page du BIOS. 
    Le 7i43 nécessite de programmer le port parallèle dans le mode EPP, 
    encore une fois cela se configure dans la page du BIOS. Si un port parallèle 
    sur carte PCI est utilisé, les adresses peuvent être recherchées en utilisant 
    le bouton de recherche sur la page de base de PNCConf.

IMPORTANT: Noter que beaucoup de cartes PCI ne prennent pas en charge le 
    protocole EPP correctement.

Fréquence de base PDM, PWM et 3PWM:: footnote:[PDM: acronyme de Modulation de 
Densité d'Impulsions, PWM: acronyme de Modulation de Largeur d'Impulsions]
    Règle l'équilibrage entre entrainement et linéarité.
    Si des cartes filles Mesa sont utilisées, les documents de celle-ci devraient 
donner des recommandations. Il est important de les suivre pour éviter des dommages 
et obtenir les meilleures performances.

Par exemple....::
- La carte 7i33 demande un PDM et une fréquence de base de 6 mHz.
- La carte 7i29 demande un PWM et une fréquence de base de 20 Khz
- La carte 7i30 demande un PWM et une fréquence de base de 20 Khz
- La carte 7i40 demande un PWM et une fréquence de base de 50 Khz
- La carte 7i48 demande un PWM et une fréquence de base de 24 Khz

Durée du Watchdog::
     Définit le délai durant lequel la carte Mesa va attendre avant de 
    déconnecter les sorties si la communication est interrompue avec l'ordinateur. 
    Les carte Mesa utilisent sur ce contact un niveau actif bas ce qui signifie 
    que lorsque la sortie est activée son niveau logique est à 0 et si la sortie 
    est inactive son niveau logique est à 1 soit environ 5 volts. S'assurer 
    que l'équipement est en sécurité quand le watchdog est déclenché. 

Nombre de codeurs::
Nombre de générateur de PWM::
Nombre de générateur de PAS::
     Il est possible de choisir les composants en dé-sélectionnant ceux qui sont 
    inutilisés. Les types de composants disponibles varient selon le micro logiciel 
    et les cartes installées.
    Si des composants ne sont pas sélectionnés, des broches GPIO seront gagnées. 
    Si des cartes filles sont utilisées, garder à l'esprit que les pins que 
    les cartes utilisent ne doivent pas être dé-sélectionnées. Par exemple, 
    certain micros logiciels supportent deux cartes 7i33, si une seule est installée, 
    il est possible de dé-sélectionner assez de composants non nécessaires pour utiliser 
    le connecteur qui était prévus pour la seconde 7i33. Les composants sont 
    dé-sélectionnés numériquement en commençant par le plus grand nombre d'abord, 
    puis en descendant sans en sauter. Si en faisant cela, les composants ne sont 
    pas là où il devraient, alors il faut utiliser un micro logiciel différent. 
    Le micro logiciel dicte où, quoi et les nombre maximum de composants. 
    Un micro logiciel personnalisé est possible en le demandant gentiment aux 
    développeurs EMC et Mesa.
    Les micros logiciels dans PNCconf nécessitent des procédures spéciales et ce 
    n'est pas toujours possible. Bien que nous essayons de rendre PNCconf aussi 
    souple que possible.
    Après avoir choisi toutes les options, appuyer sur le bouton 
    *Accept Component Changes* et PNCconf mettra à jour les pages de configuration 
    des E / S. Seuls les onglets nécessaires seront affichés pour les connexions 
    disponibles, selon les documents de Mesa.

== Réglages des E/S Mesa

Les onglets sont utilisés pour configurer les broches d'entrée et de sortie 
des cartes Mesa. PNCconf permet de créer des noms de signaux personnalisés 
à utiliser dans les fichiers de HAL personnalisés.

.Réglages des E/S Mesa C2

image::images/pncconf-mesa-io2.png[]
Sur cet onglet, avec ce micro logiciel, les composants sont liés à l'installation 
d'une carte fille 7i33, généralement utilisée avec des servomoteurs en boucle fermée. 
Noter que les numéros de composant des codeurs, des compteurs et des pilotes PWM 
ne sont pas dans l'ordre numérique. Cela fait suite aux exigences de 
l'architecture des cartes filles.

.Réglages des E/S Mesa C3

image::images/pncconf-mesa-io3.png[]
Sur cet onglet, il n'y a que des broches GPIO. Noter les numéros à trois 
chiffres, ils correspondent au numéros des *HAL pins*. Les broches GPIO 
peuvent être sélectionnées comme des entrées ou des sorties et elles peuvent 
être inversées.

.Réglages des E/S Mesa C4

image::images/pncconf-mesa-io4.png[]
Sur cet onglet, il y a un mélange entre des broches GPIO et des générateurs de pas.
Les sorties générateur de pas et de direction peuvent être inversées. 
Noter que l'inversion d'un signal Step Gen modifie les délais de pas, 
il doivent correspondre à ce que le contrôleur attend.

Configuration des ports parallèles


image::images/pncconf-parport.png[]

Les ports parallèles peuvent être utilisés comme de simples E/S similaires aux 
broches GPIO Mesa.

== Configuration des axes


.Configuration des axes

image::images/pncconf-axis-drive.png[]

Cette page permet de configurer et tester un moteur combiné ou non à un codeur. 
Si un servomoteur est utilisé, un test en boucle ouverte est disponible. 
si un moteur pas à pas est utilisé, un test de réglage est disponible.

Test en boucle ouverte::
     Le test en boucle ouverte est important car il confirme la bonne direction du 
    moteur et du codeur. Le moteur doit se déplacer dans le sens positif sur l'axe 
    lorsque le bouton est pressé dans le sens positifs et aussi le codeur doit compter 
    dans le même sens. Le mouvement de l'axe doit suivre les normes conventionnelles 
    des machine-outil, sinon l'affichage graphique de l'axe n'aura pas de sens. 
    Espérons que la page d'aide et le diagramme vous aideront à comprendre cela. 
    Noter que les directions des axes sont celles du mouvement de l'outil et non 
    celle du mouvement de la table. Il n'y a pas de rampe d'accélération lors du test 
    en boucle ouverte, il convient donc de commencer avec une valeur faible du DAC. 
    Déplacer l'axe sur une distance connue, confirmera la bonne mise à l'échelle du 
    codeur. Le codeur doit compter dans le même sens, même sans la puissance sur le 
    moteur, mais cela dépend de la manière dont le codeur est alimenté.

[red]#AVERTISSEMENT:# Si le moteur et le codeur ne comptent pas dans le même sens, 
le servomoteur sera incontrôlable et s'emballera lors de l'utilisation en boucle 
fermée sous régulation PID.footnote:[ PID: acronyme de Proportionnelle, Intégrale, 
Dérivée. Ce sont les 3 composantes de la régulation en boucle fermée de type PID.]

Pour le moment les paramètres PID ne peuvent pas être testés dans PNCconf,
ces réglages sont vraiment, pour quand vous rééditerez une configuration pour y
mettre vos paramètres PID testés...

Echelle du DAC:: footnote:[ DAC, acronyme pour Convertisseur Analogique Digital]
     Deux valeurs de mise à l'échelle, *Max Output* et *Offset* sont utilisées 
    pour linéariser le DAC.

*Théorie:*
     Ces deux valeurs sont les facteurs d'échelle et d'offset de la sortie vers
    l’amplificateur moteur, de l'axe. La deuxième valeur, l'offset, est soustraite 
    de la sortie calculée (en Volts) et divisée par la première valeur (le facteur d'échelle), 
    avant d'être écrite dans le DAC. La valeur d'échelle (Scale) s'exprime en
    Volts/Volts de sortie du DAC. Le décalage (offset) s'exprime en Volts. 
    Elles peuvent être utilisées pour linéariser le DAC. Plus précisément, lors 
    de l'écriture des sorties, EMC2 convertit d'abord la valeur effective de la 
    sortie concernée, qui est en quasi-unités SI, en valeurs brute d'actionneur. 
    Par exemple, des Volts pour un amplificateur DAC. La valeur de l'échelle peut 
    être obtenue en analysant l'unité c'est-à-dire en déterminant le rapport 
    *[sortie unités SI]/[unités actionneur]*.
    Par exemple, sur une machine avec un amplificateur en mode vitesse, qui fourni 
    1 Volt pour une vitesse résultante de 250 mm/s. Noter que les unités de 
    l'offset sont en unités machine, ici des mm/s et qu'elles sont pré-soustraites 
    des lectures capteur. La valeur de cet offset est obtenue en trouvant la 
    valeur de sortie qui donne 0,0 sur la sortie de l'actionneur. Si le DAC est
    linéarisé, cet offset est normalement de 0,0.
    L'échelle et l'offset peuvent être utilisés pour linéariser le DAC, il en 
    résultera des valeurs qui reflèteront les effets combinés du gain de 
    l'amplificateur, de la non-linéarité du DAC, des unités du DAC, etc. 
    Pour le faire, suivez cette procédure:

.Construire une table de calibration pour la sortie. 
Piloter le DAC avec la tension souhaitée et mesurez le résultat:

Mesure des tensions de sortie:

[width="50%"]
|========================================
|*Sortie brute* | *Mesure*
|-10            | *-9.93*    
| -9            | *-8.83*
|  0            | *-0.96*
|  1            | *-0.03*
|  9            | *9.87*
| 10            | *10.07*
|========================================

. Par la méthode des moindres carrés, déterminer les coefficients *+a+*, *+b+* tels que 
   *+Mesure=a*Sortiebrute+b+*
. Noter que nous voulons une sortie effective telle que la valeur mesurée soit 
    identique à la consigne. Cela signifie 
 .. *+cmd=a*Sortiebrute+b+*
 .. *+Sortiebrute=(cmd-b)/a+*
. Par conséquent, les coefficients *+a+* et *+b+* de l'ajustement linéaire peuvent être 
    utilisés directement comme échelle et offset pour le contrôleur. 

Valeur maximale de sortie::
     La valeur maximale pour la sortie de compensation PID qui est écrite sur 
    l'ampli moteur, exprimée en volts. La valeur de sortie calculée est alignée 
    sur cette limite. La limite est appliquée avant la mise à l'échelle des unités 
    de sortie effective. La valeur est appliquée de manière symétrique aux deux 
    limites, positive et négative.

Test de réglage::
     Le test de réglage ne fonctionne, malheureusement, qu'avec les systèmes à 
base moteur pas à pas. Encore une fois vérifier que les directions de déplacements 
sur l'axe sont correctes. Puis testez le système en déplaçant l'axe d’avant en arrière, 
si l'accélération ou la vitesse maximum sont trop élevées, vous perdrez des pas. 
Attention: Au cours de ce déplacement manuel garder à l'esprit que la distance 
d’arrêt est inversement proportionnelle à l’accélération et qu'avec une accélération 
faible il faut du temps et de la distance pour arrêter l’axe. Les fin de course 
ne sont pas fonctionnels pendant ce test. Un temps de pause peut être défini 
entre chaque mouvement d'essai. Cela permet de vérifier la position de l’axe et 
de voir si des pas sont perdus.

Timing des moteur pas à pas::
     La séquence de signaux des sorties pas a pas, doit être adaptée aux exigences 
du pilote des moteurs. Pncconf propose par défaut, certaines de ces séquences et il
est possible de les personnaliser. 
Voir http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?Stepper_Drive_Timing pour y 
trouver des séquences pour le matériel le plus commun (n'hésitez pas à ajouter 
celles que vous avez expérimenté). En cas de doute utiliser une valeur élevée 
comme 5000, cela ne fera que limiter la vitesse maximale.

Contrôle de moteur Brushless::
     Ces options sont utilisées pour permettre le contrôle bas niveau des 
moteurs *brushless* avec un micro logiciel spécial et des cartes filles. 
Elles permettent également la conversion des capteurs à effet Hall d'un fabricant 
à l'autre. Ce n'est que partiellement pris en charge et aura besoin d’une 
intervention pour terminer les connexions de HAL. Contacter la mail-liste ou un 
forum pour avoir de l'aide.

.Calcul de l'échelle d'axe

image::images/pncconf-scale-calc.png[]
Les paramètres d'échelle peuvent être saisis directement ou, on peut utiliser le 
bouton *calculer échelle* pour être assisté. Utiliser les cases à cocher pour 
sélectionner les calculs appropriés. Noter que *pulley teeth* exige le nombre de 
dents et non le rapport de réduction. *Worm turn ratio*, le rapport de vis sans fin,
est exactement le contraire, il exige le rapport de réduction. Si vous êtes à 
l’aise avec la notion d'échelle vous pouvez la saisir directement sans passer par 
l'assistant.

.Configuration des axes

image::images/pncconf-axis-config.png[]

Se référer également à l'onglet diagramme pour deux exemples de disposition des 
contacts de fin de course d'origine machine et de limites. Ce sont deux exemples 
parmi les nombreuses façons différentes de placez ces contacts.

IMPORTANT: Il est très important de commencer avec l'axe se déplaçant dans la 
bonne direction sinon l’acquisition du point d'origine est impossible !

Se souvenir que les directions positives et négatives se référent toujours à 
l'outil et jamais à la table.

Sur une faiseuse classique::
- Lorsque la table se déplace vers l'opérateur, c'est la direction positive de l'axe Y.
- Lorsque la table se déplace à gauche, c'est la direction positive de l'axe X.
- Lorsque la table se déplace vers le bas, c'est la direction positive de l'axe Z.
- Lorsque la tête se déplace vers le haut, c'est aussi la direction positive de l'axe Z.

Sur un tour classique::
- Lorsque l'outil se déplace à droite, en s'éloignant du mandrin,  c'est le sens 
    positif de l'axe Z.
- Lorsque l'outil se déplace vers l'opérateur, c’est le sens positif de l'axe X. 
- Certains tours ont un axe X opposé, dans ce cas l'outil est à l'arrière, cela 
   fonctionne bien, mais l'affichage graphique d'AXIS ne peut pas refléter cette 
   configuration.

Lorsque des contacts d'origine machine et des contacts de fin de course sont utilisés, 
EMC2 attend des signaux de HAL au niveaux haut lorsque le contact est actionné. 
Si le signal d'un fin de course est inversé, EMC2 détectera en permanence que 
la machine est en bout de course. Si la logique de recherche du contact d'origine
machine est mauvaise (fichier ini), EMC2 lancera la séquence de recherche d'origine 
machine de l'axe dans la mauvaise direction.

Décider de l'emplacement des fins de courses::
     Les fin de course de limite d'axe sont au delà des limites logicielles, ils 
    protègent la machine en cas de problème électrique, par exemple, l'emballement 
    d'un servomoteur.
	Les fin de course doivent être placés de manière à ce que l'axe ne puisse pas 
    percuter une butée mécanique. Attention: si la distance d'activation du contact
    de fin de course est trop faible, avec l'inertie du mobile il pourra le dépasser.
    Les fin de course des limites d'axes, doivent être actifs à l'état bas et 
    ils doivent aussi couper la puissance sur l'axe concerné. Le contact doit 
    s'ouvrir à l'activation du fin de course. Utiliser un autre câblage est 
    possible mais il est moins sécurisé.
    Il peut être nécessaire d'inverser le signal de HAL dans EMC2 pour avoir un 
    état actif haut, TRUE signifie que le contact a été activé. Lorsqu'au 
    démarrage d'EMC2 un avertissement de limite et affiché même si l'axe n'est 
    pas sur un des fin de course, le signal est probablement inversé. Utiliser 
    HALMETER pour vérifier l'état du signal de HAL correspondant, par exemple,
    axis.0.pos-lim-sw-in, fin de course positif de l'axe X.
	 
Décider de l'emplacement des contacts d'origine machine::
    Si des fin de course de limite d'axe sont utilisés, il est possible de les 
    utiliser également comme contacts d'origine machine.
	Un contact d'origine machine séparé est utile si les axes sont longs et que 
    le déplacement vers un fin de course dure trop longtemps pour un usage normale 
    ou que le déplacement vers une extrémité présente des problèmes d'interférences 
    avec le porte-pièce ou la pièce.
    Par exemple sur un tour, le déplacement en bout de banc n'est pas efficace 
    pour un point d'origine machine et un contact placé vers le centre est 
    certainement meilleur.
    Si codeur avec un index est utilisé, le contact agit comme point de référence 
    et l'index suivant sera le point d'origine machine effectif.
  
Décider de la position de l'origine machine::
     L'origine machine dans EMC2 sert de référence à tous les systèmes de coordonnées 
    utilisateur. Il n'y a pas d'emplacement particulier pour ce point. Seuls 
    quelques G-codes accèdent au système de coordonnées machine (G53, G30 et G28).
    Si l'option de changement d'outil sur G30 est utilisée, placer l'origine machine 
    à cet endroit peut être commode. Par convention, il est plus simple d'avoir 
    l'origine machine sur le contact d'origine.
	
Décider de la position finale de l'origine::
     Ça consiste simplement à placer le chariot ou la broche à la position 
    la plus commode après qu'EMC2 soit initialisé et que les points d'origines
    machine de chacun des axes lui soit connus.   

Définition des côtés positifs/négatifs et des longueurs de courses maximales::
    Placer l'axe à l'origine. Faire un repère sur le mobile et un autre sur la 
    partie fixe. Déplacer la machine jusqu'au contact de limite d'axe. Mesurer
    la distance entre les deux repères pour obtenir la longueur de déplacement 
    maximale dans ce sens. Déplacer dans l'autre sens, sur le contact de limite 
    de l'autre côté. Mesurer de nouveau les repères pour obtenir la longueur de 
    déplacement maximale dans l'autre sens. Si l'origine machine est située sur 
    une des limites d'axe, alors cette distance de déplacement sera évidemment de zéro.

Point d'origine machine::
    Ce point est le point de référence de la machine. (Ne pas confondre avec le 
    point zéro de l'outil ou de la pièce). EMC2 référence tout à partir de ce point. 
    Il doit être à l'intérieur des limites logicielles sinon la machine ne pourrait
    jamais l'atteindre. EMC2 utilise la position du contact d'origine machine 
    pour calculer la position d'origine. Si la machine ne dispose pas de contact 
    il faudra la positionner manuellement sur les points d'origine, cocher les axes 
    l'un après l'autre et pour chacun, presser le bouton *POM des axes*. 
    Dans Axis, le symbole indiquant que l'origine machine de l'axe est connue 
    s'affichera alors à droite de la visu de l'axe concerné.

Course de la table::
     C'est la distance maximale que l'axe peut parcourir dans chaque direction. 
    Ceci peut ou ne peut pas être mesuré directement de l'origine aux contacts 
    de fin de course. Le cumul des courses positives et négatives sera égal à la 
    longueur de course totale.

Course positive::
     C'est la distance depuis l'origine de l'axe, jusqu'au fin de course de limite 
    du côté positif. Si l'origine de l'axe est placée sur le fin de course de limite positive, 
    cette valeur est égale à zéro. Les valeurs possibles sont positives ou égales à zéro.

Course négative::
     C'est la distance depuis l'origine de l'axe, jusqu'au fin de course de limite 
    du coté négatif. Ou la course totale moins la course positive. Si l'origine de l'axe
    est placée sur le fin de course de limite négative, cette valeur est de zéro.
    Les valeurs possibles sont négatives égales à zéro.
    Si la valeur entrée dans PNCconf n'est pas négative, elle sera déduite des 
    autres valeurs.

Position de l'origine::
     C'est la position ou se termine la séquence de prise d'origine machine. 
    Elle est référencée par rapport à l'origine et peut être positive, si cette 
    position finale est du coté positif ou négative, si cette position finale est 
    du coté négatif.

Position du contact d'origine machine::
     C'est la distance depuis le contact d'origine jusqu'à la position de l'origine. 
    Il peut être négatif ou positif selon de quel côté de l'origine il est placé. 
    Depuis ce point, si l'axe doit être déplacé dans la direction positive pour 
    arriver à l'origine, alors la valeur sera négative, sinon elle sera positive. 
    Si il est mis à zéro, l'origine sera à l'emplacement du contact (plus la distance
    éventuelle pour attendre l'index suivant, si une règle de mesure, ou un codeur 
    de position avec index sont utilisés).

Vitesse de recherche du contact d'origine machine::    
	 Vitesse utilisée pendant le déplacement vers le contact d'origine machine en 
    unités par minute.

Direction de recherche du contact d'origine machine::
    Direction de la recherche de l'origine machine. Négatif ou Positif selon le
    coté de l'axe où se trouve le contact d'origine machine. 

Vitesse d'acquisition du contact d'origine machine::
    Vitesse lente de détection du contact d'origine machine, en unités par minute.

Vitesse vers la position de l'origine::
     Vitesse utilisée pour déplacer le mobile de la position d'acquisition du contact
    d'origine machine, vers la position finale de l'origine, en unités par minute. 
    Si réglée à 0 c'est la vitesse de déplacement rapide qui sera utilisée.

Direction d'acquisition du contact d'origine machine::
     Direction d'acquisition de l'origine machine, peut être dans la même direction 
    que la recherche, ou à l'opposé.  

Origine machine sur l'index du codeur::
     EMC2 attendra l'impulsion d'index du codeur après l’acquisition du contact 
    d'origine machine.

Utiliser un fichier de compensation de jeu::
    Permet de spécifier le nom et le type d'un fichier de compensation de jeu. 
    Permet une compensation sophistiquée. Voir le manuel.

Utiliser la compensation de jeu::
     Permet de régler la compensation du jeu de la vis, ne peut pas être utilisé 
    en même temps qu'un fichier de compensation. Voir le manuel.

.Dessin d'aide à l'identification des axes et fin de course

image::images/pncconf-diagram-lathe.png[]

Ce dessin devrait aider à comprendre un exemple de positionnement des contacts 
de fin de course et les directions standards sur un tour.
Sur ce tour, l'axe Z a deux contacts de fin de course, le contact positif est 
utilisé également comme contact de prise d'origine machine. La position du zéro 
machine (origine machine de l'axe) est placée à la limite négative.
Le bord gauche du chariot est la came qui active le fin de course de la limite 
négative et le côté droit, la came qui active le fin de course de la limite positive. 
Nous voyons que la position finale de l'origine se trouve à 4 pouces de distance 
de l'origine de l'axe, du côté positif.
Si le chariot était déplacé jusqu'à la limite positive, nous mesurerions 10 pouces 
entre la limite négative et la came du côté négatif du chariot (fin de course 
bord gauche du chariot).

Configuration de la broche

Si un signal de contrôle de la broche est présent, cette page permet de le configurer.

TIP: Beaucoup d'options de cette page ne sont visibles que si les sélections 
appropriées ont été choisies dans les pages précédentes. Si des signaux de broche 
ont été sélectionnés, alors cette page est disponible pour les configurer.

.Configuration de la broche

image::images/pncconf-spindle-config.png[]

Cette page est semblable à la page de configuration des moteurs d'axe mais il y a 
quelques différences: À moins que l'on ait choisi un moteur pas à pas pour la 
conduite de la broche il n'y a pas d'accélération ni de limitation de vitesse.
Il n'y a pas de support pour les changements de vitesse ni pour les gammes de vitesses.  
Si une option VCP d'affichage de vitesse broche est choisie, alors la 
*vitesse broche atteinte*, *l'échelle*, *la vitesse* et *les réglages de filtres*
seront visibles. L’information sur la vitesse de broche permet à EMC2 d'attendre 
que celle-ci ait atteint la vitesse de consigne, avant de déplacer les axes. 
C'est particulièrement pratique sur les tours, lors de l'utilisation d'une vitesse 
de coupe constante avec de grands changements de diamètre. Il exige un retour 
d'information par codeur ou par un signal de vitesse broche numérique, typiquement 
connecté à un variateur de vitesse (VFD). 

En utilisant le retour d'information d'un codeur, il est possible de choisir une 
plage de *vitesse broche atteinte* comme tolérance de vitesse, au delà de laquelle,
la vitesse broche sera admise comme étant la vitesse de consigne.

En utilisant le retour d'information d'un codeur, l'affichage de vitesse VCP peut 
être irrégulier, des filtres peuvent dans ce cas, être utilisés pour corriger l'affichage. 
L'échelle du codeur doit être réglée à la valeur *comptage codeur/rapport de réduction utilisé*.
Si une seule entrée est utilisée pour le codeur de broche, la ligne suivante doit 
être ajoutée: setp hm2_7i43.0.encoder.00.counter-mode 1 (Changer le nom de la 
carte et le numéro de codeur selon besoins) dans le fichier HAL personnalisé. 
Lire la section codeurs dans Hostmot2 pour plus d'information sur les modes de 
comptage.

== Options avancées

Cette page permet de régler les commandes HALUI, de charger classicladder. Elle
propose des exemples de programmes en Ladder.
Si l'option GladeVCP a été choisie, comme pour la mise à zéro de l'axe sur 
l'origine pièce.  Les commandes nécessaires s'afficheront. 
Voir le manuel de HALUI pour utiliser des commandes personnalisées halcmds. 
Parmi les exemples de programmes ladder: Le programme Estop permet de gérer un 
contact externe d'arrêt d'urgence ou permet à l'interface graphique de déclencher
l'arrêt d'urgence. La commande périodique de la pompe du graissage centralisé est 
disponible. +
Le contact de mise au zéro pièce de l'axe Z (longueur d'outil) s'utilise avec 
une plaque de référence, le contact (touch-off) de GladeVCP et les commandes 
spéciales HALUI sont là pour permettre rapidement, une recherche de l'origine pièce.

Le programme série *modbus* est un squelette de programme, vierge, préréglé pour 
l'utilisation de classicladder avec le protocole série modbus. Voir la section 
classicladder dans le manuel.


.Options avancées

image::images/pncconf-advanced.png[]

== Composants de HAL

Cette page permet d'ajouter des composants de HAL supplémentaires qui seront utilisés
dans les fichiers HAL personnalisés. De cette manière il n'est pas nécessaire 
d'éditer le fichier HAL principal en permettant malgré tout à l'utilisateur de 
définir ses propres composants.

.Composants de HAL

image::images/pncconf-hal.png[]

La première sélection est prévue pour les composants que pncconf utilise en interne.
Il est possible de configurer pncconf pour qu'il charge les instances additionnelles
pour votre fichier HAL personnalisé.
Sélectionner le nombres d'instances dont a besoin le fichier de personnalisation 
et pncconf ajoutera ce qui est nécessaire.
Si 2 composants sont nécessaires et que pncconf à besoin d'un composant interne, 
il chargera 3 composants et utilisera le dernier.

Composants de commande personnalisés::
     Cette sélection permettra de charger des composants de HAL que pncconf 
    n'utilise pas. 
    Ajoute les commandes loadrt ou loadusr dans l'entête *loading command*. 
    Ajoute la commande addf dans l'entête *Thread command*.
    Les composants seront ajoutés au thread entre la lecture des entrées et 
    l'écriture des sorties, dans l'ordre ou ils sont écrits dans *thread command*.

== Utilisation avancée de PNCConf

PNCconf fait de son mieux pour permettre un personnalisation souple à l'utilisateur, 
PNCconf supporte les noms de signaux particuliers, le chargement de composants 
personnalisés comme la personnalisation des fichiers de HAL et des microprogrammes.
Il y a aussi les noms de signaux que PNCconf fournit, indépendamment des options 
choisies, pour les fichiers HAL personnalisés.

Avec une conception réfléchie, la plupart des personnalisations devraient fonctionner, 
même si des options doivent être modifiées par la suite dans PNCCONF.
Finalement, si les personnalisations vont au-delà du périmètre de travail de PNCCONF,
il sera possible d'utiliser PNCCONF pour construire une configuration de base, 
ou d'utiliser une des configurations fournies en standards par EMC2 et de l'éditer
pour obtenir ce que est souhaité. 

Nom de signaux personnalisés::

Si un composant doit être connecté à quelque chose dans un fichier HAL personnalisé, 
écrire un nom de signal unique dans la boîte de dialogue. Certains composants 
ajouteront des suffixes au nom du signal personnalisé.

    Les codeurs ajoutent  < Nom personnalisé >:
    -position
    -count
    -velocity
    -index-enable
    -reset

    Les contrôles de moteurs pas à pas ajoutent:
    -enable
    -counts
    -position-cmd
    -position-fb
    -velocity-fb
    
    Les PWM ajoutent:
    -enable
    -value

    Les broches GPIO auront juste le nom du signal d'entrée qui leur est connecté.

De cette façon on peut établir des connexions à ces signaux dans les fichiers 
personnalisés de HAL et avoir toujours la possibilité de les déplacer plus tard.

Charger un microprogramme personnalisé::

PNCconf cherche le microprogramme sur le système et cherche ensuite le fichier XML 
qu'il peut convertir et qu'il comprend. Ces fichiers XML sont seulement fournis 
pour les microprogrammes officiellement délivrés par l'équipe EMC2. Pour utiliser 
un microprogramme personnalisé, il faut le convertir en tableau que PNCconf comprend 
et ajouter son chemin dans le fichier de préférences de PNCCONF. Par défaut 
le chemin recherché est sur le bureau, dans un dossier nommé *custom_firmware* 
contenant un fichier nommé firmware.py.

Le fichier caché des préférence est dans le dossier home de l'utilisateur et se 
nomme .pncconf-preferences, pour l'éditer il faut sélectionner *afficher les 
fichiers cachés*. On peut voir le contenu de ce fichier au premier démarrage de 
PNCCONF. Presser le bouton d'aide et regarder la page de sortie.
Demander sur la liste de diffusion EMC2 ou sur le forum pour des renseignements 
pour convertir un microprogramme personnalisé. 
Tous les microprogrammes ne peuvent pas être utilisés avec PNCCONF.

Fichiers HAL Personnalisés::
    Il y a quatre fichiers personnalisés utilisables pour ajouter des commandes a HAL:
- custom.hal est prévu pour les commandes HAL utilisées avant le chargement de 
    l'interface graphique. Il est exécuté après le fichier HAL de configuration 
    nommé : non-de-la-configuration.hal
- custom_postgui.hal est prévu pour les commandes qui doivent être exécutées après 
    le chargement de l'interface graphique Axis ou PYVCP autonomes.
// PYVCP a trouver 
- custom_gvcp.hal est prévu pour les commandes qui doivent être exécutées après 
    le chargement de GLADE VCP.
- shutdown.hal est prévu pour des commandes exécutées quand EMC2 se ferme de façon 
    contrôlée.

// vim: set syntax=asciidoc:




