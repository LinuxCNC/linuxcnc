= hostmot2(9)

== NAME

hostmot2 - LinuxCNC HAL driver for the Mesa Electronics HostMot2 firmware.

== SYNOPSIS

See the config modparam section below for Mesa card configuration.
Typically hostmot2 is loaded with no parameters unless debugging is required.

*loadrt hostmot2* [ **debug_idrom=**__N__ ] [ **debug_module_descriptors=**__N__ ] [ **debug_pin_descriptors=**__N__ ] [ **debug_modules=**__N__ ]

*debug_idrom* [default: 0]::
 Developer/debug use only! Enable debug logging of the HostMot2 IDROM header.
*debug_module_descriptors* [default: 0]::
 Developer/debug use only! Enables debug logging of the HostMot2 Module Descriptors.
*debug_pin_descriptors* [default: 0]::
 Developer/debug use only! Enables debug logging of the HostMot2 Pin Descriptors.
*debug_modules* [default: 0]::
 Developer/debug use only! Enables debug logging of the HostMot2 Modules used.
*use_serial_numbers* [default: 0]::
 When creating HAL pins for smart-serial devices name the pins by the
 board serial number rather than which board and port they are
 connected to. With this option set to 1 pins will have names like
 `hm2_8i20.1234.current` rather than `hm2_5i23.0.8i20.0.1.current`.
 The identifier consists of the last 4 digits of the board serial number,
 which is normally on a sticker on the board. This will make configs
 less portable, but does mean that boards can be re-connected less carefully.

== DESCRIPTION

hostmot2 is a device driver that interfaces the Mesa or litehm2 HostMot2
firmware to the LinuxCNC HAL. This driver by itself does nothing, the
boards that actually run the firmware require their own drivers before
anything can happen. Currently drivers are available for PCI, Ethernet,
SPI and EPP interfaced cards.

The HostMot2 firmware provides modules such as encoders, PWM generators,
step/dir generators, and general purpose I/O pins (GPIOs). These things
are called "Modules". The firmware is configured, at firmware compile
time, to provide zero or more instances of each of these Modules.

=== Board I/O Pins

The HostMot2 firmware runs on an FPGA board. The board interfaces with
the computer via PCI, Ethernet, SPI, or EPP, and interfaces with motion
control hardware, such as servos and stepper motors via I/O pins on the board.

Each I/O pin can be configured, at board-driver load time, to serve one
of two purposes: Either as a particular I/O pin of a particular Module
instance (encoder, pwmgen, stepgen etc), or as a general purpose digital
I/O pin. By default all Module instances are enabled, and all the
board's pins are used by the Module instances.

The user can disable Module instances at board-driver load time, by
specifying a hostmot2 config string modparam. Any pins which belong to
Module instances that have been disabled automatically become GPIOs.

All I/O pins have some HAL presence, whether they belong to an active
module instance or are full GPIOs. GPIOs can be changed (at run-time)
between inputs, normal outputs, and open drains, and have a flexible HAL
interface. I/O pins that belong to active Module instances are
constrained by the requirements of the owning Module, and have a more
limited interface in HAL. This is described in the General Purpose I/O
section below.

=== config modparam

All the board-driver modules (hm2_pci, hm2_eth etc) accept a load-time
modparam of type string array, named "config". This array has one config
string for each board the driver should use. Each board's config string
is passed to and parsed by the hostmot2 driver when the board-driver
registers the board.

The config string can contain spaces, so it is usually a good idea to
wrap the whole thing in double-quotes (the " character).

The comma character (,) separates members of the config array from each other.

For example, if your control computer has one 5I20 and one 5I23 you might
load the hm2_pci driver with a HAL command (in halcmd) something like this:


*loadrt hm2_pci config="firmware=hm2/5i20/SVST8_4.BIT num_encoders=3 num_pwmgens=3 num_stepgens=3,firmware=hm2/5i23/SVSS8_8.BIT sserial_port_0=0000 num_encoders=4"*


Note: This assumes that the hm2_pci driver detects the 5I20 first and the 5I23 second.
If the detection order does not match the order of the config strings,
the hostmot2 driver will refuse to load the firmware and
the board-driver (hm2_pci etc) will fail to load. To the best of my knowledge,
there is no way to predict the order in which PCI boards will be detected by the driver,
but the detection order will be consistent as long as PCI boards are not moved around.
Best to try loading it and see what the detection order is.

The valid entries in the format string are:

**[firmware=**__F__**]**

**[num_dplls=**__N__**]**

**[num_encoders=**__N__**]**

**[ssi_chan_**__N__**=**__abc%nq__**]**

**[biss_chan_**__N__**=**__abc%nq__**]**

**[fanuc_chan_**__N__**=**__abc%nq__**]**

**[num_inmux=**__N__**]**

**[num_inms=**__N__**]**

**[num_resolvers=**__N__**]**

**[num_pwmgens=**__N__**]**

**[num_3pwmgens=**__N__**]**

**[num_oneshots=**__N__**]**

**[num_periodms=**__N__**]**

**[num_rcpwmgens=**__N__**]**

**[num_stepgens=**__N__**]**

**[stepgen_width=**__N__**]**

**[sserial_port_0=**00000000**]**

**[num_bspis=**__N__**]**

**[num_leds=**__N__**]**

**[num_ssrs=**__N__**]**

**[num_outms=**__N__**]**

**[num_xy2mods=**__N__**]**

**[enable_raw]**


*firmware* [optional]::
 Load the firmware specified by _F_ into the FPGA on this board.
 If no "**firmware=**_F_" string is specified, the FPGA will not be
 re-programmed but may continue to run a previously downloaded firmware.

The requested firmware _F_ is fetched by udev, which searches for the
firmware in the system's firmware search path, usually /lib/firmware.
_F_ typically has the form "hm2/<BoardType>/file.bit";
a typical value for _F_ might be "hm2/5i20/SVST8_4.BIT".
The hostmot2 firmware files are supplied by the hostmot2-firmware packages,
available from https:://linuxcnc.org[linuxcnc.org] and can normally be installed
by entering the command "sudo apt-get install hostmot2-firmware-5i23"
to install the support files for the 5I23 for example.

Newer FPGA cards come pre-programmed with firmware and no "firmware="
string should be used with these cards. To change the firmware on these
cards the "mesaflash" utility should be used. It is perfectly valid and
reasonable to load these cards with no config string at all.

*num_dplls* [optional, default: -1]::
 The hm2dpll is a phase-locked loop timer module which may be used to
 reduce sample and write time jitter for some hm2 modules. This
 parameter can be used to disable the hm2dpll by setting the number to 0.
 There is only ever one module of this type, with 4 timer channels,
 so the other valid numbers are -1 (enable all) and 1, both of which
 end up meaning the same thing.
*num_encoders* [optional, default: -1]::
 Only enable the first N encoders. If N is -1, all encoders are enabled.
 If N is 0, no encoders are enabled. If N is greater than the number of
 encoders available in the firmware, the board will fail to register.
**ssi_chan_**_N_ [optional, default: ""]::
 Specifies how the bit stream from a Synchronous Serial Interface
 device will be interpreted. There should be an entry for each device
 connected. Only channels with a format specifier will be enabled (as
 the software can not guess data rates and bit lengths).
**biss_chan_**_N_ [optional, default: ""]::
 As for ssi_chan_N, but for BiSS devices.
**fanuc_chan_**__N__ [optional, default: ""]::
 Specifies how the bit stream from a Fanuc absolute encoder will be
 interpreted. There should be an entry for each device connected. Only
 channels with a format specifier will be enabled (as the software can
 not guess data rates and bit lengths).
*num_resolvers* [optional, default: -1]::
 Only enable the first N resolvers. If N = -1 then all resolvers are
 enabled. This module does not work with generic resolvers (unlike the
 encoder module which works with any encoder). At the time of writing
 this Hostmot2 Resolver function only works with the Mesa 7I49 card.
*num_pwmgens* [optional, default: -1]::
 Only enable the first N pwmgens. If N is -1, all pwmgens are enabled.
 If N is 0, no pwmgens are enabled. If N is greater than the number of
 pwmgens available in the firmware, the board will fail to register.
*num_3pwmgens* [optional, default: -1]::
 Only enable the first N Three-phase pwmgens. If N is -1, all 3pwmgens
 are enabled. If N is 0, no pwmgens are enabled. If N is greater than
 the number of pwmgens available in the firmware, the board will fail
 to register.
*num_rcpwmgens* [optional, default: -1]::
 Only enable the first N RC pwmgens. If N is -1, all rcpwmgens are
 enabled. If N is 0, no rcpwmgens are enabled. If N is greater than the
 number of rcpwmgens available in the firmware, the board will fail to
 register.
*num_stepgens* [optional, default: -1]::
 Only enable the first N stepgens. If N is -1, all stepgens are
 enabled. If N is 0, no stepgens are enabled. If N is greater than the
 number of stepgens available in the firmware, the board will fail to
 register.
*num_xy2mods* [optional, default: -1]::
 Only enable the first N xy2mods. If N is -1, all xy2mods are enabled.
 If N is 0, no xy2mods are enabled. If N is greater than the number of
 xy2mods available in the firmware, the board will fail to register.

*stepgen_width* [optional, default: 2]::
 Used to mask extra, unwanted, stepgen pins. Stepper drives typically
 require only two pins (step and dir) but the Hostmot2 stepgen can
 drive up to 8 output pins for specialised applications (depending on
 firmware). This parameter applies to all stepgen instances. Unused,
 masked pins will be available as GPIO.
**sserial_port_**_N_ (_N_ = 0 .. 3) [optional, default: 00000000 for all ports]::
 Up to 32 Smart Serial devices can be connected to a Mesa Anything I/O
 board, depending on the firmware used and the number of physical
 connections on the board. These are arranged in 1-4 ports (N) of 1 to
 8 channels. Some Smart Serial (SSLBP) cards offer more than one
 load-time configuration, for example all inputs, or all outputs, or
 offering additional analogue input on some digital pins. To set the
 modes for port 0 use for example *sserial_port_0=0120xxxx*. A "0" in
 the string sets the corresponding channel to mode 0, a "1" to mode 1,
 and so on up to mode 9. An "x" in any position disables that channel
 and makes the corresponding FPGA pins available as GPIO. The string
 can be up to 8 characters long, and if it defines more modes than
 there are channels on the port then the extras are ignored. Channel
 numbering is left to right so the example above would set sserial
 device 0.0 to mode 0, 0.1 to mode 1, 0.2 to mode 2, 0.3 to mode 0 and
 disables channels 0.4 onwards. The sserial driver will auto-detect
 connected devices, no further configuration should be needed.
 Unconnected channels will default to GPIO, but the pin values will
 vary semi-randomly during boot when card-detection runs, to it is best
 to actively disable any channel that is to be used for GPIO. See
 SSERIAL(9) for more information.
*num_bspis* [optional, default: -1]::
 Only enable the first N Buffered SPI drivers. If N is -1 then all the
 drivers are enabled. Each BSPI driver can address 16 devices.
*num_leds* [optional, default: -1]::
 Only enable the first N of the LEDs on the FPGA board. If N is -1,
 then HAL pins for all the LEDs will be created. If N=0 then no pins
 will be added.
*num_ssrs* [optional, default: -1]::
 Only enable the first N of the SSR modules on the FPGA board. If N is
 -1, then HAL pins for all the SSR outputs will be created. If N=0 then
 no pins will be added.
*enable_raw* [optional]::
 If specified, this turns on a raw access mode, whereby a user can peek
 and poke the firmware from HAL. See Raw Mode below.

=== dpll

The hm2dpll module has pins like "hm2__<BoardType>_._<BoardNum>_.dpll"
It is likely that the pin-count will decrease in the future and that
some pins will become parameters. This module is a phase-locked loop
that will synchronise itself with the thread in which the hostmot2
"read" function is installed and will trigger other functions that are
allocated to it at a specified time before or after the "read" function
runs. This can be applied to the three absolute encoder types,
quadrature encoder, stepgen, and xy2mod. In the case of the absolute
encoders this allows the system to trigger a data transmission just
prior to the time when the HAL driver reads the data. In the case of
stepgens, quadrature encoders, and the xy2mod, the timers can be used to
reduce position sampling jitter. This is especially valuable with the
ethernet-interfaced cards.

*Pins:*

hm2___<BoardType>__.__<BoardNum>__.dpll._NN_.timer-us (float, in)::
 This pin sets the triggering offset of the associated timer. There are
 4 timers numbered 01 to 04, represented by the _NN_ digits in the pin
 name. The units are microseconds (µs). Generally the value for reads
 will be negative, and positive for writes, so that input data is
 sampled prior to the main hostmot read and output data is written some
 time after the main hostmot2 read.
 +
 For stepgen and quadrature encoders, the value needs to be more than the
 maximum variation between read times. -100 will suffice for most
 systems, and -50 will work on systems with good performance and latency.
 +
 For serial encoders, the value also needs to include the time it takes
 to transfer the absolute encoder position. For instance, if 50 bits must
 be read at 500 kHz then subtract an additional 50/500 kHz = 100 µs to
 get a starting value of -200.
 +
 The xy2mod uses 2 DPLL timers, one for read and one for write.
 The read timer value can be the same as used by the stepgen and quadrature
 encoders so the same timer channel can be shared.
 The write timer is typically set to a time after the main hostmot2 write
 this may take some experimentation.

hm2__<BoardType>__.__<BoardNum>__.dpll.base-freq-khz (float, in)::
 This pin sets the base frequency of the phase-locked loop. By default
 it will be set to the nominal frequency of the thread in which the PLL
 is running and will not normally need to be changed.
hm2__<BoardType>__.__<BoardNum>__.dpll.phase-error-us (float, out)::
 Indicates the phase error of the DPLL. If the number cycles by a large
 amount it is likely that the PLL has failed to achieve lock and
 adjustments will need to be made.
hm2___<BoardType>__.__<BoardNum>__.dpll.time-const (u32, in)::
 The filter time-constant for the PLL. The default value is a
 compromise between insensitivity to single-cycle variations and being
 resilient to changes to the Linux CLOCK_MONOTONIC timescale, which can
 instantly change by up to ±500ppm from its nominal value, usually by
 timekeeping software like ntpd and ntpdate. Default 2000 (0x7d0).
hm2___<BoardType>__.__<BoardNum>__.dpll.plimit (u32, in)::
 Sets the phase adjustment limit of the PLL. If the value is zero then
 the PLL will free-run at the base frequency independent of the servo
 thread rate. This is probably not what you want. Default 4194304
 (0x400000) Units not known...
hm2___<BoardType>__.__<BoardNum>__.dpll.ddsize (u32, out)::
 Used internally by the driver, likely to disappear.
hm2___<BoardType>__.__<BoardNum>__.dpll.prescale (u32, in)::
 Prescale factor for the rate generator. Default 1.

=== Encoder

Encoders have names like **hm2_**__<BoardType>__**.**__<BoardNum>__**.encoder.**__<Instance>__**.**".
"Instance" is a two-digit number that corresponds to the HostMot2 encoder instance number.
There are "num_encoders" instances, starting with 00.

So, for example, the HAL pin that has the current position of the second
encoder of the first 5I25 board is: hm2_5i25.0.encoder.01.position (this
assumes that the firmware in that board is configured so that this HAL
object is available).

Each encoder uses three or four input I/O pins, depending on how the
firmware was compiled. Three-pin encoders use A, B, and Index (sometimes
also known as Z). Four-pin encoders use A, B, Index, and Index-mask.

The hm2 encoder representation is similar to the one described by the
Canonical Device Interface (in the HAL General Reference document), and
to the software encoder component. Each encoder instance has the
following pins and parameters:

*Pins:*

count (s32 out)::
 Number of encoder counts since the previous reset.
position (float out)::
 Encoder position in position units (count / scale).
position-interpolated (float out)::
 Encoder interpolated position in position units (count / scale). Only
 valid when velocity is approximately constant and the time between
 counts is less than the velocity timeout parameter value. Do not use
 for position control. Useful for spindle synchronized moves with low
 resolution encoders.
position-latched (float out)::
 Encoder latched position in position units (count / scale).
velocity (float out)::
 Estimated encoder velocity in position units per second.
velocity-rpm (float out)::
 Estimated encoder velocity in position units per minute.
reset (bit in)::
 When this pin is True, the count and position pins are set to 0 (the
 value of the velocity pin is not affected by this). The driver does
 not reset this pin to FALSE after resetting the count to 0, that is
 the user's job.
index-enable (bit in/out)::
 When this pin is set to True, the count (and therefore also position)
 are reset to zero on the next Index (Phase-Z) pulse. At the same time,
 index-enable is reset to zero to indicate that the pulse has occurred.
probe-enable (bit in/out)::
 When this pin is set to True, the encoder count (and therefore also
 position) are latched on the the next probe active edge. At the same
 time, probe-enable is reset to zero to indicate that latch event has
 occurred.
probe-invert (bit r/w)::
 If set to True, the rising edge of the probe input pin triggers the
 latch event (if probe-enable is True). If set to False, the falling
 edge triggers.
rawcounts (s32 out)::
 Total number of encoder counts since the start, not adjusted for index or reset.
input-a, input-b, input-index (bit out)::
 Real time filtered values of A,B,Index encoder signals
quad-error-enable (bit in)::
 When this pin is True quadrature error reporting is enabled. When
 False, existing quadrature errors are cleared and error reporting is disabled.
quad-error (bit out)::
 This bit indicates that a quadrature sequence error has been detected.
 It can only be set if the corresponding quad-error-enable bit is True.
hm2_XXXX.N.encoder.sample-frequency (u32 in)::
 This is the sample frequency that determines all standard encoder
 channels digital filter time constant (see filter parameter).
hm2_XXXX.N.encoder.muxed-sample-frequency (u32 in)::
 This is the sample frequency that determines all muxed encoder
 channels digital filter time constant (see filter parameter).
 This also sets the encoder multiplexing frequency.
hm2_XXXX.N.encoder.muxed-skew (float in)::
 This sets the muxed encoder sample time delay (in ns) from the multiplex signal.
 Setting this properly can increase the usable
 multiplex frequency and compensate for cable delays (suggested value
 is 3* cable length in feet +20).
hm2_XXXX.N.encoder.hires-timestamp (bit in)::
 When this pin is True the encoder timestamp counter frequency is
 ca. 10 MHz when False the timestamp counter frequency is ca. 2&#8201;MHz.
 This should be set True for frequency counting applications to improve the resolution.
 It should be set False when servo thread periods longer than 1&#8201;ms are used.

*Parameters:*

scale (float r/w)::
 Converts from "count" units to "position" units.
index-invert (bit r/w)::
 If set to True, the rising edge of the Index input pin triggers the
 Index event (if index-enable is True). If set to False, the falling
 edge triggers.
index-mask (bit r/w)::
 If set to True, the Index input pin only has an effect if the
 Index-Mask input pin is True (or False, depending on the
 index-mask-invert pin below).
index-mask-invert (bit r/w)::
 If set to True, Index-Mask must be False for Index to have an effect.
 If set to False, the Index-Mask pin must be True.
counter-mode (bit r/w)::
 Set to False (the default) for Quadrature. Set to True for Step/Dir
 (in which case Step is on the A pin and Dir is on the B pin).
filter (bit r/w)::
 If set to True (the default), the quadrature counter needs 15 sample
 clocks to register a change on any of the three input lines (any pulse
 shorter than this is rejected as noise). If set to False, the
 quadrature counter needs only 3 clocks to register a change. The
 default encoder sample clock runs at approximately 25 to 33 MHz but
 can be changed globally with the sample-frequency or
 muxed-sample-frequency pin.
vel-timeout (float r/w)::
 When the encoder is moving slower than one pulse for each time that
 the driver reads the count from the FPGA (in the hm2_read() function), the velocity is harder to estimate.
 The driver can wait several iterations for the next pulse to arrive,
 all the while reporting the upper bound of the encoder velocity, which can be accurately guessed.
 This parameter specifies how long to wait for the next pulse, before reporting the encoder stopped.
 This parameter is in seconds.
hm2_XXXX.N.encoder.timer-number (default: -1) (s32 r/w)::
 Sets the hm2dpll timer instance to be used to latch encoder counts.
 A setting of -1 does not latch encoder counts. A setting of 0 latches at
 the same time as the main hostmot2 read. A setting of 1..4 uses a time
 offset from the main hostmot2 read according to the dpll's timer-us setting.

Typically, timer-us should be a negative number with a magnitude larger than the largest latency
(e.g., -100 for a system with mediocre latency, -50 for a system with good latency).
A negative number specifies latching the specified time before the nominal hostmot2 read time.

If no DPLL module is present in the FPGA firmware, or if the encoder
module does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.
Doing so generally reduces following errors.

=== Synchronous Serial Interface (SSI)

(Not to be confused with the Smart Serial Interface)

One pin is created for each SSI instance regardless of data format:

hm2_XXXX.__NN__.ssi.__MM__.data-incomplete (bit, in)::
This pin will be set "True" if the module was still transferring data when the value was read.
When this problem exists there will also be a limited number of error messages printed to the UI.
This pin should be used to monitor whether the problem has been addressed by config changes.
Solutions to the problem depend on whether
* the encoder read is being triggered by the hm2dpll phase-locked-loop timer (described above)
*  or by the trigger-encoders function (described below).

The names of the pins created by the SSI module will depend entirely on
the format string for each channel specified in the loadrt command line.
A typical format string might be *ssi_chan_0=error%1bposition%24g*.

This would interpret the LSB of the bit-stream as a bit-type pin named
"error" and the next 24 bits as a Gray-coded encoder counter.
The encoder-related HAL pins would all begin with "position".

There should be no spaces in the format string, as this is used as a
delimiter by the low-level code.

The format consists of a string of alphanumeric characters that will
form the HAL pin names, followed by a % symbol, a bit-count and a data
type. All bits in the packet must be defined, even if they are not used.
There is a limit of 64 bits in total.

The valid format characters and the pins they create are:

p: (Pad)::
 Does not create any pins, used to ignore sections of the bit stream that are not required.

b: (Boolean).:: (bit, out) hm2_XXXX.N.ssi.MM.<name>.
 If any bits in the designated field width are non-zero then the HAL pin will be "True".
 (bit, out) hm2_XXXX.N.ssi.MM.<name>-not. An inverted version of the above, the
 HAL pin will be "True" if all bits in the field are zero.

u: (Unsigned):: (float, out) hm2_XXXX.N.ssi.MM.<name>.
 The value of the bits
 interpreted as an unsigned integer then scaled such that the pin value
 will equal the scalemax parameter value when all bits are high. (for
 example if the field is 8 bits wide and the scalmax parameter was 20
 then a value of 255 would return 20, and 0 would return 0.

s: (Signed):: (float, out) hm2_XXXX.N.ssi.MM.<name>.
 The value of the bits
 interpreted as a 2s complement signed number then scaled similarly to
 the unsigned variant, except symmetrical around zero.

f: (bitField):: (bit, out) hm2_XXXX.N.ssi.MM.<name>-NN.
 The value of each individual
 bit in the data field. NN starts at 00 up to the number of bits in the
 field. (bit, out) hm2_XXXX.N.ssi.MM.<name>-NN-not. An inverted version
 of the individual bit values.

e: (Encoder):: (s32, out) hm2_XXXX.N.ssi.MM.<name>.count.
The lower 32 bits of the
 total encoder counts. This value is reset both by the ...reset and the
 ...index-enable pins. (s32, out) hm2_XXXX.N.ssi.MM.<name>.rawcounts.
 The lower 32 bits of the total encoder counts. The pin is not affected
 by reset and index. (float, out) hm2_XXXX.N.ssi.MM.<name>.position.
 The encoder position in machine units. This is calculated from the
 full 64-bit buffers so will show a True value even after the counts
 pins have wrapped. It is zeroed by reset and index enable. (bit, IO)
 hm2_XXXX.N.ssi.MM.<name>.index-enable. When this pin is set "True" the
 module will wait until the raw encoder counts next passes through an
 integer multiple of the number of counts specified by counts-per-rev
 parameter and then it will zero the counts and position pins, and set
 the index-enable pin back to "False" as a signal to the system that
 "index" has been passed. this pin is used for spindle-synchronised
 motion and index-homing. (bit, in) (bit, out)
 hm2_XXXX.N.ssi.MM.<name>.reset. When this pin is set high the counts
 and position pins are zeroed.
h: (Split encoder, high-order bits)::
 Some encoders (Including Fanuc) place the encoder part-turn counts and
 full-turn counts in separate, non-contiguous fields. This tag defines
 the high-order bits of such an encoder module. There can be only one h
 and one l tag per channel, the behaviour with multiple such channels
 will be undefined.
l: (Split encoder, low-order bits)::
 Low order bits (see "h")
g: (Gray-code):: This is a modifier that indicates that the following format string is gray-code encoded.
 This is only valid for encoders (e, h l) and unsigned (u) data types.
m: (Multi-turn)::
 This is a modifier that indicates that the following
 format string is a multi-turn encoder. This is only valid for encoders
 (e, h l). A jump in encoder position of more than half the full scale
 is interpreted as a full turn and the counts are wrapped. With a
 multi-turn encoder this is only likely to be a data glitch and will
 lead to a permanent offset. This flag endures that such encoders will
 never wrap.

*Parameters*

Two parameters are universally created for all SSI instances

hm2_XXXX.N.ssi.MM.frequency-khz (float r/w)::
 This parameter sets the SSI clock frequency. The units are kHz, so 500
 will give a clock frequency of 500,000 Hz.
hm2_XXXX.N.ssi.timer-number-num (s32 r/w)::
 This parameter allocates the SSI module to a specific hm2dpll timer
 instance. This pin is only of use in firmwares which contain a hm2dpll
 function and will default to 1 in cases where there is such a
 function, and 0 if there is not. The pin can be used to disable reads
 of the encoder, by setting to a nonexistent timer number, or to 0.

Other parameters depend on the data types specified in the config string.

p: (Pad):: No Parameters.
b: (Boolean):: No Parameters.
u: (Unsigned)::
 (float, r/w) hm2_XXXX.N.ssi.MM.<name>-scalemax.
 The scaling factor for the channel.
s: (Signed)::
 (float, r/w) hm2_XXXX.N.ssi.MM.<name>-scalemax.
 The scaling factor for the channel.
f: (bitField):: No parameters.
e: (Encoder)::
 (float, r/w) hm2_XXXX.N.ssi.MM._<name>_.scale: (float, r.w) The encoder
 scale in counts per machine unit. (u32, r/w)
 hm2_XXXX.N.ssi.MM._<name>_.counts-per-rev (u32, r/w) Used to emulate the
 index behaviour of an incremental+index encoder. This would normally
 be set to the actual counts per rev of the encoder, but can be any
 whole number of revs. Integer divisors or multipliers of the true PPR
 might be useful for index-homing. Non-integer factors might be
 appropriate where there is a synchronous drive ratio between the
 encoder and the spindle or ballscrew.

=== BiSS

BiSS is a bidirectional variant of SSI. Currently only a single
direction is supported by LinuxCNC (encoder to PC).

One pin is created for each BiSS instance regardless of data format:

hm2_XXXX.NN.biss.MM.data-incomplete (bit, in)::
 This pin will be set "True" if the module was still transferring data when the value was read.
 When this problem exists there will also be a limited number of error messages printed to the UI.
 This pin should be used to monitor whether the problem has been addressed by config changes.
 Solutions to the problem depend on whether the encoder read is being triggered by the hm2dpll
 phase-locked-loop timer (described above) or by the trigger-encoders function (described below).

The names of the pins created by the BiSS module will depend entirely on
the format string for each channel specified in the loadrt command line
and follow closely the format defined above for SSI. Currently data
packets of up to 96 bits are supported by the LinuxCNC driver, although
the Mesa Hostmot2 module can handle 512 bit packets. It should be
possible to extend the number of packets supported by the driver if
there is a requirement to do so.

=== Fanuc encoder

The pins and format specifier for this module are identical to the SSI
module described above, except that at least one pre-configured format
is provided. A modparam of fanuc_chan_N=AA64 (case sensitive) will
configure the channel for a Fanuc Aa64 encoder. The pins created are:

hm2___XXXX__._N_.fanuc._MM_.batt:: indicates battery state
hm2___XXXX__._N_.fanuc._MM_.batt-not:: inverted version of above
hm2___XXXX__._N_.fanuc._MM_.comm:: The 0-1023 absolute output for motor commutation
hm2___XXXX__._N_.fanuc._MM_.crc:: The CRC checksum. Currently HAL has no way to use this
hm2___XXXX__._N_.fanuc._MM_.encoder.count:: Encoder counts
hm2___XXXX__._N_.fanuc._MM_.encoder.index-enable:: Simulated index. Set by counts-per-rev parameter
hm2___XXXX__._N_.fanuc._MM_.encoder.position:: Counts scaled by the ...scale parameter
hm2___XXXX__._N_.fanuc._MM_.encoder.rawcounts:: Raw counts, unaffected by reset or index
hm2___XXXX__._N_.fanuc._MM_.encoder.reset:: If high/True then counts and position = 0
hm2___XXXX__._N_.fanuc._MM_.valid:: Indicates that the absolute position is valid
hm2___XXXX__._N_.fanuc._MM_.valid-not:: Inverted version

=== resolver

Resolvers have names like **hm2_**__<BoardType>__**.**__<BoardNum>__**.resolver.**__<Instance>__.
__<Instance>__ is a 2-digit number, which for the 7I49 board will be between 00 and 05.
This function only works with the Mesa Resolver interface boards (of which the 7I49 is the only example at the time of writing).
This board uses an SPI interface to the FPGA card, and will only work with the correct firmware.
The pins allocated will be listed in the dmesg output, but are unlikely to be usefully probed with HAL tools.

*Pins:*

angle (float, out)::
 This pin indicates the angular position of the resolver.
 It is a number between 0 and 1 for each electrical rotation.
position (float, out)::
 Calculated from the number of complete and partial revolutions since startup,
 reset, or index-reset multiplied by the scale parameter.
velocity (float, out)::
 Calculated from the rotational velocity and the velocity-scale parameter.
 The default scale is electrical rotations per second.
velocity-rpm (float, out)::
 Simply velocity scaled by a factor of 60 for convenience.
count (s32, out)::
 This pins outputs a simulated encoder count at 2^24^ counts per rev (16777216 counts).
rawcounts (s32, out)::
 This is identical to the counts pin, except it is not reset by the
 "index" or "reset" pins. This is the pin which would be linked to the
 bldc HAL component if the resolver was being used to commutate a motor.
reset (bit, in)::
 Resets the position and counts pins to zero immediately.
joint-pos-fb (bit, in)::
 The Mesa resolver driver has the capability of emulating an absolute
 encoder using a position file (see the INI-config section of the manual)
 and the single-turn absolute operation of resolvers.
 At startup, and only if the *use-position-file* parameter is set to "True",
 the resolver driver will wait for a value to be written by the system to the axis.N.joint-pos-fb pin
 (which must be netted to this resolver pin) and will calculate the number of full turns that best
 matches the current resolver position.
 It will then pre-load the driver output with this offset.
 This should only be used on systems where axis movement in the unpowered state is unlikely.
 This feature will only work properly if the machine is initially homed to "index"
 and if the axis home positions are exactly zero.
index-enable (bit, in/out)::
 When this pin is set high the position and counts pins will be reset
 the next time the resolver passes through the zero position. At the
 same time the pin is driven low to indicate to connected modules that
 the index has been seen, and that the counters have been reset.
error (bit, out)::
 Indicates an error in the particular channel. If this value is "True"
 then the reported position and velocity are invalid.

*Parameters:*

scale (float, read/write):: The position scale, in machine units per resolver electrical revolution.

velocity-scale (float, read/write):: The conversion factor between resolver rotation speed and machine velocity.
 A value of 1 will typically give motor speed in RPS, a value of 0.01666667 will give (approximate) RPM.

index-divisor (default 1) (u32, read/write)::
 The resolver component emulates an index at a fixed point in the sin/cos cycle.
 Some resolvers have multiple cycles per rev (often related to the number of pole-pairs on the attached motor).
 LinuxCNC requires an index once per revolution for proper threading etc.
 This parameter should be set to the number of cycles per rev of the resolver.
 CAUTION: Which pseudo-index is used will not necessarily be consistent between LinuxCNC runs.
 Do not expect to re-start a thread after restarting LinuxCNC.
 It is not appropriate to use this parameter for index-homing of axis drives.

excitation-khz (float, read/write)::
 This pin sets the excitation frequency for the resolver. This pin is
 module-level rather than instance-level as all resolvers share the
 same excitation frequency. Valid values are 10 (ca. 10 kHz), 5 (ca. 5 kHz)
 and 2.5 (ca. 2.5 kHz). The actual frequency depends on the FPGA
 frequency, and they correspond to CLOCK_LOW/5000, CLOCK_LOW/10000 and
 CLOCK_LOW/20000 respectively. The parameter will be set to the closest
 available of the three frequencies. A value of -1 (the default)
 indicates that the current setting should be retained.

use-position-file (bit, read/write)::
 In conjunction with *joint-pos-fb* (qv) emulate absolute encoders.

=== pwmgen

pwmgens have names like "**hm2_**__<BoardType>__**.**__<BoardNum>__**.pwmgen.**__<Instance>__".
__<Instance>__ is a two-digit number that corresponds to the HostMot2 pwmgen instance number.
There are "num_pwmgens"-many instances, starting with 00.

So, for example, the HAL pin that enables output from the fourth pwmgen of the first 7I43 board is: `hm2_7i43.0.pwmgen.03.enable`
(this assumes that the firmware in that board is configured so that this HAL object is available).

In HM2, each pwmgen uses three output I/O pins: `Not-Enable`, `Out0`, and `Out1`.
The function of the Out0 and Out1 I/O pins varies with output-type parameter (see below).

The hm2 pwmgen representation is similar to the software pwmgen component.
Each pwmgen instance has the following pins and parameters:

*Pins:*

enable (bit input)::
 If True, the pwmgen will set its Not-Enable pin False and output its pulses.
 If "enable" is False, pwmgen will set its Not-Enable pin True and not output any signals.
value (float input)::
 The current pwmgen command value, in arbitrary units.

*Parameters:*

scale (float rw)::
 Scaling factor to convert "value" from arbitrary units to duty cycle:
 dc = value / scale. Duty cycle has an effective range of -1.0 to +1.0
 inclusive, anything outside that range gets clipped. The default scale is 1.0.
output-type (s32 rw)::
 This emulates the output_type load-time argument to the software pwmgen component.
 This parameter may be changed at runtime, but most of the time
 you probably want to set it at startup and then leave it alone.
 Accepted values are 1 (PWM on Out0 and Direction on Out1),
 2 (Up on Out0 and Down on Out1), 3 (PDM mode, PDM on Out0 and Dir on Out1),
 and 4 (Direction on Out0 and PWM on Out1, "for locked antiphase").
offset-mode (bit input)::
 When True, offset-mode modifies the PWM behavior so that a PWM value
 of 0 results in a 50% duty cycle PWM output, a -1 value results in a
 0% duty cycle and +1 results in a 100% duty cycle (with default scaling).
 This mode is used by some PWM motor drives and PWM to analog converters.
 Typically the direction signal is not used in this mode.
dither (bit input)::
 When True, dither causes the PWM output to dither between two adjacent
 PWM register values at the PWM frequency. This increases the PWM
 resolution when used for analog output purposes, increasing the
 maximum resolution from 12 to 16 bits.
 Dither is only supported with PWMGen firmware version 1 or greater and
 only affects PWM outputs, not PDM outputs.

In addition to the per-instance HAL Parameters listed above, there are a
couple of HAL Parameters that affect all the pwmgen instances:

pwm_frequency (u32 rw)::
 This specifies the PWM frequency, in Hz, of all the pwmgen instances
 running in the PWM modes (modes 1 and 2). This is the frequency of the
 variable-duty-cycle wave. Its effective range is from 1 Hz up to 386
 kHz. Note that the max frequency is determined by the ClockHigh
 frequency of the Anything IO board; the 5I25 and 7I92 both have a 200
 MHz clock, resulting in a 386 kHz max PWM frequency. Other boards may
 have different clocks, resulting in different max PWM frequencies. If
 the user attempts to set the frequency too high, it will be clipped to
 the max supported frequency of the board. Frequencies below about 5 Hz
 are not terribly accurate, but above 5 Hz they're pretty close. The
 default pwm_frequency is 20,000 Hz (20 kHz).
pdm_frequency (u32 rw)::
 This specifies the PDM frequency, in Hz, of all the pwmgen instances
 running in PDM mode (mode 3). This is the "pulse slot frequency"; the
 frequency at which the pdm generator in the AnyIO board chooses
 whether to emit a pulse or a space. Each pulse (and space) in the PDM
 pulse train has a duration of 1/pdm_frequency seconds. For example,
 setting the pdm_frequency to 2e6 (2 MHz) and the duty cycle to 50%
 results in a 1 MHz square wave, identical to a 1 MHz PWM signal with
 50% duty cycle. The effective range of this parameter is from about
 1525 Hz up to just under 200 MHz. Note that the max frequency is
 determined by the ClockHigh frequency of the Anything IO board; the
 5I25 and 7I92 both have a 100 MHz clock, resulting in a 100 MHz max
 PDM frequency. Other boards may have different clocks, resulting in
 different max PDM frequencies. If the user attempts to set the
 frequency too high, it will be clipped to the max supported frequency
 of the board. The default pdm_frequency is 20,000 Hz (20 kHz).

=== 3ppwmgen

Three-Phase PWM generators (3pwmgens) are intended for controlling the
high-side and low-side gates in a 3-phase motor driver. The function is
included to support the Mesa motor controller daughter-cards but can be
used to control an IGBT or similar driver directly. 3pwmgens have names
like "hm2___<BoardType>__.__<BoardNum>__.3pwmgen.__<Instance>__" where
__<Instance>__ is a 2-digit number. There will be num_3pwmgens instances,
starting at 00. Each instance allocates 7 output and one input pins on
the Mesa card connectors. Outputs are: PWM A, PWM B, PWM C, /PWM A, /PWM
B, /PWM C, Enable. The first three pins are the high side drivers, the
second three are their complementary low-side drivers.
The enable bit is intended to control the servo amplifier.
The input bit is a fault bit, typically wired to over-current detection.
When set, the PWM generator is disabled.
The three phase duty-cycles are individually controllable from -Scale to +Scale.
Note that 0 corresponds to a 50% duty cycle and this is the initialization value.

*Pins:*

A-value, B-value, C-value (float input)::
 The PWM command value for each phase, limited to +/- "scale".
 Defaults to zero which is 50% duty cycle on high-side and low-sidepins
 (but see the "deadtime" parameter).

enable (bit input)::
 When high the PWM is enabled as long as the fault bit is not set by
 the external fault input pin. When low the PWM is disabled, with both
 high- side and low-side drivers low. This is not the same as 0 output
 (50% duty cycle on both sets of pins) or negative full scale
 (where the low side drivers are "on" 100% of the time).
fault (bit output)::
 Indicates the status of the fault bit. This output latches high once
 set by the physical fault pin until the "enable" pin is set to high.

*Parameters:*

deadtime (u32 rw)::
 Sets the dead-time between the high-side driver turning off and the low-side driver turning on and vice-versa.
 Deadtime is subtracted from on time and added to off time symmetrically.
 For example with 20 kHz PWM (50 µs period), 50% duty cycle and zero dead time,
 the PWM and NPWM outputs would be square waves (NPWM being inverted from PWM) with high times of 25 µs.
 With the same settings but 1 µs of deadtime, the PWM and NPWM outputs would both have high times of 23 µs (25 - (2X 1 µs), 1 µs per edge).
 The value is specified in nanoseconds (ns) and defaults to a rather conservative 5000 ns.
 Setting this parameter to too low a value could be both expensive and dangerous
 as if both gates are open at the same time there is effectively a short circuit across the supply.
scale (float rw)::
 Sets the half-scale of the specified 3-phase PWM generator.
 PWM values from -scale to +scale are valid. Default is +/- 1.0
fault-invert (bit rw)::
 Sets the polarity of the fault input pin.
 A value of 1 means that a fault is triggered with the pin high, and 0 means that a fault it triggered when the pin is pulled low.
 Default 0, fault = low so that the PWM works with the fault pin unconnected.
sample-time (u32 rw)::
 Sets the time during the cycle when an ADC pulse is generated.
 0 = start of PWM cycle and 1 = end.
 Not currently useful to LinuxCNC. Default is 0.5.

In addition the per-instance parameters above there is the following
parameter that affects all instances:

frequency (u32 rw):: Sets the master PWM frequency.
 Maximum is approx 48 kHz, minimum is 1&#8201;kHz. Defaults to 20 kHz.

=== oneshot

The oneshot is a hardware one-shot device suitable for various timing,
delay, signal conditioning, PWM generation, and watchdog functions. The
oneshot module includes 2 timers to allow variable pulse delays for
applications like phase control. Trigger sources can be software,
external inputs, the DPLL timer, a built in rate generator or the other
timer. Oneshots have names like
"**hm2_**__<BoardType>__**.**__<BoardNum>__**.oneshot.**__<Instance>__"
where __<Instance>__ is a 2-digit number.
There will be num_oneshots instances, starting at 00.
Each instance allocates up to two input and two output pins.

*Pins:*

width1 (float rw)::
 Sets the pulse width of timer1 in ms. Default is 1 ms (1/1000&#8201;s).
width2 (float rw)::
 Sets the pulse width of timer2 in ms. Default is 1 ms (1/1000&#8201;s).
filter1 (float rw)::
 Sets digital filter time constant for timer1's external trigger input
 Filter time is in ms. Default filter time constant time is 0.1&#8201;ms.
 External trigger response will be delayed by the filter time setting.
filter2 (float rw)::
 Sets digital filter time constant for timer2's external trigger input
 Filter time is in ms. Default filter time constant time is 0.1&#8201;ms.
 External trigger response will be delayed by the filter time setting.
rate (float rw)::
 Sets the frequency of the built in rate generator (in Hz)
trigger_select1,trigger_select2 (u32 rw)::
 Sets the trigger source for timer1,timer2 respectively. Trigger sources are:

....
0 Trigger disabled
1 Software trigger: triggered when hal pin swtrigger1 is true
2 External hardware: trigger
3 DPLL trigger: triggered by selected DPLL timer
4 Rate trigger: triggered by build in rate generator.
5 Timer1 trigger: triggered by timer1 output
6 Timer2 trigger: triggered by timer2 output
....

trigger_on_rise1, trigger_on_rise2 (bit rw)::
 When true, triggers timer1, timer2 respectively on the rising edge of the trigger source.
trigger_on_fall1, trigger_on_fall2 (bit rw)::
 When true, triggers timer1, timer2 respectively on the falling edge of the trigger source.
retriggerable1, retriggerable2 (bit rw)::
 When true, the associated timer is retriggerable, meaning the timer
 will reset to full time on a trigger event even during the output
 pulse period. When false the timer is not retriggerable, meaning it
 will ignore trigger events during the output pulse period.
enable1, enable2 (bit rw)::
 Trigger enable for timer1 and timer2 respectively True to enable.
reset1, reset2 (bit rw)::
 If true, resets timer1 and timer2 respectively, aborting any pulse in progress.
out1,out2 (bit ro)::
 Pulse output status bits for timer1 and timer2.
exttrigger1, exttrigger2 (bit ro)::
 External trigger input status bits for timer1 and timer2.
 These monitor the filtered inputs.
swtrigger1, swtrigger2 (bit rw)::
 Software trigger inputs to trigger timer1 and timer2.

=== periodm

The periodm is a period/width/duty cycle measuring module. It can
measure period, frequency, pulse width and duty cycle. It can also
average readings for noise filtering.

*Pins:*

period_us (float r)::
 Input period in microseconds.
width_us (float r)::
 Input pulse width in microseconds.
duty_cycle (float r)::
 Input duty cycle (width/period) scaling and offset are changeable.
duty_cycle_scale (float rw)::
 Sets the scale of the duty cycle value, default is 100.
duty_cycle_offset (float rw)::
 Sets an offset to the duty cycle value, added after scaling. Default is 0.

averages (float rw):: Number of periods/widths to average.
 From 1 to 4095. Update rate of period, width, duty cycle, and frequency will be input frequency/averages.

frequency (float r):: Input frequency in Hz.

minimum_frequency (float w):: Minimum input frequency in Hz,
 if input frequency is lower than this threshold, the valid bit will be cleared.
filtertc_us (float w)::
 The periodm input in conditioned with a digital filter for noise rejection.
 The time constant of this filter is settable via this pin in units of microseconds.
 Pulses shorter than this time constant will not be recognized.
valid (bit out)::
 The valid output bit is true when the input signal is present and the
 input frequency exceeds the minimum frequency setting.
invert (bit in)::
 The invert bit sets the input polarity, when false, the input is
 direct which means the input high time determines the width.
 When set true, the input is inverted so the input low time determines the width.
input_status (bit out)::
 The input_status bit reads the real time filtered input status (affected by invert pin).

=== rcpwmgen

The rcpwmgen is a simple PWM generator optimized for use with standard
RC servos that use pulse width to determine position. rcpwmgens have
names like "**hm2_**_<BoardType>_**.**_<BoardNum>_**.rcpwmgen.**_<Instance>_" where
_<Instance>_ is a 2-digit number.
There will be __num_rcpwmgens__-many instances, starting at 00.
Each instance allocates a single output pin. Unlike the standard PWM generator,
the rcpwmgen output is specified in width rather than duty cycle so the pulse
width is independent of the operating frequency.
Resolution is approximately 1/2000 for standard 1 to 2&#8201;ms range RC servos.

*Pins:*

rate (float rw):: Sets the master RC PWM frequency.
 Maximum is 1 kHz, minimum is 0.01 Hz.  Defaults to 50&#8201;Hz.
width (float rw):: Sets the per channel pulse width in (ms/scale).
offset (float rw):: Sets the per channel pulse width offset in ms.
 This would be set to 1.5 ms for 1-2 ms servos for a 0 center position.
scale (float rw):: Sets the per channel pulse width scaling.
 For example, setting the scale to 90 and the offset to 1.5&#8201;ms would result in a position range
 of +-45 degrees and scale in degrees for 1-2&#8201;ms servos with a full motion range of 90 degrees.

=== stepgen

stepgens have names like "**hm2_**_<BoardType>_**.**_<BoardNum>_**.stepgen.**_<Instance>_".
__<Instance>__ is a two-digit number that corresponds to the HostMot2 stepgen instance number.
There are "num_stepgens"-many instances, starting with 00.

So, for example, the HAL pin that has the current position feedback from
the first stepgen of the second 5I22 board is: `hm2_5i22.1.stepgen.00.position-fb`
(this assumes that the firmware in that board is configured so that this HAL object is available).

Each stepgen uses between 2 and 8 I/O pins.
The signals on these pins depends on the step_type parameter (described below).

The stepgen representation is modeled on the stepgen software component.
Each stepgen instance has the following pins and parameters:

*Pins:*

position-cmd (float input):: Target position of stepper motion, in arbitrary position units.
 This pin is only used when the stepgen is in position control mode (control-type=0).
velocity-cmd (float input)::
 Target velocity of stepper motion, in arbitrary position units per second.
 This pin is only used when the stepgen is in velocity control mode (control-type=1).

counts (s32 output):: Feedback position in counts (number of steps).

position-fb (float output):: Feedback position in scaled position units.
 This is similar to "counts/position_scale", but has finer than step resolution.

position-latched (float output):: latched-position in scaled position units.
 This is similar to "counts/position_scale", but has finer than step resolution.

velocity-fb (float output):: Feedback velocity in arbitrary position units per second.

enable (bit input):: This pin enables the step generator instance.
 When True, the stepgen instance works as expected.
 When False, no steps are generated and velocity-fb goes immediately to 0.
 If the stepgen is moving when enable goes False it stops immediately, without obeying the maxaccel limit.
position-reset (bit input):: Resets position to 0 when True.
 Useful for step/dir controlled spindles when switching between spindle and joint modes.
control-type (bit input)::
 Switches between position control mode (0) and velocity control mode (1).
 Defaults to position control (0).
index-enable (bit in/out)::
 When this pin is set to True, the step count (and therefore also
 position) are reset to zero on the next stepgen index pulse.
 At the same time, index-enable is reset to zero to indicate that the pulse has occurred.
index-invert (bit r/w)::
 If set to True, the rising edge of the index input pin triggers the
 position clear event (if index-enable is True).
 If set to False, the falling edge triggers.
probe-enable (bit in/out)::
 When this pin is set to True, the step count (and therefore also
 position) are latched on the the next stepgen probe active edge.
 At the same time, probe-enable is reset to zero to indicate that a latch
 event has occurred.
probe-invert (bit r/w)::
 If set to True, the rising edge of the probe input pin triggers the
 latch event (if probe-enable is True).
 If set to False, the falling edge triggers.

*Parameters:*

position-scale (float r/w)::
 Converts from counts to position units. position = counts / position_scale
maxvel (float r/w)::
 Maximum speed, in position units per second. If set to 0, the driver
 will always use the maximum possible velocity based on the current
 step timings and position-scale. The max velocity will change if the
 step timings or position-scale changes. Defaults to 0.
maxaccel (float r/w)::
 Maximum acceleration, in position units per second per second.
 Defaults to 1.0. If set to 0, the driver will not limit its
 acceleration at all. This requires that the position-cmd or
 velocity-cmd pin is driven in a way that does not exceed the machine's
 capabilities. This is probably what you want if you are going to be
 using the LinuxCNC trajectory planner to jog or run G-code.
steplen (u32 r/w)::
 Duration of the step signal, in nanoseconds.
stepspace (u32 r/w)::
 Minimum interval between step signals, in nanoseconds.
dirsetup (u32 r/w)::
 Minimum duration of stable Direction signal before a step begins, in nanoseconds.
dirhold (u32 r/w)::
 Minimum duration of stable Direction signal after a step ends, in nanoseconds.
step_type (u32 r/w)::
 Output format, like the step_type modparam to the software stepgen(9)
 component: 0 = Step/Dir, 1 = Up/Down, 2 = Quadrature, 3+ = table-lookup mode.
 In this mode the step_type parameter determines how long the step sequence is.
 Additionally the stepgen_width parameter in the loadrt config string
 must be set to suit the number of pins per stepgen required.
 Any stepgen pins above this number will be available for GPIO.
 This mask defaults to 2. The maximum length is 16.
 Note that Table mode is not enabled in all firmwares but if you see GPIO pins
 between the stepgen instances in the dmesg/log hardware pin list then
 the option may be available.

In Quadrature mode (step_type=2), the stepgen outputs one complete Gray
cycle (00 → 01 → 11 → 10 → 00) for each "step" it takes, so the scale
must be divided by 4 relative to standard step/dir. In table mode,
up to 6 I/O pins are individually controlled in an arbitrary sequence up to 16 phases long.

swap_step_dir (bit input)::
 This swaps the step and direction outputs on the selected stepgen.
 This parameter is only available if the firmware supports this option.
table-data-__N__ (u32 r/w)::
 There are 4 table-data-__N__ parameters, table-data-0 to table-data-3.
 These each contain 4 bytes corresponding to 4 stages in the step
 sequence. For example table-data-0 = 0x00000001 would set stepgen pin
 0 (always called "Step" in the dmesg output) on the first phase of the
 step sequence, and table-data-4 = 0x20000000 would set stepgen pin 6
 ("Table5Pin" in the dmesg output) on the 16th stage of the step sequence.
hm2_XXXX.__N.__stepgen.timer-number (default: -1) (s32 r/w)::
 Sets the hm2dpll timer instance to be used to latch stepgen counts.
 A setting of -1 does not latch stepgen counts.
 A setting of 0 latches at the same time as the main hostmot2 read.
 A setting of 1..4 uses a time offset from the main hostmot2 read
 according to the dpll's timer-us setting.

Typically, timer-us should be a negative number with a magnitude larger
than the largest latency (e.g., -100 for a system with mediocre latency,
-50 for a system with good latency). A negative number specifies
latching the specified time before the nominal hostmot2 read time.

If no DPLL module is present in the FPGA firmware, or if the stepgen
module does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.
Doing so generally reduces following errors.

=== Smart Serial Interface

The Smart Serial Interface allows up to 32 different devices such as the
Mesa 8i20 2.2 kW 3-phase drive or 7I64 48-way I/O cards to be connected to a single FPGA card.
The driver auto-detects the connected hardware port, channel and device type.
Devices can be connected in any order to any active channel of an active port (see the config modparam definition above).

For full details of the smart-serial devices see *sserial*(9).

=== BSPI

The BSPI (Buffered SPI) driver is unusual in that it does not create any HAL pins.
Instead the driver exports a set of functions that can be used by a sub-driver for the attached hardware.
Typically, these would be written in the "comp".

Pre-processing language: see https://linuxcnc.org/docs/html/hal/comp.html or man halcompile for further details.
See mesa_7i65(9) and the source of mesa_7i65.comp for details of a typical sub-driver.
See hm2_bspi_setup_chan(3hm2), hm2_bspi_write_chan(3hm2), hm2_tram_add_bspi_frame(3hm2), hm2_allocate_bspi_tram(3hm2),
hm2_bspi_set_read_function(3hm2) and hm2_bspi_set_write_function(3hm2) for the exported functions.

The names of the available channels are printed to standard output
during the driver loading process and take the form
**hm2_**__<board name>__**.**__<board index>__**.bspi.**__<index>__, e.g., `hm2_5i23.0.bspi.0`.

=== UART

The UART driver also does not create any HAL pins, instead it declares two simple
read/write functions and a setup function to be utilised by user-written code.
Typically this would be written in the "comp" pre-processing language:
see https://linuxcnc.org/docs/html/hal/comp.html or man halcompile for further details.
See mesa_uart(9) and the source of mesa_uart.comp for details of a typical sub-driver.
See hm2_uart_setup_chan(3hm2), hm2_uart_send(3hm2), hm2_uart_read(3hm2) and hm2_uart_setup(3hm2).

The names of the available uart channels are printed to standard output
during the driver loading process and take the form **hm2_**__<board name>__**.**__<board index>__**.uart.**__<index>__, e.g., `hm2_5i23.0.uart.0`.

=== General Purpose I/O

I/O pins on the board which are not used by a module instance are
exported to HAL as "full" GPIO pins. Full GPIO pins can be configured at
run-time to be inputs, outputs, or open drains, and have a HAL interface
that exposes this flexibility. I/O pins that are owned by an active
module instance are constrained by the requirements of the owning
module, and have a restricted HAL interface.

GPIOs have names like "**hm2_**__<BoardType>__**.**__<BoardNum>__**.gpio.**__<IONum>__".
__<IONum>__ is a three-digit number. The mapping from __<IONum>__ to connector and
pin-on-that-connector is written to the syslog when the driver loads,
and it is documented in Mesa's manual for the Anything I/O boards.

So, for example, the HAL pin that has the current inverted input value
read from GPIO 012 of the second 7I43 board is:
`hm2_7i43.1.gpio.012.in-not` (this assumes that the firmware in that board
is configured so that this HAL object is available).

The HAL parameter that controls whether the last GPIO of the first 5I22
is an input or an output is: `hm2_5i22.0.gpio.095.is_output` (this assumes
that the firmware in that board is configured so that this HAL object is available).

The hm2 GPIO representation is modeled after the Digital Inputs and
Digital Outputs described in the Canonical Device Interface (part of the
HAL General Reference document).
Each GPIO can have the following HAL Pins:

in & in_not (bit out)::
 State (normal and inverted) of the hardware input pin. Both full GPIO
 pins and I/O pins used as inputs by active module instances have these pins.
out (bit in)::
 Value to be written (possibly inverted) to the hardware output pin.
 Only full GPIO pins have this pin.

Each GPIO can have the following Parameters:

is_output (bit r/w)::
 If set to 0, the GPIO is an input. The I/O pin is put in a
 high-impedance state (weakly pulled high), to be driven by other
 devices. The logic value on the I/O pin is available in the "in" and
 "in_not" HAL pins. Writes to the "out" HAL pin have no effect. If this
 parameter is set to 1, the GPIO is an output; its behavior then
 depends on the "is_opendrain" parameter.
 Only full GPIO pins have this parameter.
is_opendrain (bit r/w)::
 This parameter only has an effect if the "is_output" parameter is True.
 If this parameter is False, the GPIO behaves as a normal output pin:
 The I/O pin on the connector is driven to the value specified by
 the "out" HAL pin (possibly inverted), and the value of the "in" and
 "in_not" HAL pins is undefined. If this parameter is True, the GPIO
 behaves as an open-drain pin. Writing 0 to the "out" HAL pin drives
 the I/O pin low, writing 1 to the "out" HAL pin puts the I/O pin in a
 high-impedance state. In this high-impedance state the I/O pin floats
 (weakly pulled high), and other devices can drive the value; the
 resulting value on the I/O pin is available on the "in" and "in_not"
 pins. Only full GPIO pins and I/O pins used as outputs by active module
 instances have this parameter.
invert_output (bit r/w)::
 This parameter only has an effect if the "is_output" parameter is True.
 If this parameter is True, the output value of the GPIO will be
 the inverse of the value on the "out" HAL pin. Only full GPIO pins and
 I/O pins used as outputs by active module instances have this parameter.

When a physical I/O pin is used by a special function, the related
*is_output*, and *is_opendrain* HAL parameters are aliased to the
special function. For instance, if gpio 1 is taken over by pwmgen 0's
first output, then aliases like
`hm2_7i92.0.pwmgen.00.out0.invert_output` (referring to
`hm2_7i92.0.gpio.001.invert_output`) will be automatically created. When
more than one GPIO is connected to the same special function,
an extra **.**_#_**.** is inserted so that the settings for each related GPIO can be set separately.
For example, for the firmware SV12IM_2X7I48_72, the aliases
`hm2_5i20.0.pwmgen.00.0.enable.invert_output` (referring to `hm2_5i20.0.gpio.000.invert_output`) and
`hm2_5i20.0.pwmgen.00.1.enable.invert_output` (referring to `hm2_5i20.0.gpio.023.invert_output`) are both created.

=== inm and inmux

inm/inmuxs are input debouncing modules that support hardware digital
filtering of input pins. In addition to the input filtering function,
the inm/inmux modules support up to 4 simple quadrature counters for MPG
use. The quadrature inputs for MPG encoders 0 through 3 are inm/inmux
pins 0 through 7. MPG A,B inputs use the filter time constants
programmed for inputs 0..7. Each inm/inmux input pin can have a slow or
fast filter constant. Filter time constants are specified in units of
scan times. inms have names like
"**hm2_**_<BoardType>_**.**_<BoardNum>_**.inm.**_<Instance>_". inmuxes have names
like "**hm2_**_<BoardType>_**.**_<BoardNum>_**.inmux.**_<Instance>_".
"Instance" is a two-digit number that corresponds to the HostMot2 inm or inmux instance number.
There are "num_inms" or numx_inmuxs" instances, starting with 00.

Each instance reads between 8 and 32 input pins. inm and inmux are
identical except for pin names and the physical interface.

*Pins:*

input and input-not (bit out):: True and inverted filtered input states.
raw-input and raw-input-not (bit out):: True and inverted unfiltered input states.
input-slow (bit in)::
 If True, selects the long time constant filter for the corresponding
 input bit, if False the short time constant is used.

enc0-count,enc1-count,enc2-count,enc3-count (s32 out)::
 MPG counters 0 through 3.
enc0-reset,enc1-reset,enc2-reset,enc3-reset (bit in)::
 Reset for MPG counters 0 through 3, count is forced to 0 if true.

*Parameters:*

scan_rate (u32 in)::
 This sets the input scan rate in Hz. Default scan rate is 20 kHz (50 µs scan period).
fast_scans (u32 in)::
 This sets the fast time constant for all input pins.
 This is the time constant used when the input-slow pin for the corresponding input is False.
 The range is 0 to 63 scan periods and the default value is 5 = 250&#8201;µs at the default 20&#8201;kHz scan_rate.
slow_scans (u32 in)::
 This sets the slow time constant for all input pins.
 This is the time constant used when the input-slow pin for the corresponding input is True.
 The range is 0 to 1023 scan periods and the default value is 500 = 25&#8201;ms at the default 20&#8201;kHz scan_rate.
enc0_4xmode, enc1_4xmode, enc2_4xmode, and enc3_4xmode (bit in)::
 These set the MPG encoder operating modes to 4X when True and 1X when False.
scan_width (u32 out)::
 This read only parameter specifies the number of inputs scanned by the module.

=== led

Creates HAL pins for the LEDs on the FPGA board.

*Pins:*

**CR**__<NN>__ (bit in)::
 The pins are numbered from CR01 upwards with the name corresponding to
 the PCB silkscreen. Setting the bit to "True" or 1 lights the LED.

=== Solid State Relay

SSRs have names like "**hm2_**_<BoardType>_**.**_<BoardNum>_**.ssr.**_<Instance>_".
_Instance_ is a two-digit number that corresponds to the HostMot2 SSR
instance number. There are __num_ssrs__ instances, starting with 00.

Each instance has a rate control pin and between 1 and 32 output pins.

**Pins:**

rate (u32 in)::
 Set the internal frequency of the SSR instance, in Hz (approximate).
 The valid range is 25 kHz to 25 MHz. Values below the minimum will use
 the minimum, and values above the max will use the max. 1 MHz is a
 typical value, and appropriate for all Mesa cards, and is the default.
 Set to 0 to disable this SSR instance.
out-NN (bit in)::
 The state of this SSR instance's NNth output. Set to 0 to make the
 output pins act like an open switch (no connection), set to 1 to make
 them act like a closed switch.
invert-NN (bit in)::
 Inverts the state of this SSR instance's NNth output, defaults to 0.
 When invert-NN is set to 1, SSR output NN is closed when the out-NN
 pin is 0 and open when the out-NN pin is 1.

== OutM Simple output module

OutMs have names like
"**hm2_**_<BoardType>_**.**_<BoardNum>_**.OutM.**_<Instance>_". _Instance_ is a
two-digit number that corresponds to the HostMot2 OutM instance number.
There are __num_outms__ instances, starting with 00.

Each instance has between 1 and 32 output pins.

**Pins:**

out-NN (bit in)::
 The sets the state of this OutM instance's NNth output. Normally the
 output pin follows the state of this pin but may be inverted by the
 invert-nn HAL pin.
invert-NN (bit in)::
 Inverts the state of the this OutM instance's NNth output, defaults to 0.
 When invert-NN is set to 1, OutM output NN is high when the out-NN
 pin is 0 and low when the out-NN pin is 1.

== xy2mod

The xy2mod is a xy2-100 galvanometer interface. It supports 16 and 18
bit data modes and includes parabolic interpolation to provide position
updates between servo thread invocations.

**Pins:**

posx_cmd, posy_cmd (float in):: X and Y position commands.
 Full scale is +-posn_scale default full scale (set by posx_scale and posy_scale) is +- 1
posx_fb, posy_fb (float out):: X and Y position feedback.
 Full scale is +-posN_scale default full scale is +- 1.
 This is feedback from the interpolator not the galvanometer.
velx_cmd, vely_cmd (float in):: X and Y velocity commands in units of fullscale_position/second
velx_fb, vely_fb (float out):: X and Y velocity feedback in units of fullscale_position/second
accx_cmd, accy_cmd (float in):: X and Y acceleration commands in units of fullscale_position/second^2^
posx_scale, posy_scale (float in):: This sets the full scale range of the position command and feedback, default is +- 1.0.
enable (bit in)::
 When False, output data is 0, all interpolator values are set to 0 and overflow flags are cleared.
 Must be True for normal operation.

controlx, controly (u32 in):: These set the galvanometer control bits.
 There 3 bits per channel in 16 bit mode but just 1 control bit in 18 bit mode,
 so values from 0..7 are valid in 16 bit mode but only 0 and 4 are valid in 18 bit mode.
commandx, commandy (u32 in)::
 These set the raw 16 bit data sent to the galvanometer in command mode.
commandmodex, commandmodey (bit in)::
 When set, these enable the command mode where 16 bit command data is sent to the galvanometer.
18bitmodex, 18bitmodey (bit in)::
 When True, these enable the 18 bit data mode for the respective channel.
posx-overflow, posy-overflow (bit out)::
 When true, these indicate an attempted position move beyond the full scale value.
velx-overflow, vely-overflow (bit out)::
 When True, these indicate an attempted velocity update move beyond the full scale value.

status (u32 out):: Raw 16 bit return status from galvanometer.

*Parameters:*

read-timer-number (s32 in)::
 Selects the DPLL timer number for pre-read sampling of the position and velocity registers.
 If set to -1, pre-read sampling is disabled.
write-timer-number (s32 in)::
 Selects the DPLL timer number for post write update of the position and velocity registers.
 If set to -1, post write update is disabled.

=== Watchdog

The HostMot2 firmware may include a watchdog Module; if it does, the
hostmot2 driver will use it. The HAL representation of the watchdog is
named "**hm2_**_<BoardType>_**.**_<BoardNum>_**.watchdog**".

The watchdog starts out asleep and inactive. Once you access the board
the first time by running the hm2 write() HAL function (see below), the
watchdog wakes up. From them on it must be petted periodically or it
will bite. Pet the watchdog by running the hm2 write() HAL function.

When the watchdog bites, all the board's I/O pins are disconnected from
their Module instances and become high-impedance inputs (pulled high),
and all communication with the board stops. The state of the HostMot2
firmware modules is not disturbed (except for the configuration of the
I/O pins). Encoder instances keep counting quadrature pulses, and pwm-
and step-generators keep generating signals (which are *not* relayed to
the motors, because the I/O pins have become inputs).

Resetting the watchdog (by clearing the has_bit pin, see below) resumes
communication and resets the I/O pins to the configuration chosen at load-time.

If the firmware includes a watchdog, the following HAL objects will be exported:

*Pins:*

has_bit (bit in/out)::
 True if the watchdog has bit, False if the watchdog has not bit.
 If the watchdog has bit and the has_bit bit is True, the user can reset
 it to False to resume operation.

*Parameters:*

timeout_ns (u32 read/write)::
 Watchdog timeout, in nanoseconds.
 This is initialized to 5,000,000 (5 milliseconds) at module load time.
 If more than this amount of time passes between calls to the hm2 write() function, the watchdog will bite.

=== Raw Mode

If the "enable_raw" config keyword is specified, some extra debugging
pins are made available in HAL. The raw mode HAL pin names begin with
"**hm2_**_<BoardType>_**.**_<BoardNum>_**.raw**".

With Raw mode enabled, a user may peek and poke the firmware from HAL,
and may dump the internal state of the hostmot2 driver to the syslog.

*Pins:*

read_address (u32 in)::
 The bottom 16 bits of this is used as the address to read from.
read_data (u32 out)::
 Each time the hm2_read() function is called, this pin is updated with the value at .read_address.
write_address (u32 in)::
 The bottom 16 bits of this is used as the address to write to.
write_data (u32 in)::
 This is the value to write to .write_address.
write_strobe (bit in)::
 Each time the hm2_write() function is called, this pin is examined. If
 it is True, then value in .write_data is written to the address in
 .write_address, and .write_strobe is set back to False.

dump_state (bit in/out):: This pin is normally False.  If it gets set to True,
 the hostmot2 driver will write its representation of the board's internal state to the syslog,
 and set the pin back to False.

=== Setting up Smart Serial devices

See setsserial(9) for the current way to set smart-serial eeprom parameters.

== FUNCTIONS

**hm2_**_<BoardType>_**.**_<BoardNum>_**.read-request**::
 On boards with long turn around time for reads (at the time of
 writing, this applies only to ethernet boards), this function sends a
 read request. When multiple boards are used, this can reduce the servo
 thread execution time. In this case, the appropriate thread order would be

....
addf hm2_7i80.0.read-request
addf hm2_7i80.1.read-request
addf hm2_7i80.0.read
addf hm2_7i80.1.read
....

which causes the read request to be sent to board 1 before waiting for
the response to the read request to arrive from board 0.

**hm2_**_<BoardType>_**.**_<BoardNum>_**.read**::
 This reads the encoder counters, stepgen feedbacks, and GPIO input pins from the FPGA.
**hm2_**_<BoardType>_**.**_<BoardNum>_**.write**::
 This updates the PWM duty cycles, stepgen rates, and GPIO outputs on
 the FPGA. Any changes to configuration pins such as stepgen timing,
 GPIO inversions, etc., are also effected by this function.
**hm2_**_<BoardType>_**.**_<BoardNum>_**.read_gpio**::
 Read the GPIO input pins. Note that the effect of this function is a
 subset of the effect of the .read() function described above. Normally
 only .read() is used. The only reason to call this function is if you
 want to do GPIO things in a faster-than-servo thread.
 (This function is not available on the 7I43 due to limitations of the EPP bus.)
**hm2_**_<BoardType>_**.**_<BoardNum>_**.write_gpio**::
 Write the GPIO control registers and output pins. Note that the effect
 of this function is a subset of the effect of the .write() function
 described above. Normally only .write() is used. The only reason to
 call this function is if you want to do GPIO things in a faster-than-servo thread.
 (This function is not available on the 7I43 due to limitations of the EPP bus.)
**hm2_**_<BoardType>_**.**_<BoardNum>_**.trigger-encoders**::
 This function will only appear if the firmware contains a BiSS, Fanuc
 or SSI encoder module and if the firmware does not contain a hm2dpll
 module (qv) or if the modparam contains num_dplls=0.
 This function should be inserted first in the thread so that the encoder data is
 ready when the main *hm2_*_XXXX_*.*_NN_*.read* function runs.
 An error message will be printed if the encoder read is not finished in time.
 It may be possible to avoid this by increasing the data rate.
 If the problem persists and if "stale" data is acceptable then the function
 may be placed later in the thread, allowing a full servo cycle for the
 data to be transferred from the devices.
 If available it is better to use the synchronous hm2dpll triggering function.

== SEE ALSO

hm2_pci(9), hm2_eth(9), hm2_spi(9), hm2_rpspi(9), hm2_7i43(9), hm2_7i90(9)

Mesa's documentation for the Anything I/O boards, at https://www.mesanet.com.

== LICENSE

GPL
