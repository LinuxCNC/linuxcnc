[[cha:qtscreen]]

= QTscreen

QTscreen is an infrastructure to display a custom screen or VCP panel in LinuxCNC. +
It displays a UI file built with the QTDesigner screen editor or combines this +
with python programming to create a GUI screen for running a CNC machine. +
QTscreen is customizable - you can add different buttons and status LEDs etc. +

.QT_cnc - 3 Axis Sample
image::images/qt_cnc.png["QTscreen Mill",align="left"]

= QTvcp Widgets

Qtscreen uses QTvcp widgets for linuxcnc integration.
Widget is the general name for the UI objects such as buttons and labels in QTpy4. +
You are free to use any available widgets in the QTDesigner editor. +
There are also special widgets made for linuxcnc that make integration easier. +
This are split in three heading on the left side of the editor. +
One is for HAL only widgets. +
One is for cnc control widgets. +
One is for dialog widgets. +
you are free to mix them in any way on your panel. +
A very important widget is the screenoptions widget. It does not add anything visually to the screen. +
But allows important details to be selected rather then be coded in the handler file. +

= Overview

There are two files that can be used, individually or in combination to add +
customization. Normally QTscreen uses the stock UI and handler file. +
You can specify QTscreen to use 'local' UI and handler files. +
One is not restricted to adding a custom panel on the right or a custom tab. +
QTscreen leverages 'QT Designer' (the editor) and 'PyQT5' (the widget toolkit). +
QTvcp has some special widgets and actions added just for LinuxCNC. +

== INI Settings

If you are using this to make a CNC control screen: +
Under the [DISPLAY] heading:

----
DISPLAY = qtscreen <screen_name>
  options:
    -d debugging on
    -a set window always on top
    -c HAL component name. Default is to use the UI file name.
    -g geometry: WIDTHxHEIGHT+XOFFSET+YOFFSET
    -m maximise window
    -f fullscreen the window
    -t theme. Default is system theme
    <screen_name> is the base name of the .ui and _handler.py files.
    If <screen_name> is missing the default screen will be loaded.
----
QTscreen assumes the UI file and the handler file use this same base name. +
QTscreen will search the LinuxCNC configuration file that was launched first for the files,  +
then in the system skin folder. the skin folders holds standard screens. +


== QTDesigner UI File

A designer file is a text file organized in the XML standard that describes the +
layout and the widgets of the screen. Pyqt5 uses this file to build the display +
and react to those widgets. The QTDesigner editor makes it relatively easy to build +
and edit this file. +

== Handler Files

A handler file is a file containing python code, which QTscreen adds to it's +
default routines. A handler file allows one to modify defaults, or add logic +
to a QTscreen skin without having to modify QTscreen proper.  +
If present a handler file will be loaded. +
Only one file is allowed. QTscreen looks for the handler file. +
In this way you can have custom behaviour. +
Here is a sample handler file. +
It's broken up in sections for ease of discussion. +

[source,python]
----
############################
# **** IMPORT SECTION **** #
############################

from PyQt5 import QtCore
from PyQt5 import QtWidgets
from qtvcp.lib.keybindings import Keylookup
from qtvcp.core import Status
import linuxcnc
import sys
import os

###########################################
# **** instantiate libraries section **** #
###########################################

KEYBIND = Keylookup()
STATUS = Status()

###################################
# **** HANDLER CLASS SECTION **** #
###################################

class HandlerClass:

    ########################
    # **** INITIALIZE **** #
    ########################
    # widgets allows access to  widgets from the qtvcp files
    # at this point the widgets and hal pins are not instantiated
    def __init__(self, halcomp,widgets,paths):
        self.hal = halcomp
        self.w = widgets
        self.stat = linuxcnc.stat()
        self.cmnd = linuxcnc.command()
        self.jog_velocity = 10.0

        # connect to GStat to catch linuxcnc events
        STATUS.connect('state-on', self.on_state_on)
        STATUS.connect('state-off', self.on_state_off)

    #######################################
    # **** Special Functions SECTION **** #
    #######################################

    # at this point:
    # the widgets are instantiated.
    # the HAL pins are built but HAL is not set ready
    # you could still make arbritrary HAL pins here
    def initialized__(self):
        STATUS.forced_update()

    def processed_key_event__(self,receiver,event,is_pressed,key,code,shift,cntrl):
        # when typing in MDI, we don't want keybinding to call functions
        # so we catch and process the events directly.
        # We do want ESC, F1 and F2 to call keybinding functions though
        if code not in(QtCore.Qt.Key_Escape,QtCore.Qt.Key_F1 ,QtCore.Qt.Key_F2,
                    QtCore.Qt.Key_F3,QtCore.Qt.Key_F5,QtCore.Qt.Key_F5):
            if isinstance(receiver, OFFVIEW_WIDGET) or \
                isinstance(receiver, MDI_WIDGET):
                if is_pressed:
                    receiver.keyPressEvent(event)
                    event.accept()
                return True
            elif isinstance(receiver, GCODE) and STATUS.is_man_mode() == False:
                if is_pressed:
                    receiver.keyPressEvent(event)
                    event.accept()
                return True
            elif isinstance(receiver,QtWidgets.QDialog):
                print 'dialog'
                return True
        try:
            KEYBIND.call(self,event,is_pressed,shift,cntrl)
            return True
        except Exception as e:
            print 'no function %s in handler file for-%s'%(KEYBIND.convert(event),key)
            return False


    #####################################
    # **** STATUS CALLBACKS SECTION **** #
    #####################################

    def on_state_on(self,w):
        print 'machine on'

    def on_state_off(self,w):
        print 'machine off'

    #####################################
    # **** QTFORM CALLBACK SECTION **** #
    #####################################

    def zero_axis(self):
        name = self.w.sender().text()
        print name
        if 'X' in name:
            STATUS.set_axis_origin('x',0)
        elif 'Y' in name:
            STATUS.set_axis_origin('y',0)
        elif 'Z' in name:
            STATUS.set_axis_origin('z',0)

    #######################################
    # **** GENERAL FUNCTIONS SECTION **** #
    #######################################

    def continous_jog(self, axis, direction):
        STATUS.continuous_jog(axis, direction)

    #################################
    # **** KEY BINDING SECTION **** #
    #################################
    def on_keycall_ESTOP(self,event,state,shift,cntrl):
        if state:
            self.w.button_estop.click()
    def on_keycall_POWER(self,event,state,shift,cntrl):
        if state:
            self.w.button_machineon.click()
    def on_keycall_HOME(self,event,state,shift,cntrl):
        if state:
            self.w.button_home.click()

    ###########################
    # **** CLOSING EVENT **** #
    ###########################
    def closeEvent(self, event):
        event.accept()

    ##############################
    # required class boiler code #
    ##############################

    def __getitem__(self, item):
        return getattr(self, item)
    def __setitem__(self, item, value):
        return setattr(self, item, value)

################################
# required handler boiler code #
################################

def get_handlers(halcomp,widgets,paths):
     return [HandlerClass(halcomp,widgets,paths)]
----
== Libraries modules
Qtscreen as built does little more then display the screen and react to widgets. +
For more prebuilt behaviours there are available libraries. +
(found in lib/python/qtvcp/lib in RIP linuxcnc install) +
libraries are prebuilt python modules that give added features to QTvcp. +
In this way you can select what features you want - yet don't have to build common ones yourself. +
Such libraries include: +

audio_player +
aux_program_loader +
keybindings +
message +
preferences +
notify +
virtual_keyboard +

== Themes

Themes are a way to modify the look and feel of the widgets on the screen. +
For instance the color or size of buttons and sliders can be changed using
themes. +
The Windows theme is default for screens. System theme is default for panels. +
to see available themes load qtscreen with -d -t SHOWTHEMES +

Qtscreen can also be customized with Qt stylesheets using css. +

=== Local Files

If present, local UI files in the configuration folder will be loaded instead +
of the stock UI files. Local UI files allow you to use your customized +
designs rather then the default screens. +
QTscreen will look for MYNAME.ui and MYNAME_handler.py in the launched configuration folder. +


=== Modifying Stock Screens

If you wish to modify a stock screen, copy it's UI and handler file to your configuration folder. +


== Build a simple clean-sheet custom screen

=== Overview

To build a panel or screen use QTDesigner to build a design you like. +
Save this design to your configuration folder with a name of your choice, ending with .ui +
modify the configurations INI file to load Qtscreen with your new .ui file. +
Then connect any required HAL pins in a HAL file +

=== Get Designer to include linuxcnc widgets

TODO +
- how to get widget loading library +
- where to put the library
- how to get the library to find the widgets +
- commands to launch designer with QT5 +


=== build the screen .ui file

When Designer is first started there is a 'New Form' dialog displayed. +
Pick 'Main Window' and press the 'create' button. +
Do not rename this window - Qtvcp requires the name to be 'MainWindow' +
 +
A mainwindow widget is Displayed. Grab the corner of the window and resize to +
an appropriate size say 1000x600. right click on the window and click +
set minimum size. Do it again and set maximum size.Our sample widget will +
now not be resizable. +
 +
Drag and drop the screenoption widget onto the main window (anywhere). +
This widget doesn't add anything visually but sets up some common options. +

Drag and drop a FileDialog widget on the window anywhere. +
This will show the dialog and we want it hidden. +
On the right hand side there is a panel with tabs for a Property editor and +
an object inspector. On the Object inspector click on the FileDialog. then +
switch switch to the property Editor. Under the heading 'FileDialog' toggle +
'State' until the dialog disappears. +

Drag and drop a GCodeGraphics widget and a GcodeEditor widget. +
Place and resize them as you see fit leaving some room for buttons. +

Now we will add action buttons. +
Add 7 action buttons on to the main window. If you double click the button, you +
can add text. Edit the button labels for 'Estop', 'Machine On', 'Home', 'Load', +
'Run', + 'Pause' and 'stop'. +
Action buttons default to Estop action so we must change the the other buttons. +
Select the 'Machine On' button. Now go to the 'Property Editor' on the right +
side of Designer. Scroll down until you find the 'ActionButton' heading. +
You will see a list of properies and values. find the 'machine on action' and +
click the checkbox. the button will now control machine on/off. +
Do the same for all the other button with the addition of: +

 - With the 'Home' button we must also change the joint_number property to -1, +
Which tells the controller to home all the axes rather then a specific axis. +

 - With the 'Pause' button under the heading 'Indicated_PushButton' check the +
'indicator_option' and under the 'QAbstactButton' heading check 'checkable'

.Qt Designer - Selecting Pause button's properties
image::images/designer_button_property.png["designer button property",align="left"]

We then need to save this design as 'tester.ui' in the sim/qtscreen folder +
We are saving it as tester as that is a file name that qtscreen recognizes and +
will use a built in handler file to display it. +

=== Handler file
a handler file is required. It allows customizations to be written in python. +
For instance keyboard controls are usually written in the handler file. +
 +
In this example the built in file 'tester_handler.py' is automatically used. +
It does the minimum required to display the tester.ui defined screen and do +
basic keyboard jogging. +

=== INI

If you are using Qtscreen to make a CNC control screen: +
Under the '[DISPLAY]' heading: +
 +
'DISPLAY = qtscreen <screen_name>' +
 +
'<screen_name>' is the base name of the .ui and _handler.py files. +

In our example there is already a sim configuration called tester, that we +
will use to display our test screen.

=== HAL

If your screen used widgets with HAL pins the you must connect then in a HAL file. +
Qtscreen looks under the heading '[HAL]' for the entry 'POSTGUI_HALFILE=<filename>' +
Typically '<filename>' would be the screens base name + '_postgui' + '.hal' +
eg. 'qtscreen_postgui.hal' +
These commands are executed after the screen is built, guaranteeing the widget HAL +
pins are available. +
 +
In our example there are no HAl pins to connect. +



