:lang: en
:toc:

[[cha:kinematics]]
= Kinematics

(((kinematics)))

== Introduction

When we talk about CNC machines, we usually think about machines that
are commanded to move to certain locations and perform various tasks.
In order to have an unified view of the machine space, and to make it
fit the human point of view over 3D space, most of the machines (if not
all) use a common coordinate system called the Cartesian Coordinate
System.

The Cartesian Coordinate system is composed of three axes (X, Y, Z) each
perpendicular to the other two footnote:[The word "axes" is also
commonly (and wrongly) used when talking about
CNC machines, and referring to the moving directions of the machine.].

When we talk about a G-code program (RS274/NGC) we talk about a number
of commands (G0, G1, etc.) which have positions as parameters (X- Y-
Z-). These positions refer exactly to Cartesian positions. Part of the
LinuxCNC motion controller is responsible for translating those positions
into positions which correspond to the machine
(((kinematics)))kinematics footnote:[Kinematics: a two way function to
transform from Cartesian space to joint space.].

=== Joints vs Axes

A joint of a CNC machine is a one of the physical degrees of freedom
of the machine. This might be linear (leadscrews) or rotary (rotary
tables, robot arm joints). There can be any number of joints on a
given machine. For example, one popular robot has 6 joints, and a
typical simple milling machine has only 3.

There are certain machines where the joints are laid out to match
kinematics axes (joint 0 along axis X, joint 1 along axis Y, joint 2
along axis Z), and these machines are called (((Cartesian machines)))
Cartesian machines (or machines with (((Trivial Kinematics)))Trivial Kinematics).
These are the most common machines used in milling,
but are not very common in other domains of machine control (e.g. welding: puma-typed robots).

LinuxCNC supports axes with names: X Y Z A B C U V W.  The X Y Z axes
typically refer to the usual Cartesian coordinates. The A B C axes refer to
rotational coordinates about the X Y Z axes respectively.  The U V W axes refer to
additional coordinates that are commonly made colinear to the X Y Z axes respectively.

== Trivial Kinematics

The simplest machines are those in which which each joint is placed
along one of the Cartesian axes. On these machines the mapping from
Cartesian space (the G-code program) to the joint space (the actual
actuators of the machine) is trivial. It is a simple 1:1 mapping:

----
pos->tran.x = joints[0];
pos->tran.y = joints[1];
pos->tran.z = joints[2];
----

In the above code snippet one can see how the mapping is done: the X
position is identical with the joint 0, the Y position with
joint 1, etc. The above refers to the direct kinematics (one
direction of the transformation).
The next code snippet refers to the inverse kinematics (or the
inverse direction of the transformation):

----
joints[0] = pos->tran.x;
joints[1] = pos->tran.y;
joints[2] = pos->tran.z;
----

In LinuxCNC, the identity kinematics are implemented with the
'trivkins' kinematics module and extended to 9 axes.  The default
relationships between axis coordinates and joint numbers are:
footnote:[If the machine (for example a lathe) is mounted with
only the X, Z and A axes and the INI file of LinuxCNC contains
only the definition of these 3 joints, then the previous assertion is false.
Because we currently have (joint0=X, joint1=Z, joint2=A) which
assumes that joint1=Y.
To make this work in LinuxCNC just define all the axes (XYZA),
LinuxCNC will then use a simple loop in HAL for unused Y axis.]
footnote:[Another way to make it work is to change the corresponding code and recompile the software.]

----
pos->tran.x = joints[0];
pos->tran.y = joints[1];
pos->tran.z = joints[2];
pos->a      = joints[3];
pos->b      = joints[4];
pos->c      = joints[5];
pos->u      = joints[6];
pos->v      = joints[7];
pos->w      = joints[8];
----

Similarly, the default relationships for inverse kinematics for trivkins are:

----
joints[0] = pos->tran.x;
joints[1] = pos->tran.y;
joints[2] = pos->tran.z;
joints[3] = pos->a;
joints[4] = pos->b;
joints[5] = pos->c;
joints[6] = pos->u;
joints[7] = pos->v;
joints[8] = pos->w;
----

It is straightforward to do the transformation for a trivial "kins" ('trivkins'
kinematics) or Cartesian machine provided that there are no omissions in the
axis letters used.

It gets a bit more complicated if the machine is missing one or more of the
axis letters.  The problems of omitted axis letters is addressed by using the
'coordinates=' module parameter with the trivkins module. Joint numbers are
assigned consecutively to each coordinate specified.  A lathe can be described
with 'coordinates=xz' The joint assignments will then be:

----
joints[0] = pos->tran.x
joints[1] = pos->tran.z
----

Use of the 'coordinates=' parameter is recommended for configurations that omit
axis letters. footnote:[ Historically, the trivkins module did not support the
'coordinates=' parameter so lathe configs were often configured as XYZ
machines.  The unused Y axis was configured to 1) home immediately, 2) use a
simple loopback to connect its position command HAL pin to its position
feedback HAL pin, and 3) hidden in gui displays. Numerous sim configs use
these methods in order to share common HAL files.]

The 'trivkins' kinematics module also allows the same coordinate to be specified
for more than one joint.  This feature can be useful on machines like a gantry
having two independent motors for the y coordinate.  Such a machine could use
'coordinates=xyyz' resulting in joint assignments:

----
joints[0] = pos->tran.x
joints[1] = pos->tran.y
joints[2] = pos->tran.y
joints[3] = pos->tran.z
----

See the trivkins man pages for more information.

== Non-trivial kinematics

There can be quite a few types of machine setups (robots: puma, scara;
hexapods etc.). Each of them is set up using linear and rotary joints.
These joints don't usually match with the Cartesian coordinates,
therefore we need a kinematics function which does the
conversion (actually 2 functions: forward and inverse kinematics
function).

To illustrate the above, we will analyze a simple kinematics called
bipod (a simplified version of the tripod, which is a simplified
version of the hexapod).

.Bipod setup
image::images/bipod.png["Bipod setup",align="center"]

The Bipod we are talking about is a device that consists of 2 motors
placed on a wall, from which a device is hung using some wire. The
joints in this case are the distances from the motors to the device
(named AD and BD in the figure).

The position of the motors is fixed by convention. Motor A is in
(0,0), which means that its X coordinate is 0, and its Y coordinate is
also 0. Motor B is placed in (Bx, 0), which means that its X coordinate
is Bx.

Our tooltip will be in point D which gets defined by the distances AD
and BD, and by the Cartesian coordinates Dx, Dy.

The job of the kinematics is to transform from joint lengths (AD, BD)
to Cartesian coordinates (Dx, Dy) and vice-versa.

[[sec:Forward-transformation]]
=== Forward transformation

To transform from joint space into Cartesian space we will use some
trigonometry rules (the right triangles determined by the points (0,0),
(Dx,0), (Dx,Dy) and the triangle (Dx,0), (Bx,0) and (Dx,Dy)).

We can easily see that:

image::images/kinematics-math-01.png[align="center"]

likewise:

image::images/kinematics-math-02.png[align="center"]

If we subtract one from the other we will get:

image::images/kinematics-math-03.png[align="center"]

and therefore:

image::images/kinematics-math-04.png[align="center"]

From there we calculate:

image::images/kinematics-math-05.png[align="center"]

////////////////////////////////////////////////////////////////////
we can easily see that latexmath:[$AD^{2}=x^{2}+y^{2}$], likewise
latexmath:[$BD^{2}=(Bx-x)^{2}+y^{2}$].

If we subtract one from the other we will get:

latexmath::[\[AD^{2}-BD^{2}=x^{2}+y^{2}-x^{2}+2*x*Bx-Bx^{2}-y^{2}\]]

and therefore:

latexmath::[\[x=\frac{AD^{2}-BD^{2}+Bx^{2}}{2*Bx}\]]

From there we calculate:

latexmath::[\[y=\sqrt{AD^{2}-x^{2}}\]]
////////////////////////////////////////////////////////////////////

Note that the calculation for y involves the square root of a
difference, which may not result in a real number. If there is no
single Cartesian coordinate for this joint position, then the position
is said to be a singularity. In this case, the forward kinematics
return -1.

Translated to actual code:

----
double AD2 = joints[0] * joints[0];
double BD2 = joints[1] * joints[1];
double x = (AD2 - BD2 + Bx * Bx) / (2 * Bx);
double y2 = AD2 - x * x;
if(y2 < 0) return -1;
pos->tran.x = x;
pos->tran.y = sqrt(y2);
return 0;
----

=== Inverse transformation

The inverse kinematics is much easier in our example, as we can write
it directly:

image::images/kinematics-math-06.png[align="left"]

image::images/kinematics-math-07.png[align="left"]

/////////////////////////////////////////////////
latexmath::[\[AD=\sqrt{x^{2}+y^{2}}\]]

latexmath::[\[BD=\sqrt{(Bx-x)^{2}+y^{2}}\]]
/////////////////////////////////////////////////

or translated to actual code:

----
double x2 = pos->tran.x * pos->tran.x;
double y2 = pos->tran.y * pos->tran.y;
joints[0] = sqrt(x2 + y2);
joints[1] = sqrt((Bx - pos->tran.x)*(Bx - pos->tran.x) + y2);
return 0;
----

== Implementation details

A kinematics module is implemented as a HAL component, and is
permitted to export pins and parameters. It consists of several "C"
functions (as opposed to HAL functions):

----
int kinematicsForward(const double *joint, EmcPose *world,
const KINEMATICS_FORWARD_FLAGS *fflags,
KINEMATICS_INVERSE_FLAGS *iflags)
----

Implements the <<sec:Forward-transformation,forward kinematics function>>.

----
int kinematicsInverse(const EmcPose * world, double *joints,
const KINEMATICS_INVERSE_FLAGS *iflags,
KINEMATICS_FORWARD_FLAGS *fflags)
----

Implements the inverse kinematics function.

----
KINEMATICS_TYPE kinematicsType(void)
----

Returns the kinematics type identifier, typically 'KINEMATICS_BOTH':

. KINEMATICS_IDENTITY  (each joint number corresponds to an axis letter)
. KINEMATICS_BOTH      (forward and inverse kinematics functions are provided)
. KINEMATICS_FORWARD_ONLY
. KINEMATICS_INVERSE_ONLY

[NOTE]
GUIs may interpret KINEMATICS_IDENTITY to hide the distinctions
between joint numbers and axis letters when in joint mode
(typically prior to homing).

----
int kinematicsSwitchable(void)
int kinematicsSwitch(int switchkins_type)
KINS_NOT_SWITCHABLE
----

The function kinematicsSwitchable() returns 1 if multiple
kinematics types are supported.  The function kinematicsSwitch()
selects the kinematics type.
See <<cha:switchable-kinematics,Switchable Kinematitcs>>.

[NOTE]
The majority of provided kinematics modules support a single
kinematics type and use the directive "*KINS_NOT_SWITCHABLE*" to
supply defaults for the required kinematicsSwitchable() and
kinematicsSwitch() functions.

----
int kinematicsHome(EmcPose *world, double *joint,
KINEMATICS_FORWARD_FLAGS *fflags,
KINEMATICS_INVERSE_FLAGS *iflags)
----

The home kinematics function sets all its arguments to their proper
values at the known home position. When called, these should be set,
when known, to initial values, e.g., from an INI file. If the home
kinematics can accept arbitrary starting points, these initial values
should be used.

----
int rtapi_app_main(void)
void rtapi_app_exit(void)
----

These are the standard setup and tear-down functions of RTAPI modules.

When they are contained in a single source file, kinematics modules
may be compiled and installed by 'halcompile'. See the 'halcompile(1)' manpage or
the HAL manual for more information.

=== Kinematics module using the userkins.comp template

Another way to create a custom kinematics module is to adapt the
HAL component 'userkins'. This template component can be modified
locally by a user and can be built using halcompile.

See the userkins man pages for more information.

Note that to create switchable kinematic modules the required
modifications are somewhat more complicated.

See 'millturn.comp' as an example of a switchable kinematic
module that was created using the 'userkins.comp' template.

[[sec:writing-custom-kinematics]]
== Writing a Custom Kinematics Module

This section provides a complete guide to writing a kinematics module
that works with both the real-time motion controller and the userspace
trajectory planner (planner type 2).

=== Architecture overview

A kinematics module in LinuxCNC serves two consumers:

. The *real-time motion controller* (motmod) -- runs the kinematics
  every servo cycle to convert between joint and Cartesian space.
  This code has access to HAL pins and runs in the RTAPI environment.
. The *userspace trajectory planner* (milltask, planner type 2) --
  calls kinematics during path planning to compute blending, velocity
  limits, and look-ahead.  This code runs in normal userspace and
  cannot access HAL pins directly.

Both sets of functions live in the *same `.c` source file* and are
compiled into the *same RT `.so` module*.  The userspace planner loads
the RT `.so` via `dlopen()` and resolves the non-RT symbols via
`dlsym()`.

The key insight is that the *math is shared*: write your forward and
inverse kinematics as static helper functions that take plain
parameters (doubles, structs), then call those helpers from both the
RT interface (which reads HAL pins) and the non-RT interface (which
reads from a `kinematics_params_t` structure).

=== Required functions

Every kinematics module must export *two sets* of functions:

==== RT functions (for motmod)

These are the standard LinuxCNC kinematics functions documented above:
`kinematicsForward()`, `kinematicsInverse()`, `kinematicsType()`,
and either `KINS_NOT_SWITCHABLE` or the switchkins functions.
Additionally, `rtapi_app_main()` and `rtapi_app_exit()` handle
module initialization and cleanup.

==== Non-RT functions (for the userspace planner)

The userspace planner resolves these four symbols from the RT `.so`:

----
int nonrt_kinematicsForward(const void *params,
                            const double *joints,
                            EmcPose *pos);
----

Forward kinematics.  The `params` argument is a pointer to a
`kinematics_params_t` structure (see below) that contains all the
parameters the math needs.  Returns 0 on success, -1 on failure.

----
int nonrt_kinematicsInverse(const void *params,
                            const EmcPose *pos,
                            double *joints);
----

Inverse kinematics.  Same parameter convention.

----
int nonrt_refresh(void *params,
                  int (*read_float)(const char *, double *),
                  int (*read_bit)(const char *, int *),
                  int (*read_s32)(const char *, int *));
----

Called periodically by the userspace planner to update the
kinematics parameters from HAL pin values.  The three callback
functions read HAL pins by name.  Use them to populate the
module-specific fields in `kinematics_params_t`.  Returns 0 on
success.

For modules with no runtime parameters (e.g., trivkins, corexykins),
this function is a no-op that returns 0.

----
int nonrt_is_identity(void);
----

Returns 1 if this module implements identity kinematics (each
joint maps directly to one axis), 0 otherwise.  The planner
uses this to enable optimized code paths.

All four functions must be exported with `EXPORT_SYMBOL()`:

----
EXPORT_SYMBOL(nonrt_kinematicsForward);
EXPORT_SYMBOL(nonrt_kinematicsInverse);
EXPORT_SYMBOL(nonrt_refresh);
EXPORT_SYMBOL(nonrt_is_identity);
----

=== The `kinematics_params_t` structure

The non-RT functions receive their parameters through a
`kinematics_params_t` structure defined in
`src/emc/motion/kinematics_params.h`.  This structure contains:

- *`module_name`* -- the module name string (e.g., "maxkins")
- *`coordinates`* -- the coordinates string (e.g., "XYZBC")
- *`num_joints`* -- number of configured joints
- *`joint_to_axis[]`* -- maps joint number to axis index (0=X through 8=W)
- *`axis_to_joint[]`* -- maps axis index to its principal joint number
- *`params`* -- a union of module-specific parameter structs

The `params` union has a member for each built-in kinematics module.
When writing a custom module, add a new struct typedef and a
corresponding member to this union.

==== Adding parameters for a custom module

. Define a parameter struct in `kinematics_params.h`:
+
----
/* Parameters for mykins */
typedef struct {
    double my_param_a;
    double my_param_b;
    int    my_flag;
} kins_mykins_params_t;
----

. Add the struct to the `params` union inside `kinematics_params_t`:
+
----
union {
    kins_5axis_params_t fiveaxis;
    kins_trt_params_t trt;
    /* ... existing members ... */
    kins_mykins_params_t mykins;  /* <-- add this */
    double raw[128];
} params;
----

=== Complete example: a parametric 2-axis kinematics module

The following example implements a kinematics module for a machine
with an arm length parameter.  It demonstrates all three layers:
the math, the RT interface, and the non-RT interface.

[source,c]
----
/********************************************************************
 * mykins.c -- Example custom kinematics module
 * License: GPL Version 2
 ********************************************************************/

/* ---- RT headers ---- */
#include "kinematics.h"
#include "hal.h"
#include "rtapi.h"
#include "rtapi_app.h"
#include "rtapi_math.h"

/* ================================================================
 * Layer 1: Pure math (shared by RT and non-RT)
 *
 * These functions take plain parameters, no HAL, no globals.
 * ================================================================ */

static int mykins_forward(double arm_length,
                          const double *joints,
                          EmcPose *pos)
{
    /* Example: polar-to-cartesian with joint[0]=angle, joint[1]=radius */
    double angle_rad = joints[0] * (PM_PI / 180.0);
    double r = joints[1] + arm_length;
    pos->tran.x = r * cos(angle_rad);
    pos->tran.y = r * sin(angle_rad);
    pos->tran.z = joints[2];
    pos->a = pos->b = pos->c = 0;
    pos->u = pos->v = pos->w = 0;
    return 0;
}

static int mykins_inverse(double arm_length,
                          const EmcPose *pos,
                          double *joints)
{
    double r = sqrt(pos->tran.x * pos->tran.x
                  + pos->tran.y * pos->tran.y);
    if (r < 1e-10) return -1;  /* singularity at origin */
    joints[0] = atan2(pos->tran.y, pos->tran.x) * (180.0 / PM_PI);
    joints[1] = r - arm_length;
    joints[2] = pos->tran.z;
    return 0;
}

/* ================================================================
 * Layer 2: RT interface (reads HAL pins)
 * ================================================================ */

static struct haldata {
    hal_float_t *arm_length;
} *haldata;

int kinematicsForward(const double *joints, EmcPose *pos,
                      const KINEMATICS_FORWARD_FLAGS *fflags,
                      KINEMATICS_INVERSE_FLAGS *iflags)
{
    (void)fflags; (void)iflags;
    return mykins_forward(*(haldata->arm_length), joints, pos);
}

int kinematicsInverse(const EmcPose *pos, double *joints,
                      const KINEMATICS_INVERSE_FLAGS *iflags,
                      KINEMATICS_FORWARD_FLAGS *fflags)
{
    (void)iflags; (void)fflags;
    return mykins_inverse(*(haldata->arm_length), pos, joints);
}

KINEMATICS_TYPE kinematicsType() { return KINEMATICS_BOTH; }

const char *kinematicsGetName(void) { return "mykins"; }

KINS_NOT_SWITCHABLE
EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsForward);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsGetName);
MODULE_LICENSE("GPL");

static int comp_id;

int rtapi_app_main(void)
{
    comp_id = hal_init("mykins");
    if (comp_id < 0) return comp_id;

    haldata = hal_malloc(sizeof(struct haldata));
    if (hal_pin_float_new("mykins.arm-length", HAL_IO,
                          &(haldata->arm_length), comp_id) < 0)
        goto error;

    *(haldata->arm_length) = 100.0;  /* default value */
    hal_ready(comp_id);
    return 0;
error:
    hal_exit(comp_id);
    return -1;
}

void rtapi_app_exit(void) { hal_exit(comp_id); }

/* ================================================================
 * Layer 3: Non-RT interface (for userspace trajectory planner)
 *
 * These functions are resolved via dlsym() by the planner.
 * They call the same math as the RT side but get parameters
 * from kinematics_params_t instead of HAL pins.
 * ================================================================ */
#include "kinematics_params.h"

int nonrt_kinematicsForward(const void *params,
                            const double *joints,
                            EmcPose *pos)
{
    const kinematics_params_t *kp = (const kinematics_params_t *)params;
    return mykins_forward(kp->params.mykins.arm_length, joints, pos);
}

int nonrt_kinematicsInverse(const void *params,
                            const EmcPose *pos,
                            double *joints)
{
    const kinematics_params_t *kp = (const kinematics_params_t *)params;
    return mykins_inverse(kp->params.mykins.arm_length, pos, joints);
}

int nonrt_refresh(void *params,
                  int (*read_float)(const char *, double *),
                  int (*read_bit)(const char *, int *),
                  int (*read_s32)(const char *, int *))
{
    kinematics_params_t *kp = (kinematics_params_t *)params;
    (void)read_bit; (void)read_s32;

    /* Read the HAL pin value into our params struct.
     * The pin name must match what rtapi_app_main() created. */
    if (read_float("mykins.arm-length",
                   &kp->params.mykins.arm_length) != 0)
        return -1;

    return 0;
}

int nonrt_is_identity(void) { return 0; }

EXPORT_SYMBOL(nonrt_kinematicsForward);
EXPORT_SYMBOL(nonrt_kinematicsInverse);
EXPORT_SYMBOL(nonrt_refresh);
EXPORT_SYMBOL(nonrt_is_identity);
----

=== Structure of the code

The example above shows the three-layer pattern that all built-in
kinematics modules follow:

. **Layer 1 -- Pure math**: Static functions that take plain C
  parameters (doubles, arrays) and compute the kinematics.  These
  functions have no dependencies on HAL, RTAPI, or any global state.
  Both the RT and non-RT interfaces call them.

. **Layer 2 -- RT interface**: The standard `kinematicsForward()` /
  `kinematicsInverse()` functions.  They read HAL pin values and pass
  them to the Layer 1 math.  Also includes `rtapi_app_main()` which
  creates the HAL component and pins.

. **Layer 3 -- Non-RT interface**: The `nonrt_*` functions.  They
  read from the `kinematics_params_t` structure instead of HAL pins,
  and call the same Layer 1 math.  The `nonrt_refresh()` function
  uses the provided callbacks to copy current HAL pin values into
  the params structure.

This three-layer pattern ensures:

- The math is written once and tested once
- The RT module works identically whether or not planner 2 is in use
- The userspace planner gets the same kinematics results as the
  real-time controller

=== Adding the module to the build system

For an in-tree kinematics module, add a build rule in
`src/Makefile`.  For a standalone module named `mykins`:

----
obj-m += mykins.so
mykins-objs := emc/kinematics/mykins.o
----

The module will be compiled to `rtlib/mykins.so`.

For an out-of-tree module, the standard `halcompile --install`
method works for the RT side.  However, to support the non-RT
interface, the module must be compiled as a shared library (`.so`)
and placed in the `rtlib/` directory where the planner can find it.

=== INI file configuration

Configure your kinematics module in the INI file:

----
[KINS]
KINEMATICS = mykins
JOINTS = 3
----

For planner type 2, also set:

----
[TRAJ]
PLANNER_TYPE = 2
----

The userspace planner reads `[KINS]KINEMATICS` to determine which
RT `.so` to load and will automatically resolve the `nonrt_*`
symbols from it.

=== Tips

- Keep the math functions *pure*: no global state, no HAL access,
  no RTAPI calls.  This makes them testable and reusable.
- Use `rtapi_math.h` (not `math.h`) for math functions in the RT
  sections.  The non-RT sections (after `#include "kinematics_params.h"`)
  can use standard C headers since they only run in userspace, but
  it is simplest to use `rtapi_math.h` throughout.
- Use `rtapi_snprintf()` instead of `snprintf()` in RT code.
  Standard C library functions are not available in the RT
  environment.
- The `nonrt_refresh()` pin names must exactly match the HAL pin
  names created in `rtapi_app_main()`.
- For modules with no runtime parameters (pure geometric transforms
  with fixed joint mappings), `nonrt_refresh()` can be a no-op that
  returns 0.
- For switchkins modules that link with `switchkins.o`, do *not*
  include `rtapi_app.h` in your kinematics source -- `switchkins.c`
  already provides `rtapi_app_main()` and `rtapi_app_exit()`.  Put
  the non-RT interface section after all RT code with its own
  `#include "kinematics_params.h"`.
- Look at the existing modules in `src/emc/kinematics/` for
  real-world examples: `trivkins.c` (identity, no params),
  `maxkins.c` (simple with params), `xyzac-trt-kins.c` (switchkins
  with params).

// vim: set syntax=asciidoc:
