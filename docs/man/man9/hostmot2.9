.TH HOSTMOT2 "9" "2008-05-13" "LinuxCNC Documentation" "HAL Component"

.SH NAME
hostmot2 \- LinuxCNC HAL driver for the Mesa Electronics HostMot2 firmware.
.SH SYNOPSIS
See the config modparam section below for Mesa card configuration.
Typically hostmot2 is loaded with no parameters unless debugging is required.
.HP
.B loadrt hostmot2 [debug_idrom=\fIN\fB] [debug_module_descriptors=\fIN\fB] [debug_pin_descriptors=\fIN\fB] [debug_modules=\fIN\fB]
.TP
\fBdebug_idrom\fR [default: 0]
Developer/debug use only!  Enable debug logging of the HostMot2 IDROM header.
.TP
\fBdebug_module_descriptors\fR [default: 0]
Developer/debug use only!  Enables debug logging of the HostMot2 Module Descriptors.
.TP
\fBdebug_pin_descriptors\fR [default: 0]
Developer/debug use only!  Enables debug logging of the HostMot2 Pin Descriptors.
.TP
\fBdebug_modules\fR [default: 0]
Developer/debug use only!  Enables debug logging of the HostMot2 Modules used.
.TP
\fBuse_serial_numbers\fR [default: 0]
When creating HAL pins for smart-serial devices name the pins by the board serial number
rather than which board and port they are connected to.
With this option set to 1 pins will have names like \fBhm2_8i20.1234.current\fR rather than \fBhm2_5i23.0.8i20.0.1.current\fR.
The identifier consists of the last 4 digits of the board serial number, which is normally on a sticker on the board.
This will make configs less portable, but does mean that boards can be re-connected less carefully.

.SH DESCRIPTION
hostmot2 is a device driver that interfaces the Mesa or litehm2 HostMot2 firmware to the LinuxCNC HAL.
This driver by itself does nothing, the boards that actually run the firmware require their own drivers before anything can happen.
Currently drivers are available for PCI, Ethernet, SPI and EPP interfaced cards.

The HostMot2 firmware provides modules such as encoders, PWM generators, step/dir generators, and general purpose I/O pins (GPIOs).
These things are called "Modules".
The firmware is configured, at firmware compile time, to provide zero or more instances of each of these Modules.

.SS Board I/O Pins
The HostMot2 firmware runs on an FPGA board.
The board interfaces with the computer via PCI, Ethernet, SPI, or EPP, and interfaces with motion control hardware,
such as servos and stepper motors via I/O pins on the board.

Each I/O pin can be configured, at board-driver load time, to serve one of two purposes:
Either as a particular I/O pin of a particular Module instance (encoder, pwmgen, stepgen etc), or as a general purpose digital I/O pin.
By default all Module instances are enabled, and all the board's pins are used by the Module instances.

The user can disable Module instances at board-driver load time, by specifying a hostmot2 config string modparam.
Any pins which belong to Module instances that have been disabled automatically become GPIOs.

All IO pins have some HAL presence, whether they belong to an active module instance or are full GPIOs.
GPIOs can be changed (at run-time) between inputs, normal outputs, and open drains, and have a flexible HAL interface.
IO pins that belong to active Module instances are constrained by the requirements of the owning Module, and have a more limited interface in HAL.
This is described in the General Purpose I/O section below.

.SS config modparam
All the board-driver modules (hm2_pci, hm2_eth etc) accept a load-time modparam of type string array, named "config".
This array has one config string for each board the driver should use.
Each board's config string is passed to and parsed by the hostmot2 driver when the board-driver registers the board.

The config string can contain spaces, so it is usually a good idea to wrap the whole thing in double-quotes (the " character).

The comma character (,) separates members of the config array from each other.

For example, if your control computer has one 5I20 and one 5I23 you might load the hm2_pci driver with a HAL command (in halcmd) something like this:

.nf
.B
loadrt hm2_pci config="firmware=hm2/5i20/SVST8_4.BIT num_encoders=3 num_pwmgens=3 num_stepgens=3,firmware=hm2/5i23/SVSS8_8.BIT sserial_port_0=0000 num_encoders=4"
.fi

Note: this assumes that the hm2_pci driver detects the 5I20 first and the 5I23 second.
If the detection order does not match the order of the config strings,
the hostmot2 driver will refuse to load the firmware and the board-driver (hm2_pci etc) will fail to load.
To the best of my knowledge, there is no way to predict the order in which PCI boards will be detected by the driver,
but the detection order will be consistent as long as PCI boards are not moved around.
Best to try loading it and see what the detection order is.

The valid entries in the format string are:

.B
 [firmware=\fIF\fB]
 [num_dplls=\fIN\fB]
 [num_encoders=\fIN\fB]
 [ssi_chan_\fIN\fB=\fIabc%nq\fB]
 [biss_chan_\fIN\fB=\fIabc%nq\fB]
 [fanuc_chan_\fIN\fB=\fIabc%nq\fB]
 [num_inmuxs=\fIN\fB]
 [num_inms=\fIN\fB]
 [num_resolvers=\fIN\fB]
 [num_pwmgens=\fIN\fB]
 [num_3pwmgens=\fIN\fB]
 [num_oneshots=\fIN\fB]
 [num_rcpwmgens=\fIN\fB]
 [num_stepgens=\fIN\fB]
 [stepgen_width=\fIN\fB]
 [sserial_port_\fI0\fB=\fI00000000\fB]
 [num_bspis=\fIN\fB]
 [num_leds=\fIN\fB]
 [num_ssrs=\fIN\fB]
 [num_outms=\fIN\fB]
 [num_xy2mods=\fIN\fB]
 [enable_raw]

.TP
\fBfirmware\fR [optional]
Load the firmware specified by F into the FPGA on this board.
If no "\fBfirmware=\fIF\fR" string is specified, the FPGA will not be re-programmed but may continue to run a previously downloaded firmware.

The requested firmware F is fetched by udev, which searches for the firmware in the system's firmware search path, usually /lib/firmware.
F typically has the form "hm2/<BoardType>/file.bit"; a typical value for F might be "hm2/5i20/SVST8_4.BIT".
The hostmot2 firmware files are supplied by the hostmot2\-firmware packages, available from linuxcnc.org
and can normally be installed by entering the command "sudo apt\-get install hostmot2\-firmware\-5i23" to install the support files for the 5I23 for example.

Newer FPGA cards come pre-programmed with firmware and no "firmware=" string should be used with these cards.
To change the firmware on these cards the "mesaflash" utility should be used.
It is perfectly valid and reasonable to load these cards with no config string at all.
.TP
\fBnum_dplls\fR [optional, default: \-1]
The hm2dpll is a phase-locked loop timer module which may be used to reduce sample and write time jitter for some hm2 modules.
This parameter can be used to disable the hm2dpll by setting the number to 0.
There is only ever one module of this type, with 4 timer channels, so the other valid numbers are \-1 (enable all) and 1, both of which end up meaning the same thing.
.TP
\fBnum_encoders\fR [optional, default: \-1]
Only enable the first N encoders.  If N is \-1, all encoders are enabled.
If N is 0, no encoders are enabled.
If N is greater than the number of encoders available in the firmware, the board will fail to register.
.TP
\fBssi_chan_N\fR [optional, default: ""]
Specifies how the bit stream from a Synchronous Serial Interface device will be interpreted.
There should be an entry for each device connected.
Only channels with a format specifier will be enabled (as the software can not guess data rates and bit lengths).
.TP
\fBbiss_chan_N\fR [optional, default: ""]
As for ssi_chan_N, but for BiSS devices.
.TP
\fBfanuc_chan_N\fR [optional, default: ""]
Specifies how the bit stream from a Fanuc absolute encoder will be interpreted.
There should be an entry for each device connected.
Only channels with a format specifier will be enabled (as the software can not guess data rates and bit lengths).
.TP
\fBnum_resolvers\fR [optional, default: \-1]
Only enable the first N resolvers. If N = \-1 then all resolvers are enabled.
This module does not work with generic resolvers (unlike the encoder module which works with any encoder).
At the time of writing this Hostmot2 Resolver function only works with the Mesa 7I49 card.
.TP
\fBnum_pwmgens\fR [optional, default: \-1]
Only enable the first N pwmgens.  If N is \-1, all pwmgens are enabled.
If N is 0, no pwmgens are enabled.
If N is greater than the number of pwmgens available in the firmware, the board will fail to register.
.TP
\fBnum_3pwmgens\fR [optional, default: \-1]
Only enable the first N Three-phase pwmgens.
If N is \-1, all 3pwmgens are enabled. If N is 0, no pwmgens are enabled.
If N is greater than the number of pwmgens available in the firmware, the board will fail to register.
.TP
\fBnum_rcpwmgens\fR [optional, default: \-1]
Only enable the first N RC pwmgens.
If N is \-1, all rcpwmgens are enabled. If N is 0, no rcpwmgens are enabled.
If N is greater than the number of rcpwmgens available in the firmware, the board will fail to register.
.TP
\fBnum_stepgens\fR [optional, default: \-1]
Only enable the first N stepgens.  If N is \-1, all stepgens are enabled. If N is 0, no stepgens are enabled.
If N is greater than the number of stepgens available in the firmware, the board will fail to register.
.TP
\fBnum_xy2mods\fR [optional, default: \-1]
Only enable the first N xy2mods.  If N is \-1, all xy2mods are enabled.  If N is 0, no xy2mods are enabled.
If N is greater than the number of xy2mods available in the firmware, the board will fail to register.
.TP
.TP
\fBstepgen_width\fR [optional, default: 2]
Used to mask extra, unwanted, stepgen pins.
Stepper drives typically require only two pins (step and dir) but the Hostmot2 stepgen can drive up to 8 output pins for specialised applications (depending on firmware).
This parameter applies to all stepgen instances. Unused, masked pins will be available as GPIO.
.TP
\fBsserial_port_\fIN\fR (\fIN\fR = 0 .. 3)\fR [optional, default: 00000000 for all ports]
Up to 32 Smart Serial devices can be connected to a Mesa Anything IO board,
depending on the firmware used and the number of physical connections on the board.
These are arranged in 1-4 ports (N) of 1 to 8 channels.
Some Smart Serial (SSLBP) cards offer more than one load-time configuration,
for example all inputs, or all outputs, or offering additional analogue input on some digital pins.
To set the modes for port 0 use for example \fBsserial_port_0=0120xxxx\fR.
A "0" in the string sets the corresponding channel to mode 0, a "1" to mode 1, and so on up to mode 9.
An "x" in any position disables that channel and makes the corresponding FPGA pins available as GPIO.
The string can be up to 8 characters long, and if it defines more modes than there are channels on the port then the extras are ignored.
Channel numbering is left to right so the example above would set sserial device 0.0 to mode 0, 0.1 to mode 1, 0.2 to mode 2, 0.3 to mode 0 and disables channels 0.4 onwards.
The sserial driver will auto-detect connected devices, no further configuration should be needed.
Unconnected channels will default to GPIO, but the pin values will vary semi-randomly during boot when card-detection runs,
to it is best to actively disable any channel that is to be used for GPIO.
See SSERIAL(9) for more information.
.TP
\fBnum_bspis\fR [optional, default: \-1]
Only enable the first N Buffered SPI drivers. If N is \-1 then all the drivers are enabled.
Each BSPI driver can address 16 devices.
.TP
\fBnum_leds\fR [optional, default: \-1]
Only enable the first N of the LEDs on the FPGA board. If N is \-1, then HAL pins for all the LEDs will be created.
If N=0 then no pins will be added.
.TP
\fBnum_ssrs\fR [optional, default: -1]
Only enable the first N of the SSR modules on the FPGA board.
If N is \-1, then HAL pins for all the SSR outputs will be created.
If N=0 then no pins will be added.
.TP
\fBenable_raw\fR [optional]
If specified, this turns on a raw access mode, whereby a user can peek and poke the firmware from HAL.  See Raw Mode below.

.SS dpll
The hm2dpll module has pins like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll\fR"
It is likely that the pin-count will decrease in the future and that some pins will become parameters.
This module is a phase-locked loop that will synchronise itself with the thread in which the hostmot2 "read" function is installed
and will trigger other functions that are allocated to it at a specified time before or after the "read" function runs.
This can be applied to the three absolute encoder types, quadrature encoder, stepgen, and xy2mod.
In the case of the absolute encoders this allows the system to trigger a data transmission just prior to the time when the HAL driver reads the data.
In the case of stepgens, quadrature encoders, and the xy2mod, the timers can be used to reduce position sampling jitter.
This is especially valuable with the ethernet-interfaced cards.

Pins:
.TP
(float, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.NN.timer\-us
This pin sets the triggering offset of the associated timer.
There are 4 timers numbered 01 to 04, represented by the NN digits in the pin name.
The units are microseconds (µs).
Generally the value for reads will be negative, and positive for writes,
so that input data is sampled prior to the main hostmot read and output data is written some time after the main hostmot2 read.

For stepgen and quadrature encoders, the value needs to be more than the maximum variation between read times.
\-100 will suffice for most systems, and \-50 will work on systems with good performance and latency.

For serial encoders, the value also needs to include the time it takes to transfer the absolute encoder position.
For instance, if 50 bits must be read at 500 kHz then subtract an additional 50/500 kHz = 100 µs to get a starting value of \-200.

The xy2mod uses 2 DPLL timers, one for read and one for write.
The read timer value can be the same as used by the stepgen and quadrature encoders so the same timer channel can be shared.
The write timer is typically set to a time after the main hostmot2 write this may take some experimentation.

.TP
(float, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.base\-freq\-khz
This pin sets the base frequency of the phase-locked loop.
By default it will be set to the nominal frequency of the thread in which the PLL is running and will not normally need to be changed.
.TP
(float, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.phase\-error\-us
Indicates the phase error of the DPLL.
If the number cycles by a large amount it is likely that the PLL has failed to achieve lock and adjustments will need to be made.
.TP
(u32, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.time\-const
The filter time-constant for the PLL.
The default value is a compromise between insensitivity to single-cycle variations and being resilient to changes to the Linux CLOCK_MONOTONIC timescale,
which can instantly change by up to ±500ppm from its nominal value, usually by timekeeping software like ntpd and ntpdate. Default 2000 (0x7d0).
.TP
(u32, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.plimit
Sets the phase adjustment limit of the PLL.
If the value is zero then the PLL will free-run at the base frequency independent of the servo thread rate.
This is probably not what you want. Default 4194304 (0x400000) Units not known...
.TP
(u32, out) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.ddsize
Used internally by the driver, likely to disappear.
.TP
(u32, in) hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.dpll.prescale
Prescale factor for the rate generator. Default 1.


.SS Encoder

Encoders have names like
""hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.encoder.\fI<Instance>\fR".".
"Instance" is a two-digit number that corresponds to the HostMot2 encoder instance number.
There are "num_encoders" instances, starting with 00.

So, for example, the HAL pin that has the current position of the second encoder of the first 5I25 board is:
hm2_5i25.0.encoder.01.position (this assumes that the firmware in that board is configured so that this HAL object is available).

Each encoder uses three or four input IO pins, depending on how the firmware was compiled.
Three-pin encoders use A, B, and Index (sometimes also known as Z).
Four-pin encoders use A, B, Index, and Index-mask.

The hm2 encoder representation is similar to the one described by the Canonical Device Interface (in the HAL General Reference document),
and to the software encoder component.
Each encoder instance has the following pins and parameters:

Pins:

.TP
(s32 out) count
Number of encoder counts since the previous reset.

.TP
(float out) position
Encoder position in position units (count / scale).

.TP
(float out) position-latched
Encoder latched position in position units (count / scale).

.TP
(float out) velocity
Estimated encoder velocity in position units per second.

.TP
(float out) velocity-rpm
Estimated encoder velocity in position units per minute.

.TP
(bit in) reset
When this pin is True, the count and position pins are set to 0 (the value of the velocity pin is not affected by this).
The driver does not reset this pin to FALSE after resetting the count to 0, that is the user's job.

.TP
(bit in/out) index\-enable
When this pin is set to True, the count (and therefore also position) are reset to zero on the next Index (Phase\-Z) pulse.
At the same time, index\-enable is reset to zero to indicate that the pulse has occurred.

.TP
(bit in/out) probe\-enable
When this pin is set to True, the encoder count (and therefore also position) are latched on the the next probe active edge.
At the same time, probe\-enable is reset to zero to indicate that latch event has occurred.

.TP
(bit r/w) probe\-invert
If set to True, the rising edge of the probe input pin triggers the latch event (if probe\-enable is True).
If set to False, the falling edge triggers.

.TP
(s32 out) rawcounts
Total number of encoder counts since the start, not adjusted for index or reset.

.TP
(bit out) input-a, input-b, input-index
Real time filtered values of A,B,Index encoder signals

.TP
(bit in) quad-error-enable
When this pin is True quadrature error reporting is enabled.
when False, existing quadrature errors are cleared and error reporting is disabled.

.TP
(bit out) quad-error
This bit indicates that a quadrature sequence error has been detected.
It can only be set if the corresponding quad-error-enable bit is True.

.TP
(u32 in) hm2_XXXX.N.encoder.sample-frequency
This is the sample frequency that determines all standard encoder channels digital filter time constant (see filter parameter).

.TP
(u32 in) hm2_XXXX.N.encoder.muxed-sample-frequency
This is the sample frequency that determines all muxed encoder channels digital filter time constant (see filter parameter).
This also sets the encoder multiplexing frequency.

.TP
(float in) hm2_XXXX.N.encoder.muxed-skew
This sets the muxed encoder sample time delay (in ns) from the multiplex signal.
Setting this properly can increase the usable multiplex frequency and compensate for cable delays (suggested value is 3* cable length in feet +20).

.TP
(bit in) hm2_XXXX.N.encoder.hires-timestamp
When this pin is True the encoder timestamp counter frequency is ~10 MHz when False the timestamp counter frequency is ~2 MHz.
This should be set True for frequency counting applications to improve the resolution.
It should be set False when servo thread periods longer than 1 ms are used.

Parameters:

.TP
(float r/w) scale
Converts from "count" units to "position" units.

.TP
(bit r/w) index\-invert
If set to True, the rising edge of the Index input pin triggers the Index event (if index\-enable is True).
If set to False, the falling edge triggers.

.TP
(bit r/w) index\-mask
If set to True, the Index input pin only has an effect if the Index\-Mask input pin is True (or False, depending on the index\-mask\-invert pin below).

.TP
(bit r/w) index\-mask\-invert
If set to True, Index\-Mask must be False for Index to have an effect.
If set to False, the Index\-Mask pin must be True.

.TP
(bit r/w) counter\-mode
Set to False (the default) for Quadrature.
Set to True for Step/Dir (in which case Step is on the A pin and Dir is on the B pin).

.TP
(bit r/w) filter
If set to True (the default), the quadrature counter needs 15 sample clocks to register a change on any of the three input lines
(any pulse shorter than this is rejected as noise).
If set to False, the quadrature counter needs only 3 clocks to register a change.
The default encoder sample clock runs at approximately 25 to 33 MHz but can be changed globally with the sample-frequency or muxed-sample-frequency pin.

.TP
(float r/w) vel\-timeout
When the encoder is moving slower than one pulse for each time that the driver reads the count from the FPGA (in the hm2_read() function), the velocity is harder to estimate.
The driver can wait several iterations for the next pulse to arrive, all the while reporting the upper bound of the encoder velocity,
which can be accurately guessed.
This parameter specifies how long to wait for the next pulse, before reporting the encoder stopped.
This parameter is in seconds.

.TP
(s32 r/w) hm2_XXXX.N.encoder.timer\-number (default: \-1)
Sets the hm2dpll timer instance to be used to latch encoder counts.
A setting of \-1 does not latch encoder counts.
A setting of 0 latches at the same time as the main hostmot2 read.
A setting of 1..4 uses a time offset from the main hostmot2 read according to the dpll's timer\-us setting.

Typically, timer\-us should be a negative number with a magnitude larger than the largest latency
(e.g., \-100 for a system with mediocre latency, \-50 for a system with good latency).
A negative number specifies latching the specified time before the nominal hostmot2 read time.

If no DPLL module is present in the FPGA firmware, or if the encoder module does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.  Doing so generally reduces following errors.

.SS Synchronous Serial Interface (SSI)
(Not to be confused with the Smart Serial Interface)

One pin is created for each SSI instance regardless of data format: (bit, in) hm2_XXXX.NN.ssi.MM.data\-incomplete.
This pin will be set "True" if the module was still transferring data when the value was read.
When this problem exists there will also be a limited number of error messages printed to the UI.
This pin should be used to monitor whether the problem has been addressed by config changes.
Solutions to the problem dpend on whether the encoder read is being triggered by the hm2dpll phase-locked-loop timer (described above) or by the trigger\-encoders function (described below).

The names of the pins created by the SSI module will depend entirely on the format string for each channel specified in the loadrt command line.
A typical format string might be  \fBssi_chan_0=error%1bposition%24g\fR.

This would interpret the LSB of the bit-stream as a bit-type pin named "error" and the next 24 bits as a Gray-coded encoder counter.
The encoder-related HAL pins would all begin with "position".

There should be no spaces in the format string, as this is used as a delimiter by the low-level code.

The format consists of a string of alphanumeric characters that will form the HAL pin names, followed by a % symbol, a bit-count and a data type.
All bits in the packet must be defined, even if they are not used.
There is a limit of 64 bits in total.

The valid format characters and the pins they create are:
.TP
p: (Pad). Does not create any pins, used to ignore sections of the bit stream that are not required.
.TP
b: (Boolean).
  (bit, out) hm2_XXXX.N.ssi.MM.<name>. If any bits in the designated field width are non-zero then the HAL pin will be "True".
  (bit, out) hm2_XXXX.N.ssi.MM.<name>\-not. An inverted version of the above, the HAL pin will be "True" if all bits in the field are zero.
.TP
u: (Unsigned)
  (float, out) hm2_XXXX.N.ssi.MM.<name>. The value of the bits interpreted as an unsigned integer then scaled such that the pin value will equal the scalemax parameter value when all bits are high. (for example if the field is 8 bits wide and the scalmax parameter was 20 then a value of 255 would return 20, and 0 would return 0.
.TP
s: (Signed)
  (float, out) hm2_XXXX.N.ssi.MM.<name>. The value of the bits interpreted as a 2s complement signed number then scaled similarly to the unsigned variant, except symmetrical around zero.
.TP
f: (bitField)
  (bit, out) hm2_XXXX.N.ssi.MM.<name>\-NN. The value of each individual bit in the data field. NN starts at 00 up to the number of bits in the field.
  (bit, out) hm2_XXXX.N.ssi.MM.<name>\-NN\-not. An inverted version of the individual bit values.
.TP
e: (Encoder)
 (s32, out) hm2_XXXX.N.ssi.MM.<name>.count. The lower 32 bits of the total encoder counts. This value is reset both by the ...reset and the ...index\-enable pins.
 (s32, out) hm2_XXXX.N.ssi.MM.<name>.rawcounts. The lower 32 bits of the total encoder counts. The pin is not affected by reset and index.
 (float, out) hm2_XXXX.N.ssi.MM.<name>.position. The encoder position in machine units. This is calculated from the full 64-bit buffers so will show a True value even after the counts pins have wrapped. It is zeroed by reset and index enable.
 (bit, IO) hm2_XXXX.N.ssi.MM.<name>.index\-enable. When this pin is set "True" the module will wait until the raw encoder counts next passes through an integer multiple of the number of counts specified by counts\-per\-rev parameter and then it will zero the counts and position pins, and set the index\-enable pin back to "False" as a signal to the system that "index" has been passed.  this pin is used for spindle-synchronised motion and index-homing.
 (bit, in) (bit, out) hm2_XXXX.N.ssi.MM.<name>.reset. When this pin is set high the counts and position pins are zeroed.
.TP
h: (Split encoder, high-order bits)
Some encoders (Including Fanuc) place the encoder part-turn counts and full-turn counts in separate, non-contiguous fields.
This tag defines the high-order bits of such an encoder module.
There can be only one h and one l tag per channel, the behaviour with multiple such channels will be undefined.
.TP
l: (Split encoder, low-order bits)
Low order bits (see "h")
.TP
g: (Gray-code). This is a modifier that indicates that the following format string is gray-code encoded.
This is only valid for encoders (e, h l) and unsigned (u) data types.
.TP
m: (Multi-turn). This is a modifier that indicates that the following
format string is a multi-turn encoder. This is only valid for encoders (e, h l).
A jump in encoder position of more than half the full scale is interpreted as a full turn and the counts are wrapped.
With a multi-turn encoder this is only likely to be a data glitch and will lead to a permanent offset.
This flag endures that such encoders will never wrap.

.TP
Parameters:
Two parameters is universally created for all SSI instances

.TP
(float r/w) hm2_XXXX.N.ssi.MM.frequency\-khz
This parameter sets the SSI clock frequency. The units are kHz, so 500 will give a clock frequency of 500,000 Hz.

.TP
(s32 r/w) hm2_XXXX.N.ssi.timer-number\-num
This parameter allocates the SSI module to a specific hm2dpll timer instance.
This pin is only of use in firmwares which contain a hm2dpll function and will default to 1 in cases where there is such a function, and 0 if there is not.
The pin can be used to disable reads of the encoder, by setting to a nonexistent timer number, or to 0.

Other parameters depend on the data types specified in the config string.
.TP
p: (Pad) No Parameters.
.TP
b: (Boolean) No Parameters.
.TP
u: (Unsigned)
(float, r/w) hm2_XXXX.N.ssi.MM.<name>-scalemax. The scaling factor for the channel.
.TP
s: (Signed)
(float, r/w) hm2_XXXX.N.ssi.MM.<name>-scalemax. The scaling factor for the channel.
.TP
f: (bitField): No parameters.
.TP
e: (Encoder):
 (float, r/w) hm2_XXXX.N.ssi.MM.<name>.scale: (float, r.w)
The encoder scale in counts per machine unit.
 (u32, r/w) hm2_XXXX.N.ssi.MM.<name>.counts\-per\-rev (u32, r/w)
Used to emulate the index behaviour of an incremental+index encoder.
This would normally be set to the actual counts per rev of the encoder, but can be any whole number of revs.
Integer divisors or multipliers of the true PPR might be useful for index-homing.
Non-integer factors might be appropriate where there is a synchronous drive ratio between the encoder and the spindle or ballscrew.


.SS BiSS
BiSS is a bidirectional variant of SSI. Currently only a single direction is supported by LinuxCNC (encoder to PC).

One pin is created for each BiSS instance regardless of data format:

(bit, in) hm2_XXXX.NN.biss.MM.data\-incomplete
This pin will be set "True" if the module was still transferring data when the value was read.
When this problem exists there will also be a limited number of error messages printed to the UI.
This pin should be used to monitor whether the problem has been addressed by config changes.
Solutions to the problem dpend on whether the encoder read is being triggered by the hm2dpll phase-locked-loop timer (described above) or by the trigger\-encoders function (described below).

The names of the pins created by the BiSS module will depend entirely on the format string for each channel specified in the loadrt command line and follow closely the format defined above for SSI.
Currently data packets of up to 96 bits are supported by the LinuxCNC driver, although the Mesa Hostmot2 module can handle 512 bit packets.
It should be possible to extend the number of packets supported by the driver if there is a requirement to do so.

.SS Fanuc encoder
The pins and format specifier for this module are identical to the SSI module described above, except that at least one pre-configured format is provided.
A modparam of fanuc_chan_N=AA64 (case sensitive) will configure the channel for a Fanuc Aa64 encoder. The pins created are:
 hm2_XXXX.N.fanuc.MM.batt                indicates battery state
 hm2_XXXX.N.fanuc.MM.batt\-not            inverted version of above
 hm2_XXXX.N.fanuc.MM.comm                The 0-1023 absolute output for motor commutation
 hm2_XXXX.N.fanuc.MM.crc                 The CRC checksum. Currently HAL has no way to use this
 hm2_XXXX.N.fanuc.MM.encoder.count       Encoder counts
 hm2_XXXX.N.fanuc.MM.encoder.index\-enable Simulated index. Set by counts\-per\-rev parameter
 hm2_XXXX.N.fanuc.MM.encoder.position    Counts scaled by the ...scale parameter
 hm2_XXXX.N.fanuc.MM.encoder.rawcounts   Raw counts, unaffected by reset or index
 hm2_XXXX.N.fanuc.MM.encoder.reset       If high/True then counts and position = 0
 hm2_XXXX.N.fanuc.MM.valid               Indicates that the absolute position is valid
 hm2_XXXX.N.fanuc.MM.valid\-not           Inverted version

.SS resolver
Resolvers have names like hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.resolver.\fI<Instance>\fR.
<Instance> is a 2-digit number, which for the 7I49 board will be between 00 and 05.
This function only works with the Mesa Resolver interface boards (of which the 7I49 is the only example at the time of writing).
This board uses an SPI interface to the FPGA card, and will only work with the correct firmware.
The pins allocated will be listed in the dmesg output, but are unlikely to be usefully probed with HAL tools.

Pins:

.TP
(float, out) angle
This pin indicates the angular position of the resolver. It is a number between 0 and 1 for each electrical rotation.

.TP
(float, out) position
Calculated from the number of complete and partial revolutions since startup, reset, or  index\-reset multiplied by the scale parameter.

.TP
(float, out) velocity
Calculated from the rotational velocity and the velocity\-scale parameter. The default scale is electrical rotations per second.

.TP
(float, out) velocity-rpm
Simply velocity scaled by a factor of 60 for convenience.

.TP
(s32, out) count
This pins outputs a simulated encoder count at 2^24 counts per rev (16777216 counts).

.TP
(s32, out) rawcounts
This is identical to the counts pin, except it is not reset by the "index" or "reset" pins.
This is the pin which would be linked to the bldc HAL component if the resolver was being used to commutate a motor.

.TP
(bit, in) reset
Resets the position and counts pins to zero immediately.

.TP
(bit, in)  joint-pos-fb
The Mesa resolver driver has the capability of emulating an absolute encoder using a position file (see the INI-config section of the manual)
and the single-turn absolute operation of resolvers.
At startup, and only if the \fBuse-position-file\fR parameter is set to "True",
the resolver driver will wait for a value to be written by the system to the axis.N.joint-pos-fb pin (which must be netted to this resolver pin)
and will calculate the number of full turns that best matches the current reolver position.
It will then pre-load the driver output with this offset.
This should only be used on systems where axis movement in the unpowered state is unlikely.
This feature will only work properly if the machine is initially homed to "index" and if the axis home positions are exactly zero.

.TP
(bit, in/out) index\-enable
When this pin is set high the position and counts pins will be reset the next time the resolver passes through the zero position.
At the same time the pin is driven low to indicate to connected modules that the index has been seen, and that the counters have been reset.

.TP
(bit, out) error
Indicates an error in the particular channel. If this value is "True" then the reported position and velocity are invalid.

Parameters:
.TP
(float, read/write) scale
The position scale, in machine units per resolver electrical revolution.

.TP
(float, read/write) velocity\-scale
The conversion factor between resolver rotation speed and machine velocity.
A value of 1 will typically give motor speed in RPS, a value of 0.01666667 will give (approximate) RPM.

.TP
(u32, read/write) index\-divisor (default 1)
The resolver component emulates an index at a fixed point in the sin/cos cycle.
Some resolvers have multiple cycles per rev (often related to the number of pole-pairs on the attached motor).
LinuxCNC requires an index once per revolution for proper threading etc.
This parameter should be set to the number of cycles per rev of the resolver.
CAUTION: Which pseudo-index is used will not necessarily be consistent between LinuxCNC runs.
Do not expect to re-start a thread after restarting LinuxCNC.
It is not appropriate to use this parameter for index-homing of axis drives.

.TP
(float, read/write) excitation\-khz
This pin sets the excitation frequency for the resolver.
This pin is module-level rather than instance-level as all resolvers share the same excitation frequency.
Valid values are 10 (~10 kHz), 5 (~5 kHz) and 2.5 (~2.5 kHz).
The actual frequency depends on the FPGA frequency, and they correspond to CLOCK_LOW/5000, CLOCK_LOW/10000 and CLOCK_LOW/20000 respectively.
The parameter will be set to the closest available of the three frequencies.
A value of \-1 (the default) indicates that the current setting should be retained.

.TP
(bit, read/write) use-position-file
In conjunction with \fBjoint-pos-fb\fR (qv) emulate absolute encoders.


.SS pwmgen

pwmgens have names like
"hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.pwmgen.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 pwmgen instance number.
There are "num_pwmgens" instances, starting with 00.

So, for example, the HAL pin that enables output from the fourth pwmgen of the first 7I43 board is:
hm2_7i43.0.pwmgen.03.enable (this assumes that the firmware in that board is configured so that this HAL object is available).

In HM2, each pwmgen uses three output IO pins: Not\-Enable, Out0, and Out1.

The function of the Out0 and Out1 IO pins varies with output\-type parameter (see below).

The hm2 pwmgen representation is similar to the software pwmgen component.
Each pwmgen instance has the following pins and parameters:

Pins:

.TP
(bit input) enable
If True, the pwmgen will set its Not\-Enable pin False and output its pulses.
If "enable" is False, pwmgen will set its Not\-Enable pin True and not output any signals.

.TP
(float input) value
The current pwmgen command value, in arbitrary units.

Parameters:

.TP
(float rw) scale
Scaling factor to convert "value" from arbitrary units to duty cycle: dc = value / scale.
Duty cycle has an effective range of \-1.0 to +1.0 inclusive, anything outside that range gets clipped.
The default scale is 1.0.

.TP
(s32 rw) output\-type
This emulates the output_type load-time argument to the software pwmgen component.
This parameter may be changed at runtime, but most of the time you probably want to set it at startup and then leave it alone.
Accepted values are 1 (PWM on Out0 and Direction on Out1), 2 (Up on Out0 and Down on Out1), 3 (PDM mode, PDM on Out0 and Dir on Out1), and 4 (Direction on Out0 and PWM on Out1, "for locked antiphase").

.TP
(bit input) offset\-mode
When True, offset\-mode modifies the PWM behavior so that a PWM value of 0 results in a 50% duty cycle PWM output,
a -1 value results in a 0% duty cycle and +1 results in a 100% duty cycle (with default scaling).
This mode is used by some PWM motor drives and PWM to analog converters.
Typically the direction signal is not used in this mode.

.TP
(bit input) dither
When True, dither causes the PWM output to dither between two adjacent PWM register values at the PWM frequency. 
This increases the PWM resolution when used for analog output purposes, increasing the maximum resolution
from 12 to 16 bits. Dither is only supported with PWMGen firmware version 1 or greater and only affects PWM outputs,
not PDM outputs. 

In addition to the per-instance HAL Parameters listed above, there are a couple of HAL Parameters that affect all the pwmgen instances:

.TP
(u32 rw) pwm_frequency
This specifies the PWM frequency, in Hz, of all the pwmgen instances running in the PWM modes (modes 1 and 2).
This is the frequency of the variable-duty-cycle wave.  Its effective range is from 1 Hz up to 386 kHz.
Note that the max frequency is determined by the ClockHigh frequency of the Anything IO board;
the 5I25 and 7I92 both have a 200 MHz clock, resulting in a 386 kHz max PWM frequency.
Other boards may have different clocks, resulting in different max PWM frequencies.
If the user attempts to set the frequency too high, it will be clipped to the max supported frequency of the board.
Frequencies below about 5 Hz are not terribly accurate, but above 5 Hz they're pretty close.
The default pwm_frequency is 20,000 Hz (20 kHz).

.TP
(u32 rw) pdm_frequency
This specifies the PDM frequency, in Hz, of all the pwmgen instances running in PDM mode (mode 3).
This is the "pulse slot frequency"; the frequency at which the pdm generator in the AnyIO board chooses whether to emit a pulse or a space.
Each pulse (and space) in the PDM pulse train has a duration of 1/pdm_frequency seconds.
For example, setting the pdm_frequency to 2e6 (2 MHz) and the duty cycle to 50% results in a 1 MHz square wave, identical to a 1 MHz PWM signal with 50% duty cycle.
The effective range of this parameter is from about 1525 Hz up to just under 200 MHz.
Note that the max frequency is determined by the ClockHigh frequency of the Anything IO board;
the 5I25 and 7I92 both have a 100 MHz clock, resulting in a 100 MHz max PDM frequency.
Other boards may have different clocks, resulting in different max PDM frequencies.
If the user attempts to set the frequency too high, it will be clipped to the max supported frequency of the board.
The default pdm_frequency is 20,000 Hz (20 kHz).

.SS 3ppwmgen
Three-Phase PWM generators (3pwmgens) are intended for controlling the high-side and low-side gates in a 3-phase motor driver.
The function is included to support the Mesa motor controller daughter-cards but can be used to control an IGBT or similar driver directly.
3pwmgens have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.3pwmgen.\fI<Instance>\fR" where <Instance> is a 2-digit number.
There will be num_3pwmgens instances, starting at 00.
Each instance allocates 7 output and one input pins on the Mesa card connectors.
Outputs are: PWM A, PWM B, PWM C, /PWM A, /PWM B, /PWM C, Enable.
The first three pins are the high side drivers, the second three are their complementary low-side drivers.
The enable bit is intended to control the servo amplifier.
The input bit is a fault bit, typically wired to over-current detection.
When set the PWM generator is disabled.  The three phase duty-cycles are individually controllable from \-Scale to +Scale.
Note that 0 corresponds to a 50% duty cycle and this is the initialization value.

Pins:

(float input) A\-value, B\-value, C\-value: The PWM command value for each phase, limited to +/\- "scale".
Defaults to zero which is 50% duty cycle on high-side and low-sidepins (but see the "deadtime" parameter).

.TP
(bit input) enable
When high the PWM is enabled as long as the fault bit is not set by the external fault input pin.
When low the PWM is disabled, with both high- side and low-side drivers low.
This is not the same as 0 output (50% duty cycle on both sets of pins) or negative full scale (where the low side drivers are "on" 100% of the time).

.TP
(bit output) fault
Indicates the status of the fault bit. This output latches high once set by the physical fault pin until the "enable" pin is set to high.

Parameters:

.TP
(u32 rw) deadtime
Sets the dead-time between the high-side driver turning off and the low-side driver turning on and vice-versa.
Deadtime is subtracted from on time and added to off time symmetrically.
For example with 20 kHz PWM (50 µs period), 50% duty cycle and zero dead time, the PWM and NPWM outputs would be square waves
(NPWM being inverted from PWM) with high times of 25 µs.
With the same settings but 1 µs of deadtime, the PWM and NPWM outputs would both have high times of 23 µs (25 \- (2X 1 µs), 1 µs per edge).
The value is specified in nanoseconds (ns) and defaults to a rather conservative 5000 ns.
Setting this parameter to too low a value could be both expensive and dangerous as if both gates are open at the same time
there is effectively a short circuit across the supply.

.TP
(float rw) scale
Sets the half-scale of the specified 3-phase PWM generator.
PWM values from \-scale to +scale are valid. Default is +/\- 1.0

.TP
(bit rw) fault\-invert
Sets the polarity of the fault input pin.
A value of 1 means that a fault is triggered with the pin high, and 0 means that a fault it triggered when the pin is pulled low.
Default 0, fault = low so that the PWM works with the fault pin unconnected.

.TP
(u32 rw) sample\-time
Sets the time during the cycle when an ADC pulse is generated.
0 = start of PWM cycle and 1 = end. Not currently useful to LinuxCNC. Default 0.5.

In addition the per-instance parameters above there is the following parameter that affects all instances:

.TP
(u32 rw) frequency
Sets the master PWM frequency. Maximum is approx 48 kHz, minimum is 1 kHz. Defaults to 20 kHz.

.SS oneshot
The oneshot is a hardware one-shot device suitable for various timing, delay, signal conditioning, PWM generation, and watchdog functions.
The oneshot module includes 2 timers to allow variable pulse delays for applications like phase control.
Trigger sources can be software, external inputs, the DPLL timer, a built in rate generator or the other timer.
Oneshots have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.oneshot.\fI<Instance>\fR" where <Instance> is a 2-digit number.
There will be num_oneshots instances, starting at 00. Each instance allocates up to two input and two output pins.

Pins:

.TP
(float rw) width1
Sets the pulse width of timer1 in ms. Default is 1 ms (1/1000 s).

.TP
(float rw) width2
Sets the pulse width of timer2 in ms. Default is 1 ms (1/1000 s).

.TP
(float rw) filter1
Sets digital filter time constant for timer1's external trigger input Filter time is in ms. Default filter time constant time is 0.1 ms.
External trigger response will be delayed by the filter time setting.

.TP
(float rw) filter2
Sets digital filter time constant for timer2's external trigger input Filter time is in ms. Default filter time constant time is 0.1 ms.
External trigger response will be delayed by the filter time setting.

.TP
(float rw) rate
Sets the frequency of the built in rate generator (in Hz)

.TP
(u32 rw) trigger_select1,trigger_select2
Sets the trigger source for timer1,timer2 respectively.
Trigger sources are:
.nf
0 Trigger disabled
1 Software trigger: triggered when hal pin swtrigger1 is true
2 External hardware: trigger
3 DPLL trigger: triggered by selected DPLL timer
4 Rate trigger: triggered by build in rate generator.
5 Timer1 trigger: triggered by timer1 output
6 Timer2 trigger: triggered by timer2 output
.fi
.TP
(bit rw) trigger_on_rise1,trigger_on_rise2
When true, triggers timer1, timer2 respectively on the rising edge of the trigger source.

.TP
(bit rw) trigger_on_fall1,trigger_on_fall2
When true, triggers timer1, timer2 respectively on the falling edge of the trigger source.

.TP
(bit rw) retriggerable1,retriggerable2
When true, the associated timer is retriggerable,
meaning the timer will reset to full time on a trigger event even during the output pulse period.
When false the timer is not retriggerable, meaning it will ignore trigger events during the output pulse period.

.TP
(bit rw) enable1,enable2
trigger enable for timer1 and timer2 respectively True to enable.

.TP
(bit rw) reset1,reset2
If true, resets timer1 and timer2 respectively, aborting any pulse in progress.

.TP
(bit ro) out1,out2
Pulse output status bits for timer1 and timer2.

.TP
(bit ro) exttrigger1,exttrigger2
External trigger input status bits for timer1 and timer2.
These monitor the filtered inputs.

.TP
(bit rw) swtrigger1,swtrigger2
software trigger inputs to trigger timer1 and timer2.

.SS rcpwmgen
The rcpwmgen is a simple PWM generator optimized for use with standard RC servos that use pulse width to determine position.
rcpwmgens have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.rcpwmgen.\fI<Instance>\fR" where <Instance> is a 2-digit number.
There will be num_rcpwmgens instances, starting at 00.
Each instance allocates a single output pin. Unlike the standard PWM generator,
the rcpwmgen output is specified in width rather than duty cycle so the pulse width is independent of the operating frequency.
Resolution is approximately 1/2000 for standard 1 to 2 ms range RC servos.

Pins:

.TP
(float rw) rate
Sets the master RC PWM frequency. Maximum is 1 kHz, minimum is .01 Hz. Defaults to 50 Hz.

.TP
(float rw) width
Sets the per channel pulse width in (ms/scale).

.TP
(float rw) offset
Sets the per channel pulse width offset in ms.
This would be set to 1.5 ms for 1-2 ms servos for a 0 center position.

.TP
(float rw) scale
Sets the per channel pulse width scaling.
For example, setting the scale to 90 and the offset to 1.5 ms would result in a position range of +-45 degrees
and scale in degrees for 1-2 ms servos with a full motion range of 90 degrees.

.SS stepgen

stepgens have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.stepgen.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 stepgen instance number.
There are "num_stepgens" instances, starting with 00.

So, for example, the HAL pin that has the current position feedback from the first stepgen of the second 5I22 board is:
hm2_5i22.1.stepgen.00.position\-fb (this assumes that the firmware in that board is configured so that this HAL object is available).

Each stepgen uses between 2 and 8 IO pins.
The signals on these pins depends on the step_type parameter (described below).

The stepgen representation is modeled on the stepgen software component.
Each stepgen instance has the following pins and parameters:

Pins:

.TP
(float input) position\-cmd
Target position of stepper motion, in arbitrary position units.
This pin is only used when the stepgen is in position control mode (control\-type=0).

.TP
(float input) velocity\-cmd
Target velocity of stepper motion, in arbitrary position units per second.
This pin is only used when the stepgen is in velocity control mode (control\-type=1).

.TP
(s32 output) counts
Feedback position in counts (number of steps).

.TP
(float output) position\-fb
Feedback position in scaled position units.
This is similar to "counts/position_scale", but has finer than step resolution.

.TP
(float output) position-latched
latched-position in scaled position units.
This is similar to "counts/position_scale", but has finer than step resolution.


.TP
(float output) velocity\-fb
Feedback velocity in arbitrary position units per second.

.TP
(bit input) enable
This pin enables the step generator instance.
When True, the stepgen instance works as expected.
When False, no steps are generated and velocity\-fb goes immediately to 0.
If the stepgen is moving when enable goes False it stops immediately, without obeying the maxaccel limit.

.TP
(bit input) position\-reset
Resets position to 0 when True.
Useful for step/dir controlled spindles when switching between spindle and joint modes.

.TP
(bit input) control\-type
Switches between position control mode (0) and velocity control mode (1).
Defaults to position control (0).

.TP
(bit in/out) index\-enable
When this pin is set to True, the step count (and therefore also position) are reset to zero on the next stepgen index pulse.
At the same time, index\-enable is reset to zero to indicate that the pulse has occurred.

.TP
(bit r/w) index\-invert
If set to True, the rising edge of the index input pin triggers the position clear event (if index\-enable is True).
If set to False, the falling edge triggers.

.TP
(bit in/out) probe\-enable
When this pin is set to True, the step count (and therefore also position) are latched on the the next stepgen probe active edge.
At the same time, probe\-enable is reset to zero to indicate that a latch event has occurred.

.TP
(bit r/w) probe\-invert
If set to True, the rising edge of the probe input pin triggers the latch event (if probe\-enable is True).
If set to False, the falling edge triggers.

Parameters:

.TP
(float r/w) position\-scale
Converts from counts to position units.
position = counts / position_scale

.TP
(float r/w) maxvel
Maximum speed, in position units per second.
If set to 0, the driver will always use the maximum possible velocity based on the current step timings and position\-scale.
The max velocity will change if the step timings or position\-scale changes.  Defaults to 0.

.TP
(float r/w) maxaccel
Maximum acceleration, in position units per second per second.
Defaults to 1.0.
If set to 0, the driver will not limit its acceleration at all.
This requires that the position\-cmd or velocity\-cmd pin is driven in a way that does not exceed the machine's capabilities.
This is probably what you want if you are going to be using the LinuxCNC trajectory planner to jog or run G-code.

.TP
(u32 r/w) steplen
Duration of the step signal, in nanoseconds.

.TP
(u32 r/w) stepspace
Minimum interval between step signals, in nanoseconds.

.TP
(u32 r/w) dirsetup
Minimum duration of stable Direction signal before a step begins, in nanoseconds.

.TP
(u32 r/w) dirhold
Minimum duration of stable Direction signal after a step ends, in nanoseconds.

.TP
(u32 r/w) step_type
Output format, like the step_type modparam to the software stepgen(9) component:  0 = Step/Dir, 1 = Up/Down, 2 = Quadrature, 3+ = table-lookup mode.
In this mode the step_type parameter determines how long the step sequence is.
Additionally the stepgen_width parameter in the loadrt config string must be set to suit the number of pins per stepgen required.
Any stepgen pins above this number will be available for GPIO.
This mask defaults to 2.
The maximum length is 16.
Note that Table mode is not enabled in all firmwares but if you see GPIO pins between the stepgen instances in the dmesg/log hardware pin list then the option may be available.

In Quadrature mode (step_type=2), the stepgen outputs one complete Gray cycle (00 → 01 → 11 → 10 → 00) for each "step" it takes,
so the scale must be divided by 4 relative to standard step/dir.
In table mode up to 6 IO pins are individually controlled in an arbitrary sequence up to 16 phases long.

.TP
(bit input) swap_step_dir
This swaps the step and direction outputs on the selected stepgen.
This parameter is only available if the firmware supports this option.

.TP
(u32 r/w) table\-data\-N
There are 4 table\-data\-N parameters, table\-data\-0 to table\-data\-3.
These each contain 4 bytes corresponding to 4 stages in the step sequence.
For example table\-data\-0 = 0x00000001 would set stepgen pin 0 (always called "Step" in the dmesg output) on the first phase of the step sequence,
and table\-data\-4 = 0x20000000 would set stepgen pin 6 ("Table5Pin" in the dmesg output) on the 16th stage of the step sequence.

.TP
(s32 r/w) hm2_XXXX.N.stepgen.timer\-number (default: \-1)
Sets the hm2dpll timer instance to be used to latch stepgen counts.
A setting of \-1 does not latch stepgen counts.
A setting of 0 latches at the same time as the main hostmot2 read.
A setting of 1..4 uses a time offset from the main hostmot2 read according to the dpll's timer\-us setting.

Typically, timer\-us should be a negative number with a magnitude larger than the largest latency
(e.g., \-100 for a system with mediocre latency, \-50 for a system with good latency).
A negative number specifies latching the specified time before the nominal hostmot2 read time.

If no DPLL module is present in the FPGA firmware, or if the stepgen module does not support DPLL, then this pin is not created.

When available, this feature should typically be enabled.
Doing so generally reduces following errors.

.SS Smart Serial Interface

The Smart Serial Interface allows up to 32 different devices such as the Mesa 8i20 2.2 kW 3-phase drive or 7I64 48-way IO cards to be connected to a single FPGA card.
The driver auto-detects the connected hardware port, channel and device type.
Devices can be connected in any order to any active channel of an active port (see the config modparam definition above).

For full details of the smart-serial devices see \fBsserial\fR(9).

.SS BSPI
The BSPI (Buffered SPI) driver is unusual in that it does not create any HAL pins.
Instead the driver exports a set of functions that can be used by a sub-driver for the attached hardware.
Typically, these would be written in the "comp".

pre-processing language: see http://linuxcnc.org/docs/html/hal/comp.html or man halcompile for further details.
See mesa_7i65(9) and the source of mesa_7i65.comp for details of a typical sub-driver.
See hm2_bspi_setup_chan(3hm2), hm2_bspi_write_chan(3hm2),
hm2_tram_add_bspi_frame(3hm2), hm2_allocate_bspi_tram(3hm2),
hm2_bspi_set_read_function(3hm2) and hm2_bspi_set_write_function(3hm2) for the exported functions.

The names of the available channels are printed to standard output during the driver loading process
and take the form hm2_<board name>.<board index>.bspi.<index>, e.g., hm2_5i23.0.bspi.0.

.SS UART
The UART driver also does not create any HAL pins, instead it declares two simple read/write functions and a setup function to be utilised by user-written code.
Typically this would be written in the "comp" pre-processing language: see http://linuxcnc.org/docs/html/hal/comp.html or man halcompile for further details.
See mesa_uart(9) and the source of mesa_uart.comp for details of a typical sub-driver.
See hm2_uart_setup_chan(3hm2), hm2_uart_send(3hm2), hm2_uart_read(3hm2) and hm2_uart_setup(3hm2).

The names of the available uart channels are printed to standard output during the driver loading process
and take the form hm2_<board name>.<board index>uart.<index>, e.g., hm2_5i23.0.uart.0.

.SS General Purpose I/O

I/O pins on the board which are not used by a module instance are exported to HAL as "full" GPIO pins.
Full GPIO pins can be configured at run-time to be inputs, outputs, or open drains, and have a HAL interface that exposes this flexibility.
I/O pins that are owned by an active module instance are constrained by the requirements of the owning module, and have a restricted HAL interface.

GPIOs have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.gpio.\fI<IONum>\fR".
IONum is a three-digit number.
The mapping from IONum to connector and pin-on-that-connector is written to the syslog when the driver loads,
and it is documented in Mesa's manual for the Anything I/O boards.

So, for example, the HAL pin that has the current inverted input value read from GPIO 012 of the second 7I43 board is:
hm2_7i43.1.gpio.012.in\-not (this assumes that the firmware in that board is configured so that this HAL object is available).

The HAL parameter that controls whether the last GPIO of the first 5I22 is an input or an output is:
hm2_5i22.0.gpio.095.is_output (this assumes that the firmware in that board is configured so that this HAL object is available).

The hm2 GPIO representation is modeled after the Digital Inputs and Digital Outputs described in the Canonical Device Interface (part of the HAL General Reference document).
Each GPIO can have the following HAL Pins:

.TP
(bit out) in & in_not
State (normal and inverted) of the hardware input pin.
Both full GPIO pins and IO pins used as inputs by active module instances have these pins.

.TP
(bit in) out
Value to be written (possibly inverted) to the hardware output pin.
Only full GPIO pins have this pin.

.PP
Each GPIO can have the following Parameters:

.TP
(bit r/w) is_output
If set to 0, the GPIO is an input.
The IO pin is put in a high-impedance state (weakly pulled high), to be driven by other devices.
The logic value on the IO pin is available in the "in" and "in_not" HAL pins.
Writes to the "out" HAL pin have no effect.
If this parameter is set to 1, the GPIO is an output; its behavior then depends on the "is_opendrain" parameter.
Only full GPIO pins have this parameter.

.TP
(bit r/w) is_opendrain
This parameter only has an effect if the "is_output" parameter is True.
If this parameter is False, the GPIO behaves as a normal output pin:
The IO pin on the connector is driven to the value specified by the "out" HAL pin (possibly inverted), and the value of the "in" and "in_not" HAL pins is undefined.
If this parameter is True, the GPIO behaves as an open-drain pin.
Writing 0 to the "out" HAL pin drives the IO pin low, writing 1 to the "out" HAL pin puts the IO pin in a high-impedance state.
In this high-impedance state the IO pin floats (weakly pulled high), and other devices can drive the value;
the resulting value on the IO pin is available on the "in" and "in_not" pins.
Only full GPIO pins and IO pins used as outputs by active module instances have this parameter.

.TP
(bit r/w) invert_output
This parameter only has an effect if the "is_output" parameter is True.
If this parameter is True, the output value of the GPIO will be the inverse of the value on the "out" HAL pin.
Only full GPIO pins and IO pins used as outputs by active module instances have this parameter.

.PP
When a physical I/O pin is used by a special function, the related
.BR is_output ", and " is_opendrain
HAL parameters are aliased to the special function.
For instance, if gpio 1 is taken over by pwmgen 0's first output, then aliases like
.B hm2_7i92.0.pwmgen.00.out0.invert_output
(referring to
.BR hm2_7i92.0.gpio.001.invert_output )
will be automatically created.
When more than one GPIO is connected to the same special function, an extra .#. is inserted so that the settings for each related GPIO can be set separately.
For example, for the firmware SV12IM_2X7I48_72, the alias
.B hm2_5i20.0.pwmgen.00.0.enable.invert_output
(referring to
.BR hm2_5i20.0.gpio.000.invert_output )
and
.B hm2_5i20.0.pwmgen.00.1.enable.invert_output
(referring to
.BR hm2_5i20.0.gpio.023.invert_output )
are both created.

.SS inm and inmux
inm/inmuxs are input debouncing modules that support hardware digital filtering of input pins.
In addition to the input filtering function, the inm/inmux modules support up to 4 simple quadrature counters for MPG use.
The quadrature inputs for MPG encoders 0 through 3 are inm/inmux pins 0 through 7.
MPG A,B inputs use the filter time constants programmed for inputs 0..7.
Each inm/inmux input pin can have a slow or fast filter constant.
Filter time constants are specified in units of scan times.
inms have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.inm.\fI<Instance>\fR".
inmuxes have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.inmux.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 inm or inmux instance number.
There are "num_inms" or numx_inmuxs" instances, starting with 00.

Each instance reads between 8 and 32 input pins. inm and inmux are identical except for pin names and the physical interface.

Pins:

.TP
(bit out) input and input-not
True and inverted filtered input states.

.TP
(bit out) raw-input and raw-input-not
True and inverted unfiltered input states.

.TP
(bit in) input-slow
If True, selects the long time constant filter for the corresponding input bit,
if False the short time constant is used.

.TP
(s32 out) enc0-count,enc1-count,enc2-count,enc3-count
MPG counters 0 through 3.

.TP
(bit in) enc0-reset,enc1-reset,enc2-reset,enc3-reset
Reset for MPG counters 0 through 3, count is forced to 0 if true.

.TP

Parameters:

.TP
(u32 in) scan_rate
This sets the input scan rate in Hz. Default scan rate is 20 kHz (50 µs scan period).

.TP
(u32 in) fast_scans
This sets the fast time constant for all input pins.
This is the time constant used when the input-slow pin for the corresponding input is False.
The range is 0 to 63 scan periods and the default value is 5 = 250 µs at the default 20 kHz scan_rate.

.TP
(u32 in) slow_scans
This sets the slow time constant for all input pins.
This is the time constant used when the input-slow pin for the corresponding input is True.
The range is 0 to 1023 scan periods and the default value is 500 = 25 ms at the default 20 kHz scan_rate.

.TP
(bit in) enc0_4xmode, enc1_4xmode, enc2_4xmode, and enc3_4xmode
These set the MPG encoder operating modes to 4X when True and 1X when False.

.TP
(u32 out) scan_width
This read only parameter specifies the number of inputs scanned by the module.


.SS led
Creates HAL pins for the LEDs on the FPGA board.

Pins:

.TP
(bit in) CR<NN>
The pins are numbered from CR01 upwards with the name corresponding to the PCB silkscreen.
Setting the bit to "True" or 1 lights the LED.

.SS Solid State Relay

SSRs have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.ssr.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 SSR instance number.
There are "num_ssrs" instances, starting with 00.

Each instance has a rate control pin and between 1 and 32 output pins.

Pins:

.TP
(u32 in) rate
Set the internal frequency of the SSR instance, in Hz (approximate).
The valid range is 25 kHz to 25 MHz.
Values below the minimum will use the minimum, and values above the max will use the max.
1 MHz is a typical value, and appropriate for all Mesa cards, and is the default.
Set to 0 to disable this SSR instance.

.TP
(bit in) out-NN
The state of this SSR instance's NNth output.
Set to 0 to make the output pins act like an open switch (no connection), set to 1 to make them act like a closed switch.

.TP
(bit in) invert-NN
Inverts the state of this SSR instance's NNth output, defaults to 0.
When invert-NN is set to 1, SSR output NN is closed when the out-NN pin is 0 and open when the out-NN pin is 1.

.SH OutM Simple output module

OutMs have names like "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.OutM.\fI<Instance>\fR".
"Instance" is a two-digit number that corresponds to the HostMot2 OutM instance number.
There are "num_outms" instances, starting with 00.

Each instance has between 1 and 32 output pins.

Pins:

.TP
(bit in) out-NN
The sets the state of this OutM instance's NNth output.
Normally the output pin follows the state of this pin but may be inverted by the invert-nn HAL pin.

.TP
(bit in) invert-NN
Inverts the state of the this OutM instance's NNth output, defaults to 0.
When invert-NN is set to 1, OutM output NN is high when the out-NN pin is 0 and low when the out-NN pin is 1.

.SH xy2mod

The xy2mod is a xy2-100 galvanometer interface.
It supports 16 and 18 bit data modes and includes parabolic interpolation to provide position updates between servo thread invocations.

.TP
Pins:

.TP
(float in) posx_cmd, posy_cmd
X and Y position commands. Full scale is +-posn_scale default full scale (set by posx_scale and posy_scale) is +- 1

.TP
(float out) posx_fb, posy_fb
X and Y position feedback. Full scale is +-posN_scale default full scale is +- 1.
This is feedback from the interpolator not the galvanometer.

.TP
(float in) velx_cmd, vely_cmd
X and Y velocity commands in units of fullscale_position/second

.TP
(float out) velx_fb, vely_fb
X and Y velocity feedback in units of fullscale_position/second

.TP
(float in) accx_cmd, accy_cmd
X and Y acceleration commands in units of fullscale_position/second^2

.TP
(float in) posx_scale, posy_scale
This sets the full scale range of the position command and feedback, default is +- 1.0.

.TP
(bit in) enable
when False, output data is 0, all interpolator values are set to 0 and overflow flags are cleared.
Must be True for normal operation.

.TP
(u32 in) controlx, controly
These set the galvanometer control bits.
There 3 bits per channel in 16 bit mode but just 1 control bit in 18 bit mode, so values from 0..7 are valid in 16 bit mode but only 0 and 4 are valid in 18 bit mode.

.TP
(u32 in) commandx, commandy
These set the raw 16 bit data sent to the galvanometer in command mode.

.TP
(bit in) commandmodex, commandmodey
When set, these enable the command mode where 16 bit command data is sent to the galvanometer.

.TP
(bit in) 18bitmodex, 18bitmodey
When True, these enable the 18 bit data mode for the respective channel.

.TP
(bit out) posx-overflow, posy-overflow
When true, these indicate an attempted position move beyond the full scale value.

.TP
(bit out) velx-overflow, vely-overflow
When True, these indicate an attempted velocity update move beyond the full scale value.

.TP
(u32 out) status
Raw 16 bit return status from galvanometer.

.TP
Parameters:

.TP
(s32 in) read-timer-number
Selects the DPLL timer number for pre-read sampling of the position and velocity registers.
If set to -1, pre-read sampling is disabled.

.TP
(s32 in) write-timer-number
Selects the DPLL timer number for post write update of the position and velocity registers.
If set to -1, post write update is disabled.

.SS Watchdog

The HostMot2 firmware may include a watchdog Module; if it does, the hostmot2 driver will use it.
The HAL representation of the watchdog is named "hm2_\fB<BoardType>\fR.\fB<BoardNum>\fR.watchdog".

The watchdog starts out asleep and inactive.
Once you access the board the first time by running the hm2 write() HAL function (see below), the watchdog wakes up.
From them on it must be petted periodically or it will bite.
Pet the watchdog by running the hm2 write() HAL function.

When the watchdog bites,
all the board's I/O pins are disconnected from their Module instances and become high-impedance inputs (pulled high),
and all communication with the board stops.
The state of the HostMot2 firmware modules is not disturbed (except for the configuration of the IO pins).
Encoder instances keep counting quadrature pulses,
and pwm- and step-generators keep generating signals (which are *not* relayed to the motors, because the IO pins have become inputs).

Resetting the watchdog (by clearing the has_bit pin, see below) resumes communication and
resets the I/O pins to the configuration chosen at load-time.

If the firmware includes a watchdog, the following HAL objects will be exported:

Pins:

.TP
(bit in/out) has_bit
True if the watchdog has bit, False if the watchdog has not bit.
If the watchdog has bit and the has_bit bit is True, the user can reset it to False to resume operation.

Parameters:

.TP
(u32 read/write) timeout_ns
Watchdog timeout, in nanoseconds.
This is initialized to 5,000,000 (5 milliseconds) at module load time.
If more than this amount of time passes between calls to the hm2 write() function, the watchdog will bite.

.SS Raw Mode
If the "enable_raw" config keyword is specified, some extra debugging pins are made available in HAL.
The raw mode HAL pin names begin with "hm2_\fI<BoardType>\fR.\fI<BoardNum>\fR.raw".

With Raw mode enabled, a user may peek and poke the firmware from HAL,
and may dump the internal state of the hostmot2 driver to the syslog.

Pins:

.TP
(u32 in) read_address
The bottom 16 bits of this is used as the address to read from.

.TP
(u32 out) read_data
Each time the hm2_read() function is called, this pin is updated with the value at .read_address.

.TP
(u32 in) write_address
The bottom 16 bits of this is used as the address to write to.

.TP
(u32 in) write_data
This is the value to write to .write_address.

.TP
(bit in) write_strobe
Each time the hm2_write() function is called, this pin is examined.
If it is True, then value in .write_data is written to the address in .write_address, and .write_strobe is set back to False.

.TP
(bit in/out) dump_state
This pin is normally False.
If it gets set to True the hostmot2 driver will write its representation of the board's internal state to the syslog, and set the pin back to False.

.SS Setting up Smart Serial devices

See setsserial(9) for the current way to set smart-serial eeprom parameters.

.SH FUNCTIONS
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read\-request\fR
On boards with long turn around time for reads (at the time of writing,
this applies only to ethernet boards), this function sends a read request.
When multiple boards are used, this can reduce the servo thread execution time.
In this case, the appropriate thread order would be
.EX
addf hm2_7i80.0.read\-request
addf hm2_7i80.1.read\-request
addf hm2_7i80.0.read
addf hm2_7i80.1.read
.EE
which causes the read request to be sent to board 1 before waiting for the response to the read request to arrive from board 0.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read\fR
This reads the encoder counters, stepgen feedbacks, and GPIO input pins from the FPGA.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.write\fR
This updates the PWM duty cycles, stepgen rates, and GPIO outputs on the FPGA.
Any changes to configuration pins such as stepgen timing, GPIO inversions, etc., are also effected by this function.
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.read_gpio\fR
Read the GPIO input pins.
Note that the effect of this function is a subset of the effect of the .read() function described above.
Normally only .read() is used.
The only reason to call this function is if you want to do GPIO things in a faster-than-servo thread.
(This function is not available on the 7I43 due to limitations of the EPP bus.)
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.write_gpio\fR
Write the GPIO control registers and output pins.
Note that the effect of this function is a subset of the effect of the .write() function described above.
Normally only .write() is used.
The only reason to call this function is if you want to do GPIO things in a faster-than-servo thread.
(This function is not available on the 7I43 due to limitations of the EPP bus.)
.TP
\fBhm2_\fI<BoardType>\fB.\fI<BoardNum>\fB.trigger\-encoders\fR
This function will only appear if the firmware contains a BiSS, Fanuc or SSI encoder module and if the firmware does not contain a hm2dpll
module (qv) or if the modparam contains num_dplls=0.
This function should be inserted first in the thread so that the encoder data is ready when the main \fBhm2_\fR\fIXXXX\fR\fB.\fR\fINN\fR\fB.read\fR function runs.
An error message will be printed if the encoder read is not finished in time.
It may be possible to avoid this by increasing the data rate.
If the problem persists and if "stale" data is acceptable then the function may be placed later in the thread,
allowing a full servo cycle for the data to be transferred from the devices.
If available it is better to use the synchronous hm2dpll triggering function.

.SH SEE ALSO

\fBhm2_pci\fR(9),
\fBhm2_eth\fR(9),
\fBhm2_spi\fR(9),
\fBhm2_rpspi\fR(9),
\fBhm2_7i43\fR(9),
\fBhm2_7i90\fR(9)

Mesa's documentation for the Anything I/O boards, at
.UR
http://www.mesanet.com
.UE
.br
.SH LICENSE

GPL
