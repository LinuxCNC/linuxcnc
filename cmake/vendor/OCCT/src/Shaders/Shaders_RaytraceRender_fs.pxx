// This file has been automatically generated from resource file src/Shaders/RaytraceRender.fs

static const char Shaders_RaytraceRender_fs[] =
  "out vec4 OutColor;\n"
  "\n"
  "// Seed for random number generator (generated on CPU).\n"
  "uniform int uFrameRndSeed;\n"
  "\n"
  "//! Enables/disables using of single RNG seed for 16x16 image\n"
  "//! blocks. Increases performance up to 4x, but the noise has\n"
  "//! become structured. Can be used fo final rendering.\n"
  "uniform int uBlockedRngEnabled;\n"
  "\n"
  "//! Number of previously rendered frames (used in non-ISS mode).\n"
  "uniform int uAccumSamples;\n"
  "\n"
  "#ifndef ADAPTIVE_SAMPLING\n"
  "  //! Input image with previously accumulated samples.\n"
  "  uniform sampler2D uAccumTexture;\n"
  "#endif\n"
  "\n"
  "//! Maximum radiance that can be added to the pixel.\n"
  "//! Decreases noise level, but introduces some bias.\n"
  "uniform float uMaxRadiance;\n"
  "\n"
  "#ifdef ADAPTIVE_SAMPLING\n"
  "//! Wrapper over imageLoad()+imageStore() having similar syntax as imageAtomicAdd().\n"
  "//! Modifies one component of 3Wx2H uRenderImage:\n"
  "//! |RGL| Red, Green, Luminance\n"
  "//! |SBH| Samples, Blue, Hit time transformed into OpenGL NDC space\n"
  "//! Returns previous value of the component.\n"
  "float addRenderImageComp (in ivec2 theFrag, in ivec2 theComp, in float theVal)\n"
  "{\n"
  "  ivec2 aCoord = ivec2 (3 * theFrag.x + theComp.x,\n"
  "                        2 * theFrag.y + theComp.y);\n"
  "#ifdef ADAPTIVE_SAMPLING_ATOMIC\n"
  "  return imageAtomicAdd (uRenderImage, aCoord, theVal);\n"
  "#else\n"
  "  float aVal = imageLoad (uRenderImage, aCoord).x;\n"
  "  imageStore (uRenderImage, aCoord, vec4 (aVal + theVal));\n"
  "  return aVal;\n"
  "#endif\n"
  "}\n"
  "#endif\n"
  "\n"
  "// =======================================================================\n"
  "// function : main\n"
  "// purpose  :\n"
  "// =======================================================================\n"
  "void main (void)\n"
  "{\n"
  "  SeedRand (uFrameRndSeed, uWinSizeX, uBlockedRngEnabled == 0 ? 1 : 16);\n"
  "\n"
  "#ifndef PATH_TRACING\n"
  "\n"
  "  SRay aRay = GenerateRay (vPixel);\n"
  "\n"
  "#else\n"
  "\n"
  "  ivec2 aFragCoord = ivec2 (gl_FragCoord.xy);\n"
  "\n"
  "#ifdef ADAPTIVE_SAMPLING\n"
  "\n"
  "#ifdef ADAPTIVE_SAMPLING_ATOMIC\n"
  "  ivec2 aTileXY = imageLoad (uOffsetImage, aFragCoord / uTileSize).xy * uTileSize;\n"
  "  if (aTileXY.x < 0) { discard; }\n"
  "\n"
  "  ivec2 aRealBlockSize = ivec2 (min (uWinSizeX - aTileXY.x, uTileSize.x),\n"
  "                                min (uWinSizeY - aTileXY.y, uTileSize.y));\n"
  "\n"
  "  aFragCoord.x = aTileXY.x + (aFragCoord.x % aRealBlockSize.x);\n"
  "  aFragCoord.y = aTileXY.y + (aFragCoord.y % aRealBlockSize.y);\n"
  "#else\n"
  "  int aNbTileSamples = imageAtomicAdd (uTilesImage, aFragCoord / uTileSize, int(-1));\n"
  "  if (aNbTileSamples <= 0)\n"
  "  {\n"
  "    discard;\n"
  "  }\n"
  "#endif\n"
  "\n"
  "#endif // ADAPTIVE_SAMPLING\n"
  "\n"
  "  vec2 aPnt = vec2 (float(aFragCoord.x) + RandFloat(),\n"
  "                    float(aFragCoord.y) + RandFloat());\n"
  "\n"
  "  SRay aRay = GenerateRay (aPnt / vec2 (uWinSizeX, uWinSizeY));\n"
  "\n"
  "#endif // PATH_TRACING\n"
  "\n"
  "  vec3 aInvDirect = InverseDirection (aRay.Direct);\n"
  "\n"
  "#ifdef PATH_TRACING\n"
  "\n"
  "#ifndef ADAPTIVE_SAMPLING\n"
  "  vec4 aColor = PathTrace (aRay, aInvDirect, uAccumSamples);\n"
  "#else\n"
  "  float aNbSamples = addRenderImageComp (aFragCoord, ivec2 (0, 1), 1.0);\n"
  "  vec4 aColor = PathTrace (aRay, aInvDirect, int (aNbSamples));\n"
  "#endif\n"
  "\n"
  "  if (any (isnan (aColor.rgb)))\n"
  "  {\n"
  "    aColor.rgb = ZERO;\n"
  "  }\n"
  "  aColor.rgb = min (aColor.rgb, vec3 (uMaxRadiance));\n"
  "\n"
  "#ifdef ADAPTIVE_SAMPLING\n"
  "\n"
  "  // accumulate RGB color and depth\n"
  "  addRenderImageComp (aFragCoord, ivec2 (0, 0), aColor.r);\n"
  "  addRenderImageComp (aFragCoord, ivec2 (1, 0), aColor.g);\n"
  "  addRenderImageComp (aFragCoord, ivec2 (1, 1), aColor.b);\n"
  "  addRenderImageComp (aFragCoord, ivec2 (2, 1), aColor.w);\n"
  "  if (int (aNbSamples) % 2 == 0) // accumulate luminance for even samples only\n"
  "  {\n"
  "    addRenderImageComp (aFragCoord, ivec2 (2, 0), dot (LUMA, aColor.rgb));\n"
  "  }\n"
  "\n"
  "#else\n"
  "\n"
  "  if (uAccumSamples == 0)\n"
  "  {\n"
  "    OutColor = aColor;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    OutColor = mix (texture (uAccumTexture, vPixel), aColor, 1.0 / float(uAccumSamples + 1));\n"
  "  }\n"
  "\n"
  "#endif // ADAPTIVE_SAMPLING\n"
  "\n"
  "#else\n"
  "\n"
  "  OutColor = clamp (Radiance (aRay, aInvDirect), 0.f, 1.f);\n"
  "\n"
  "#endif // PATH_TRACING\n"
  "}\n";
