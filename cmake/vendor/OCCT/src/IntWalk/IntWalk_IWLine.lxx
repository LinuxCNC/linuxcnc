// Copyright (c) 1995-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <Standard_DomainError.hxx>
#include <IntSurf_LineOn2S.hxx>
#include <IntSurf_Couple.hxx>
#include <IntSurf_SequenceOfCouple.hxx>

inline void IntWalk_IWLine::Cut(const Standard_Integer Index)
{
//--   std::cout<<" split : "<<Index<<std::endl;
  Handle(IntSurf_LineOn2S) lost = line->Split(Index);
}

inline void IntWalk_IWLine::AddPoint(const IntSurf_PntOn2S& P)
{
  line->Add(P);
}

inline void IntWalk_IWLine::AddStatusFirst(const Standard_Boolean Closed,
					   const Standard_Boolean HasFirst)
{
  closed = Closed;
  hasFirst = HasFirst; 
}

inline void IntWalk_IWLine::AddStatusLast (const Standard_Boolean HasLast)
{
  hasLast = HasLast; 
}

inline void IntWalk_IWLine::AddStatusFirst(const Standard_Boolean Closed,
					   const Standard_Boolean HasFirst,
					   const Standard_Integer Index,
					   const TheStartPoint& P ) {
  closed = Closed;
  hasFirst = HasFirst; 
  firstIndex = Index;
  theFirstPoint = P;
}

inline void IntWalk_IWLine::AddStatusLast(const Standard_Boolean HasLast,
					  const Standard_Integer Index,
					  const TheStartPoint& P ) {
  hasLast = HasLast; 
  lastIndex = Index;
  theLastPoint = P;
}

inline void IntWalk_IWLine::AddStatusFirstLast(const Standard_Boolean Closed,
					       const Standard_Boolean HasFirst,
					       const Standard_Boolean HasLast )
{
  closed = Closed;
  hasFirst = HasFirst; 
  hasLast = HasLast;
}

inline void IntWalk_IWLine::AddIndexPassing(const Standard_Integer Index)

{
  couple.Append(IntSurf_Couple(line->NbPoints()+1, Index));
}

inline Standard_Integer IntWalk_IWLine::NbPoints() const
{
  return line->NbPoints();
}
  
inline const IntSurf_PntOn2S& IntWalk_IWLine::Value
  (const Standard_Integer Index) const
{
  return line->Value(Index);
}

inline const Handle(IntSurf_LineOn2S)& IntWalk_IWLine::Line () const
{
  return line;
}

inline Standard_Boolean IntWalk_IWLine::IsClosed() const
{
  return closed;
}

inline Standard_Boolean IntWalk_IWLine::HasFirstPoint() const
{
  return hasFirst;
}

inline Standard_Integer IntWalk_IWLine::FirstPointIndex() const
{
  if (!hasFirst) throw Standard_DomainError();
  return firstIndex;
}

inline const TheStartPoint& IntWalk_IWLine::FirstPoint() const
{
 if (!hasFirst) throw Standard_DomainError();
 return theFirstPoint;
}

inline Standard_Boolean IntWalk_IWLine::HasLastPoint() const
{
  return hasLast;
}

inline const TheStartPoint& IntWalk_IWLine::LastPoint() const
{
  if (!hasLast) throw Standard_DomainError();
  return theLastPoint;
}

inline Standard_Integer IntWalk_IWLine::LastPointIndex() const
{
  if (!hasLast) throw Standard_DomainError();
  return lastIndex;
}

inline Standard_Integer IntWalk_IWLine::NbPassingPoint() const
{ 
  return couple.Length();
}

inline void IntWalk_IWLine::PassingPoint(const Standard_Integer Index,
					 Standard_Integer& IndexLine,
					 Standard_Integer& IndexPnts) const 
{
  IndexLine = couple(Index).First();
  IndexPnts = couple(Index).Second();
}

inline void IntWalk_IWLine::SetTangentVector (const gp_Vec& V,
					      const Standard_Integer Index) {
  indextg = Index;
  vcttg = V;
  
  //-- std::cout<<"\n IntWalk_IWLine::SetTangentVector : "<<V.X()<<" "<<V.Y()<<" "<<V.Z()<<"   Ind:"<<Index<<"  NbPts:"<<NbPoints()<<std::endl;
  
}

inline void IntWalk_IWLine::SetTangencyAtBegining
  (const Standard_Boolean IsTangent) {

  istgtend = IsTangent;
}

inline void IntWalk_IWLine::SetTangencyAtEnd
  (const Standard_Boolean IsTangent) {

  istgtend = IsTangent;
}

inline const gp_Vec& IntWalk_IWLine::TangentVector
  (Standard_Integer& Index) const {
//--    if(istgtend == Standard_False && istgtbeg == Standard_False) { 
//--      std::cout<<" IntWalk_IWLine.lxx : Pb "<<std::endl;
//--    }
  Index = indextg;
  return vcttg;
}

inline Standard_Boolean IntWalk_IWLine::IsTangentAtBegining () const {

  return istgtbeg;
}

inline Standard_Boolean IntWalk_IWLine::IsTangentAtEnd () const {

  return istgtend;
}


