// Created on: 2005-09-08
// Created by: Alexander GRIGORIEV
// Copyright (c) 2005-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <gp_Pnt.hxx>

#ifndef Bnd_B3x_RealLast
#define Bnd_B3x_RealLast RealType(1e30);
#endif

/**
 * Empty constructor
 */
inline Bnd_B3x::Bnd_B3x ()
{
  Clear();
}

/**
 * Constructor.
 * @param theCenter
 *   Center of the created box
 * @param theHSize
 *   Half-diagonal of the box, both X and Y should be non-negative
 */
inline Bnd_B3x::Bnd_B3x (const gp_XYZ& theCenter,
                         const gp_XYZ& theHSize)
{
  myCenter[0] = RealType(theCenter.X());
  myCenter[1] = RealType(theCenter.Y());
  myCenter[2] = RealType(theCenter.Z());
  myHSize[0]  = RealType(theHSize.X());
  myHSize[1]  = RealType(theHSize.Y());
  myHSize[2]  = RealType(theHSize.Z());
}

/**
 * Reset the box data.
 */
inline void Bnd_B3x::Clear ()
{
  myCenter[0] = Bnd_B3x_RealLast;
  myCenter[1] = Bnd_B3x_RealLast;
  myCenter[2] = Bnd_B3x_RealLast;
  myHSize[0] = -Bnd_B3x_RealLast;
  myHSize[1] = -Bnd_B3x_RealLast;
  myHSize[2] = -Bnd_B3x_RealLast;
}

/**
 * Check if the box is empty.
 */
inline Standard_Boolean Bnd_B3x::IsVoid () const
{
  return (myHSize[0] < -1e-5);
}

/**
 * Update the box by point.
 */
inline void Bnd_B3x::Add (const gp_Pnt& thePnt)
{
  Add (thePnt.XYZ());
}

/**
 * Update the box by another box.
 */
inline void Bnd_B3x::Add (const Bnd_B3x& theBox)
{
  if (theBox.IsVoid() == Standard_False) {
    Add (theBox.CornerMin());
    Add (theBox.CornerMax());
  }
}

/**
 * Query a box corner.
 */
inline gp_XYZ Bnd_B3x::CornerMin () const
{
  return gp_XYZ (myCenter[0] - myHSize[0],
                 myCenter[1] - myHSize[1],
                 myCenter[2] - myHSize[2]);
}

/**
 * Query a box corner.
 */
inline gp_XYZ Bnd_B3x::CornerMax () const
{
  return gp_XYZ (myCenter[0] + myHSize[0],
                 myCenter[1] + myHSize[1],
                 myCenter[2] + myHSize[2]);
}

/**
 * Query the square diagonal.
 */
inline Standard_Real Bnd_B3x::SquareExtent () const
{
  return 4 * (myHSize[0] * myHSize[0] +
              myHSize[1] * myHSize[1] +
              myHSize[2] * myHSize[2]);
}

/**
 * Set the Center coordinates.
 */
inline void Bnd_B3x::SetCenter (const gp_XYZ& theCenter)
{
  myCenter[0] = RealType(theCenter.X());
  myCenter[1] = RealType(theCenter.Y());
  myCenter[2] = RealType(theCenter.Z());
}

/**
 * Set the Center coordinates.
 */
inline void Bnd_B3x::SetHSize (const gp_XYZ& theHSize)
{
  myHSize[0] = RealType(theHSize.X());
  myHSize[1] = RealType(theHSize.Y());
  myHSize[2] = RealType(theHSize.Z());
}

/**
 * Increase the box.
 * @param aDiff
 *   absolute value of this parameter is added to the box size in all dimensions.
 */
inline void Bnd_B3x::Enlarge (const Standard_Real aDiff)
{
  const Standard_Real aD = Abs(aDiff);
  myHSize[0] += RealType(aD);
  myHSize[1] += RealType(aD);
  myHSize[2] += RealType(aD);
}

/**
 * Intersection Box - Point
 */
inline Standard_Boolean Bnd_B3x::IsOut (const gp_XYZ& thePnt) const
{
  return (Abs(RealType(thePnt.X()) - myCenter[0]) > myHSize[0] ||
          Abs(RealType(thePnt.Y()) - myCenter[1]) > myHSize[1] ||
          Abs(RealType(thePnt.Z()) - myCenter[2]) > myHSize[2]);
}

/**
 * Intersection Box-Box.
 */
inline Standard_Boolean Bnd_B3x::IsOut (const Bnd_B3x& theBox) const
{
  return (Abs(theBox.myCenter[0]-myCenter[0]) > theBox.myHSize[0]+myHSize[0] ||
          Abs(theBox.myCenter[1]-myCenter[1]) > theBox.myHSize[1]+myHSize[1] ||
          Abs(theBox.myCenter[2]-myCenter[2]) > theBox.myHSize[2]+myHSize[2]);
}

/**
 * Test the complete inclusion of this box in theBox.
 */
inline Standard_Boolean Bnd_B3x::IsIn (const Bnd_B3x& theBox) const
{
  return (Abs(theBox.myCenter[0]-myCenter[0]) < theBox.myHSize[0]-myHSize[0] &&
          Abs(theBox.myCenter[1]-myCenter[1]) < theBox.myHSize[1]-myHSize[1] &&
          Abs(theBox.myCenter[2]-myCenter[2]) < theBox.myHSize[2]-myHSize[2]);
}

